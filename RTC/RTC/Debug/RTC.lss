
RTC.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002460  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000003c  00800060  00002460  000024f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000008a  0080009c  0080009c  00002530  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002530  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002560  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000548  00000000  00000000  0000259c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005cd2  00000000  00000000  00002ae4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000166f  00000000  00000000  000087b6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000342f  00000000  00000000  00009e25  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000f60  00000000  00000000  0000d254  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a59  00000000  00000000  0000e1b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000476d  00000000  00000000  0000fc0d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004c8  00000000  00000000  0001437a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 90 00 	jmp	0x120	; 0x120 <__vector_1>
       8:	0c 94 b7 00 	jmp	0x16e	; 0x16e <__vector_2>
       c:	0c 94 de 00 	jmp	0x1bc	; 0x1bc <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 11 08 	jmp	0x1022	; 0x1022 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e6       	ldi	r30, 0x60	; 96
      68:	f4 e2       	ldi	r31, 0x24	; 36
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ac 39       	cpi	r26, 0x9C	; 156
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	21 e0       	ldi	r18, 0x01	; 1
      78:	ac e9       	ldi	r26, 0x9C	; 156
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 32       	cpi	r26, 0x26	; 38
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 c3 04 	call	0x986	; 0x986 <main>
      8a:	0c 94 2e 12 	jmp	0x245c	; 0x245c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <EXTI_Init>:
 * param : Handler is a pointer to struct that hold all information a bout the INIT 
 * return : void 
*/  
void EXIT_DISABLE(EXIT_Handler_t * Handler)
{
	GICR &=~(1<<(5+Handler->EXTI_NUM));  /* disable the required INIT */
      92:	fc 01       	movw	r30, r24
      94:	80 81       	ld	r24, Z
      96:	81 11       	cpse	r24, r1
      98:	0b c0       	rjmp	.+22     	; 0xb0 <EXTI_Init+0x1e>
      9a:	81 81       	ldd	r24, Z+1	; 0x01
      9c:	82 30       	cpi	r24, 0x02	; 2
      9e:	21 f4       	brne	.+8      	; 0xa8 <EXTI_Init+0x16>
      a0:	84 b7       	in	r24, 0x34	; 52
      a2:	8f 7b       	andi	r24, 0xBF	; 191
      a4:	84 bf       	out	0x34, r24	; 52
      a6:	1d c0       	rjmp	.+58     	; 0xe2 <EXTI_Init+0x50>
      a8:	84 b7       	in	r24, 0x34	; 52
      aa:	80 64       	ori	r24, 0x40	; 64
      ac:	84 bf       	out	0x34, r24	; 52
      ae:	19 c0       	rjmp	.+50     	; 0xe2 <EXTI_Init+0x50>
      b0:	85 b7       	in	r24, 0x35	; 53
      b2:	80 7f       	andi	r24, 0xF0	; 240
      b4:	85 bf       	out	0x35, r24	; 53
      b6:	20 81       	ld	r18, Z
      b8:	21 30       	cpi	r18, 0x01	; 1
      ba:	29 f4       	brne	.+10     	; 0xc6 <EXTI_Init+0x34>
      bc:	95 b7       	in	r25, 0x35	; 53
      be:	81 81       	ldd	r24, Z+1	; 0x01
      c0:	89 2b       	or	r24, r25
      c2:	85 bf       	out	0x35, r24	; 53
      c4:	0e c0       	rjmp	.+28     	; 0xe2 <EXTI_Init+0x50>
      c6:	45 b7       	in	r20, 0x35	; 53
      c8:	91 81       	ldd	r25, Z+1	; 0x01
      ca:	30 e0       	ldi	r19, 0x00	; 0
      cc:	22 0f       	add	r18, r18
      ce:	33 1f       	adc	r19, r19
      d0:	89 2f       	mov	r24, r25
      d2:	90 e0       	ldi	r25, 0x00	; 0
      d4:	02 c0       	rjmp	.+4      	; 0xda <EXTI_Init+0x48>
      d6:	88 0f       	add	r24, r24
      d8:	99 1f       	adc	r25, r25
      da:	2a 95       	dec	r18
      dc:	e2 f7       	brpl	.-8      	; 0xd6 <EXTI_Init+0x44>
      de:	84 2b       	or	r24, r20
      e0:	85 bf       	out	0x35, r24	; 53
      e2:	4b b7       	in	r20, 0x3b	; 59
      e4:	20 81       	ld	r18, Z
      e6:	30 e0       	ldi	r19, 0x00	; 0
      e8:	2b 5f       	subi	r18, 0xFB	; 251
      ea:	3f 4f       	sbci	r19, 0xFF	; 255
      ec:	81 e0       	ldi	r24, 0x01	; 1
      ee:	90 e0       	ldi	r25, 0x00	; 0
      f0:	02 c0       	rjmp	.+4      	; 0xf6 <EXTI_Init+0x64>
      f2:	88 0f       	add	r24, r24
      f4:	99 1f       	adc	r25, r25
      f6:	2a 95       	dec	r18
      f8:	e2 f7       	brpl	.-8      	; 0xf2 <EXTI_Init+0x60>
      fa:	84 2b       	or	r24, r20
      fc:	8b bf       	out	0x3b, r24	; 59
      fe:	78 94       	sei
     100:	08 95       	ret

00000102 <EXIT_INT0_CallBack>:
     102:	90 93 09 01 	sts	0x0109, r25	; 0x800109 <ptr_Int0+0x1>
     106:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <ptr_Int0>
     10a:	08 95       	ret

0000010c <EXIT_INT1_CallBack>:
     10c:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <ptr_Int1+0x1>
     110:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <ptr_Int1>
     114:	08 95       	ret

00000116 <EXIT_INT2_CallBack>:
     116:	90 93 07 01 	sts	0x0107, r25	; 0x800107 <ptr_Int2+0x1>
     11a:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <ptr_Int2>
     11e:	08 95       	ret

00000120 <__vector_1>:
}


/* INIT0 Function */
ISR(INT0_vect)
{
     120:	1f 92       	push	r1
     122:	0f 92       	push	r0
     124:	0f b6       	in	r0, 0x3f	; 63
     126:	0f 92       	push	r0
     128:	11 24       	eor	r1, r1
     12a:	2f 93       	push	r18
     12c:	3f 93       	push	r19
     12e:	4f 93       	push	r20
     130:	5f 93       	push	r21
     132:	6f 93       	push	r22
     134:	7f 93       	push	r23
     136:	8f 93       	push	r24
     138:	9f 93       	push	r25
     13a:	af 93       	push	r26
     13c:	bf 93       	push	r27
     13e:	ef 93       	push	r30
     140:	ff 93       	push	r31
	ptr_Int0();
     142:	e0 91 08 01 	lds	r30, 0x0108	; 0x800108 <ptr_Int0>
     146:	f0 91 09 01 	lds	r31, 0x0109	; 0x800109 <ptr_Int0+0x1>
     14a:	09 95       	icall
}
     14c:	ff 91       	pop	r31
     14e:	ef 91       	pop	r30
     150:	bf 91       	pop	r27
     152:	af 91       	pop	r26
     154:	9f 91       	pop	r25
     156:	8f 91       	pop	r24
     158:	7f 91       	pop	r23
     15a:	6f 91       	pop	r22
     15c:	5f 91       	pop	r21
     15e:	4f 91       	pop	r20
     160:	3f 91       	pop	r19
     162:	2f 91       	pop	r18
     164:	0f 90       	pop	r0
     166:	0f be       	out	0x3f, r0	; 63
     168:	0f 90       	pop	r0
     16a:	1f 90       	pop	r1
     16c:	18 95       	reti

0000016e <__vector_2>:
/* INIT0 Function */
ISR(INT1_vect)
{
     16e:	1f 92       	push	r1
     170:	0f 92       	push	r0
     172:	0f b6       	in	r0, 0x3f	; 63
     174:	0f 92       	push	r0
     176:	11 24       	eor	r1, r1
     178:	2f 93       	push	r18
     17a:	3f 93       	push	r19
     17c:	4f 93       	push	r20
     17e:	5f 93       	push	r21
     180:	6f 93       	push	r22
     182:	7f 93       	push	r23
     184:	8f 93       	push	r24
     186:	9f 93       	push	r25
     188:	af 93       	push	r26
     18a:	bf 93       	push	r27
     18c:	ef 93       	push	r30
     18e:	ff 93       	push	r31
	ptr_Int1();
     190:	e0 91 04 01 	lds	r30, 0x0104	; 0x800104 <ptr_Int1>
     194:	f0 91 05 01 	lds	r31, 0x0105	; 0x800105 <ptr_Int1+0x1>
     198:	09 95       	icall
}
     19a:	ff 91       	pop	r31
     19c:	ef 91       	pop	r30
     19e:	bf 91       	pop	r27
     1a0:	af 91       	pop	r26
     1a2:	9f 91       	pop	r25
     1a4:	8f 91       	pop	r24
     1a6:	7f 91       	pop	r23
     1a8:	6f 91       	pop	r22
     1aa:	5f 91       	pop	r21
     1ac:	4f 91       	pop	r20
     1ae:	3f 91       	pop	r19
     1b0:	2f 91       	pop	r18
     1b2:	0f 90       	pop	r0
     1b4:	0f be       	out	0x3f, r0	; 63
     1b6:	0f 90       	pop	r0
     1b8:	1f 90       	pop	r1
     1ba:	18 95       	reti

000001bc <__vector_3>:
/* INIT0 Function */
ISR(INT2_vect)
{
     1bc:	1f 92       	push	r1
     1be:	0f 92       	push	r0
     1c0:	0f b6       	in	r0, 0x3f	; 63
     1c2:	0f 92       	push	r0
     1c4:	11 24       	eor	r1, r1
     1c6:	2f 93       	push	r18
     1c8:	3f 93       	push	r19
     1ca:	4f 93       	push	r20
     1cc:	5f 93       	push	r21
     1ce:	6f 93       	push	r22
     1d0:	7f 93       	push	r23
     1d2:	8f 93       	push	r24
     1d4:	9f 93       	push	r25
     1d6:	af 93       	push	r26
     1d8:	bf 93       	push	r27
     1da:	ef 93       	push	r30
     1dc:	ff 93       	push	r31
	ptr_Int2();
     1de:	e0 91 06 01 	lds	r30, 0x0106	; 0x800106 <ptr_Int2>
     1e2:	f0 91 07 01 	lds	r31, 0x0107	; 0x800107 <ptr_Int2+0x1>
     1e6:	09 95       	icall
     1e8:	ff 91       	pop	r31
     1ea:	ef 91       	pop	r30
     1ec:	bf 91       	pop	r27
     1ee:	af 91       	pop	r26
     1f0:	9f 91       	pop	r25
     1f2:	8f 91       	pop	r24
     1f4:	7f 91       	pop	r23
     1f6:	6f 91       	pop	r22
     1f8:	5f 91       	pop	r21
     1fa:	4f 91       	pop	r20
     1fc:	3f 91       	pop	r19
     1fe:	2f 91       	pop	r18
     200:	0f 90       	pop	r0
     202:	0f be       	out	0x3f, r0	; 63
     204:	0f 90       	pop	r0
     206:	1f 90       	pop	r1
     208:	18 95       	reti

0000020a <HAL_GPIO_INIT_PIN>:
	}
	else              /* if read pin is zero */
	{
		return GPIO_PIN_RESET ;
	}
}/* END_FUN HAL_GPIO_READPIN()*/
     20a:	dc 01       	movw	r26, r24
     20c:	fb 01       	movw	r30, r22
     20e:	81 81       	ldd	r24, Z+1	; 0x01
     210:	81 30       	cpi	r24, 0x01	; 1
     212:	99 f4       	brne	.+38     	; 0x23a <HAL_GPIO_INIT_PIN+0x30>
     214:	80 81       	ld	r24, Z
     216:	11 96       	adiw	r26, 0x01	; 1
     218:	9c 91       	ld	r25, X
     21a:	11 97       	sbiw	r26, 0x01	; 1
     21c:	89 2b       	or	r24, r25
     21e:	11 96       	adiw	r26, 0x01	; 1
     220:	8c 93       	st	X, r24
     222:	11 97       	sbiw	r26, 0x01	; 1
     224:	82 81       	ldd	r24, Z+2	; 0x02
     226:	81 30       	cpi	r24, 0x01	; 1
     228:	81 f4       	brne	.+32     	; 0x24a <HAL_GPIO_INIT_PIN+0x40>
     22a:	80 81       	ld	r24, Z
     22c:	12 96       	adiw	r26, 0x02	; 2
     22e:	9c 91       	ld	r25, X
     230:	12 97       	sbiw	r26, 0x02	; 2
     232:	89 2b       	or	r24, r25
     234:	12 96       	adiw	r26, 0x02	; 2
     236:	8c 93       	st	X, r24
     238:	08 95       	ret
     23a:	90 81       	ld	r25, Z
     23c:	90 95       	com	r25
     23e:	11 96       	adiw	r26, 0x01	; 1
     240:	8c 91       	ld	r24, X
     242:	11 97       	sbiw	r26, 0x01	; 1
     244:	98 23       	and	r25, r24
     246:	11 96       	adiw	r26, 0x01	; 1
     248:	9c 93       	st	X, r25
     24a:	08 95       	ret

0000024c <HAL_GPIO_WRITEPIN>:
 * param. : PIN_NUM the pin number must be one of GPIO_PIN_RESET or GPIO_PIN_SET
 * return : void  
 */
void HAL_GPIO_WRITEPIN(GPIO_TypeDef * PORT,uint8_t PIN_NUM,GPIO_PinState PIN_STATE)
{
	if(PIN_STATE != GPIO_PIN_RESET)
     24c:	44 23       	and	r20, r20
     24e:	29 f0       	breq	.+10     	; 0x25a <HAL_GPIO_WRITEPIN+0xe>
	{
		PORT->PORT_REG |= PIN_NUM ;
     250:	fc 01       	movw	r30, r24
     252:	22 81       	ldd	r18, Z+2	; 0x02
     254:	62 2b       	or	r22, r18
     256:	62 83       	std	Z+2, r22	; 0x02
     258:	08 95       	ret
	}
	else
	{
		PORT->PORT_REG &= ~(PIN_NUM);
     25a:	60 95       	com	r22
     25c:	fc 01       	movw	r30, r24
     25e:	22 81       	ldd	r18, Z+2	; 0x02
     260:	62 23       	and	r22, r18
     262:	62 83       	std	Z+2, r22	; 0x02
     264:	08 95       	ret

00000266 <I2C_INIT_FUN>:
I2C_STATUS HAL_I2C_Slave_Receive_IT(I2C_Handler_t * Handler  ,uint8_t * pRxData ,uint8_t DataSize )
{
	
	
		return I2C_NORMAL;
}
     266:	8f 92       	push	r8
     268:	9f 92       	push	r9
     26a:	af 92       	push	r10
     26c:	bf 92       	push	r11
     26e:	cf 92       	push	r12
     270:	df 92       	push	r13
     272:	ef 92       	push	r14
     274:	ff 92       	push	r15
     276:	0f 93       	push	r16
     278:	cf 93       	push	r28
     27a:	df 93       	push	r29
     27c:	ec 01       	movw	r28, r24
     27e:	28 81       	ld	r18, Y
     280:	39 81       	ldd	r19, Y+1	; 0x01
     282:	4a 81       	ldd	r20, Y+2	; 0x02
     284:	5b 81       	ldd	r21, Y+3	; 0x03
     286:	60 e0       	ldi	r22, 0x00	; 0
     288:	74 e2       	ldi	r23, 0x24	; 36
     28a:	84 ef       	ldi	r24, 0xF4	; 244
     28c:	90 e0       	ldi	r25, 0x00	; 0
     28e:	0e 94 b8 10 	call	0x2170	; 0x2170 <__udivmodsi4>
     292:	49 01       	movw	r8, r18
     294:	5a 01       	movw	r10, r20
     296:	39 2d       	mov	r19, r9
     298:	4a 2d       	mov	r20, r10
     29a:	5b 2d       	mov	r21, r11
     29c:	60 e0       	ldi	r22, 0x00	; 0
     29e:	70 e0       	ldi	r23, 0x00	; 0
     2a0:	80 e0       	ldi	r24, 0x00	; 0
     2a2:	90 e0       	ldi	r25, 0x00	; 0
     2a4:	a0 ef       	ldi	r26, 0xF0	; 240
     2a6:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <__adddi3_s8>
     2aa:	01 e0       	ldi	r16, 0x01	; 1
     2ac:	0e 94 dc 10 	call	0x21b8	; 0x21b8 <__lshrdi3>
     2b0:	20 b9       	out	0x00, r18	; 0
     2b2:	8c 81       	ldd	r24, Y+4	; 0x04
     2b4:	82 b9       	out	0x02, r24	; 2
     2b6:	16 be       	out	0x36, r1	; 54
     2b8:	11 b8       	out	0x01, r1	; 1
     2ba:	8d 81       	ldd	r24, Y+5	; 0x05
     2bc:	81 30       	cpi	r24, 0x01	; 1
     2be:	29 f4       	brne	.+10     	; 0x2ca <I2C_INIT_FUN+0x64>
     2c0:	78 94       	sei
     2c2:	86 b7       	in	r24, 0x36	; 54
     2c4:	81 60       	ori	r24, 0x01	; 1
     2c6:	86 bf       	out	0x36, r24	; 54
     2c8:	03 c0       	rjmp	.+6      	; 0x2d0 <I2C_INIT_FUN+0x6a>
     2ca:	86 b7       	in	r24, 0x36	; 54
     2cc:	8e 7f       	andi	r24, 0xFE	; 254
     2ce:	86 bf       	out	0x36, r24	; 54
     2d0:	df 91       	pop	r29
     2d2:	cf 91       	pop	r28
     2d4:	0f 91       	pop	r16
     2d6:	ff 90       	pop	r15
     2d8:	ef 90       	pop	r14
     2da:	df 90       	pop	r13
     2dc:	cf 90       	pop	r12
     2de:	bf 90       	pop	r11
     2e0:	af 90       	pop	r10
     2e2:	9f 90       	pop	r9
     2e4:	8f 90       	pop	r8
     2e6:	08 95       	ret

000002e8 <HAL_I2C_Mem_Write>:
 * param. @ : memAdd this is the internal memory address that you need to write data to 
 * param. @ : pRxData this is pointer to the buffer that hold the writing data 
 * param. @ : DataSize number of bytes that you need to write 
*/ 
I2C_STATUS HAL_I2C_Mem_Write(I2C_Handler_t * Handler ,uint8_t DevAdd,uint8_t MemAdd ,uint8_t * pTxData ,uint8_t DataSize )
{
     2e8:	0f 93       	push	r16
     2ea:	fc 01       	movw	r30, r24
	Handler->buffer = pTxData ;
     2ec:	37 83       	std	Z+7, r19	; 0x07
     2ee:	26 83       	std	Z+6, r18	; 0x06
	Handler->Size   = DataSize;
     2f0:	00 87       	std	Z+8, r16	; 0x08
	
	
	I2C_EN_START();
     2f2:	84 ea       	ldi	r24, 0xA4	; 164
     2f4:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     2f6:	06 b6       	in	r0, 0x36	; 54
     2f8:	07 fe       	sbrs	r0, 7
     2fa:	fd cf       	rjmp	.-6      	; 0x2f6 <HAL_I2C_Mem_Write+0xe>
	
	
	I2C->I2C_TWDR = DevAdd ;
     2fc:	63 b9       	out	0x03, r22	; 3
	I2C_EN();
     2fe:	84 e8       	ldi	r24, 0x84	; 132
     300:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     302:	06 b6       	in	r0, 0x36	; 54
     304:	07 fe       	sbrs	r0, 7
     306:	fd cf       	rjmp	.-6      	; 0x302 <HAL_I2C_Mem_Write+0x1a>

	I2C->I2C_TWDR = MemAdd;
     308:	43 b9       	out	0x03, r20	; 3
	I2C_EN();
     30a:	84 e8       	ldi	r24, 0x84	; 132
     30c:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     30e:	06 b6       	in	r0, 0x36	; 54
     310:	07 fe       	sbrs	r0, 7
     312:	fd cf       	rjmp	.-6      	; 0x30e <HAL_I2C_Mem_Write+0x26>
     314:	0d c0       	rjmp	.+26     	; 0x330 <HAL_I2C_Mem_Write+0x48>
	

	while(Handler->Size-- > 0)
	{
		I2C->I2C_TWDR = *(Handler->buffer++) ;
     316:	a6 81       	ldd	r26, Z+6	; 0x06
     318:	b7 81       	ldd	r27, Z+7	; 0x07
     31a:	cd 01       	movw	r24, r26
     31c:	01 96       	adiw	r24, 0x01	; 1
     31e:	97 83       	std	Z+7, r25	; 0x07
     320:	86 83       	std	Z+6, r24	; 0x06
     322:	8c 91       	ld	r24, X
     324:	83 b9       	out	0x03, r24	; 3
		I2C_EN();
     326:	84 e8       	ldi	r24, 0x84	; 132
     328:	86 bf       	out	0x36, r24	; 54
		while(!(I2C->I2C_TWCR & 0x80));
     32a:	06 b6       	in	r0, 0x36	; 54
     32c:	07 fe       	sbrs	r0, 7
     32e:	fd cf       	rjmp	.-6      	; 0x32a <HAL_I2C_Mem_Write+0x42>
	I2C->I2C_TWDR = MemAdd;
	I2C_EN();
	while(!(I2C->I2C_TWCR & 0x80));
	

	while(Handler->Size-- > 0)
     330:	80 85       	ldd	r24, Z+8	; 0x08
     332:	9f ef       	ldi	r25, 0xFF	; 255
     334:	98 0f       	add	r25, r24
     336:	90 87       	std	Z+8, r25	; 0x08
     338:	81 11       	cpse	r24, r1
     33a:	ed cf       	rjmp	.-38     	; 0x316 <HAL_I2C_Mem_Write+0x2e>
	{
		I2C->I2C_TWDR = *(Handler->buffer++) ;
		I2C_EN();
		while(!(I2C->I2C_TWCR & 0x80));
	}
	I2C_EN_STOP();
     33c:	84 e9       	ldi	r24, 0x94	; 148
     33e:	86 bf       	out	0x36, r24	; 54
	
	return I2C_NORMAL;	
}
     340:	81 e0       	ldi	r24, 0x01	; 1
     342:	0f 91       	pop	r16
     344:	08 95       	ret

00000346 <HAL_I2C_Mem_Read>:
 * param. @ : memAdd this is the internal memory address that you need to read data from it 
 * param. @ : pRxData this is pointer to the buffer that will hold the reading data 
 * param. @ : DataSize number of bytes that you need to read 
*/ 
I2C_STATUS HAL_I2C_Mem_Read(I2C_Handler_t * Handler ,uint8_t DevAdd,uint8_t MemAdd ,uint8_t * pRxData ,uint8_t DataSize )
{
     346:	0f 93       	push	r16
     348:	fc 01       	movw	r30, r24
	Handler->buffer = pRxData ;
     34a:	37 83       	std	Z+7, r19	; 0x07
     34c:	26 83       	std	Z+6, r18	; 0x06
	Handler->Size   = DataSize;
     34e:	00 87       	std	Z+8, r16	; 0x08
	
	I2C_EN_START();
     350:	84 ea       	ldi	r24, 0xA4	; 164
     352:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     354:	06 b6       	in	r0, 0x36	; 54
     356:	07 fe       	sbrs	r0, 7
     358:	fd cf       	rjmp	.-6      	; 0x354 <HAL_I2C_Mem_Read+0xe>
	
	
	I2C->I2C_TWDR = DevAdd ;
     35a:	63 b9       	out	0x03, r22	; 3
	I2C_EN();
     35c:	84 e8       	ldi	r24, 0x84	; 132
     35e:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     360:	06 b6       	in	r0, 0x36	; 54
     362:	07 fe       	sbrs	r0, 7
     364:	fd cf       	rjmp	.-6      	; 0x360 <HAL_I2C_Mem_Read+0x1a>

	I2C->I2C_TWDR = MemAdd;
     366:	43 b9       	out	0x03, r20	; 3
	I2C_EN();
     368:	84 e8       	ldi	r24, 0x84	; 132
     36a:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     36c:	06 b6       	in	r0, 0x36	; 54
     36e:	07 fe       	sbrs	r0, 7
     370:	fd cf       	rjmp	.-6      	; 0x36c <HAL_I2C_Mem_Read+0x26>
	
	
	I2C_EN_START();
     372:	84 ea       	ldi	r24, 0xA4	; 164
     374:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));	
     376:	06 b6       	in	r0, 0x36	; 54
     378:	07 fe       	sbrs	r0, 7
     37a:	fd cf       	rjmp	.-6      	; 0x376 <HAL_I2C_Mem_Read+0x30>

	I2C->I2C_TWDR = DevAdd | 1 ;
     37c:	61 60       	ori	r22, 0x01	; 1
     37e:	63 b9       	out	0x03, r22	; 3
	I2C_EN();
     380:	84 e8       	ldi	r24, 0x84	; 132
     382:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     384:	06 b6       	in	r0, 0x36	; 54
     386:	07 fe       	sbrs	r0, 7
     388:	fd cf       	rjmp	.-6      	; 0x384 <HAL_I2C_Mem_Read+0x3e>
     38a:	0d c0       	rjmp	.+26     	; 0x3a6 <HAL_I2C_Mem_Read+0x60>
	
		
	while(Handler->Size-- > 0)
	{
		I2C_EN_ACK();
     38c:	84 ec       	ldi	r24, 0xC4	; 196
     38e:	86 bf       	out	0x36, r24	; 54
		while(!(I2C->I2C_TWCR & 0x80));
     390:	06 b6       	in	r0, 0x36	; 54
     392:	07 fe       	sbrs	r0, 7
     394:	fd cf       	rjmp	.-6      	; 0x390 <HAL_I2C_Mem_Read+0x4a>
		*(Handler->buffer++) = I2C->I2C_TWDR ;
     396:	a6 81       	ldd	r26, Z+6	; 0x06
     398:	b7 81       	ldd	r27, Z+7	; 0x07
     39a:	cd 01       	movw	r24, r26
     39c:	01 96       	adiw	r24, 0x01	; 1
     39e:	97 83       	std	Z+7, r25	; 0x07
     3a0:	86 83       	std	Z+6, r24	; 0x06
     3a2:	83 b1       	in	r24, 0x03	; 3
     3a4:	8c 93       	st	X, r24
	I2C->I2C_TWDR = DevAdd | 1 ;
	I2C_EN();
	while(!(I2C->I2C_TWCR & 0x80));
	
		
	while(Handler->Size-- > 0)
     3a6:	80 85       	ldd	r24, Z+8	; 0x08
     3a8:	9f ef       	ldi	r25, 0xFF	; 255
     3aa:	98 0f       	add	r25, r24
     3ac:	90 87       	std	Z+8, r25	; 0x08
     3ae:	81 11       	cpse	r24, r1
     3b0:	ed cf       	rjmp	.-38     	; 0x38c <HAL_I2C_Mem_Read+0x46>
	{
		I2C_EN_ACK();
		while(!(I2C->I2C_TWCR & 0x80));
		*(Handler->buffer++) = I2C->I2C_TWDR ;
	}
	I2C_EN_NACK();
     3b2:	84 e8       	ldi	r24, 0x84	; 132
     3b4:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));	
     3b6:	06 b6       	in	r0, 0x36	; 54
     3b8:	07 fe       	sbrs	r0, 7
     3ba:	fd cf       	rjmp	.-6      	; 0x3b6 <HAL_I2C_Mem_Read+0x70>
	I2C_EN_STOP();
     3bc:	84 e9       	ldi	r24, 0x94	; 148
     3be:	86 bf       	out	0x36, r24	; 54
	return I2C_NORMAL;		
}
     3c0:	81 e0       	ldi	r24, 0x01	; 1
     3c2:	0f 91       	pop	r16
     3c4:	08 95       	ret

000003c6 <DS1305_Init>:
				Alarm->Hours =   TempAlarm.Hours;
				
			}
			Alarm->Day   =TempAlarm.Day ;
	
}
     3c6:	86 e6       	ldi	r24, 0x66	; 102
     3c8:	90 e0       	ldi	r25, 0x00	; 0
     3ca:	0e 94 33 01 	call	0x266	; 0x266 <I2C_INIT_FUN>
     3ce:	08 95       	ret

000003d0 <Convert_BCD_To_BIN>:
     3d0:	38 2f       	mov	r19, r24
     3d2:	3f 70       	andi	r19, 0x0F	; 15
     3d4:	98 2f       	mov	r25, r24
     3d6:	92 95       	swap	r25
     3d8:	9f 70       	andi	r25, 0x0F	; 15
     3da:	99 0f       	add	r25, r25
     3dc:	29 2f       	mov	r18, r25
     3de:	22 0f       	add	r18, r18
     3e0:	22 0f       	add	r18, r18
     3e2:	89 2f       	mov	r24, r25
     3e4:	82 0f       	add	r24, r18
     3e6:	83 0f       	add	r24, r19
     3e8:	08 95       	ret

000003ea <RTC_Get_Time>:
     3ea:	ef 92       	push	r14
     3ec:	ff 92       	push	r15
     3ee:	0f 93       	push	r16
     3f0:	1f 93       	push	r17
     3f2:	cf 93       	push	r28
     3f4:	df 93       	push	r29
     3f6:	00 d0       	rcall	.+0      	; 0x3f8 <RTC_Get_Time+0xe>
     3f8:	00 d0       	rcall	.+0      	; 0x3fa <RTC_Get_Time+0x10>
     3fa:	1f 92       	push	r1
     3fc:	cd b7       	in	r28, 0x3d	; 61
     3fe:	de b7       	in	r29, 0x3e	; 62
     400:	7c 01       	movw	r14, r24
     402:	03 e0       	ldi	r16, 0x03	; 3
     404:	9e 01       	movw	r18, r28
     406:	2f 5f       	subi	r18, 0xFF	; 255
     408:	3f 4f       	sbci	r19, 0xFF	; 255
     40a:	40 e0       	ldi	r20, 0x00	; 0
     40c:	60 ed       	ldi	r22, 0xD0	; 208
     40e:	86 e6       	ldi	r24, 0x66	; 102
     410:	90 e0       	ldi	r25, 0x00	; 0
     412:	0e 94 a3 01 	call	0x346	; 0x346 <HAL_I2C_Mem_Read>
     416:	8b 81       	ldd	r24, Y+3	; 0x03
     418:	98 2f       	mov	r25, r24
     41a:	90 74       	andi	r25, 0x40	; 64
     41c:	86 fd       	sbrc	r24, 6
     41e:	05 c0       	rjmp	.+10     	; 0x42a <__EEPROM_REGION_LENGTH__+0x2a>
     420:	f7 01       	movw	r30, r14
     422:	82 81       	ldd	r24, Z+2	; 0x02
     424:	8f 77       	andi	r24, 0x7F	; 127
     426:	82 83       	std	Z+2, r24	; 0x02
     428:	0b c0       	rjmp	.+22     	; 0x440 <__EEPROM_REGION_LENGTH__+0x40>
     42a:	91 11       	cpse	r25, r1
     42c:	04 c0       	rjmp	.+8      	; 0x436 <__EEPROM_REGION_LENGTH__+0x36>
     42e:	91 e0       	ldi	r25, 0x01	; 1
     430:	f7 01       	movw	r30, r14
     432:	94 83       	std	Z+4, r25	; 0x04
     434:	03 c0       	rjmp	.+6      	; 0x43c <__EEPROM_REGION_LENGTH__+0x3c>
     436:	92 e0       	ldi	r25, 0x02	; 2
     438:	f7 01       	movw	r30, r14
     43a:	94 83       	std	Z+4, r25	; 0x04
     43c:	8f 71       	andi	r24, 0x1F	; 31
     43e:	8b 83       	std	Y+3, r24	; 0x03
     440:	8a 81       	ldd	r24, Y+2	; 0x02
     442:	08 2f       	mov	r16, r24
     444:	0f 77       	andi	r16, 0x7F	; 127
     446:	89 81       	ldd	r24, Y+1	; 0x01
     448:	18 2f       	mov	r17, r24
     44a:	1f 77       	andi	r17, 0x7F	; 127
     44c:	f7 01       	movw	r30, r14
     44e:	83 81       	ldd	r24, Z+3	; 0x03
     450:	82 30       	cpi	r24, 0x02	; 2
     452:	81 f4       	brne	.+32     	; 0x474 <__EEPROM_REGION_LENGTH__+0x74>
     454:	8b 81       	ldd	r24, Y+3	; 0x03
     456:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <Convert_BCD_To_BIN>
     45a:	f7 01       	movw	r30, r14
     45c:	82 83       	std	Z+2, r24	; 0x02
     45e:	80 2f       	mov	r24, r16
     460:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <Convert_BCD_To_BIN>
     464:	f7 01       	movw	r30, r14
     466:	81 83       	std	Z+1, r24	; 0x01
     468:	81 2f       	mov	r24, r17
     46a:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <Convert_BCD_To_BIN>
     46e:	f7 01       	movw	r30, r14
     470:	80 83       	st	Z, r24
     472:	05 c0       	rjmp	.+10     	; 0x47e <__EEPROM_REGION_LENGTH__+0x7e>
     474:	8b 81       	ldd	r24, Y+3	; 0x03
     476:	f7 01       	movw	r30, r14
     478:	82 83       	std	Z+2, r24	; 0x02
     47a:	01 83       	std	Z+1, r16	; 0x01
     47c:	10 83       	st	Z, r17
     47e:	0f 90       	pop	r0
     480:	0f 90       	pop	r0
     482:	0f 90       	pop	r0
     484:	0f 90       	pop	r0
     486:	0f 90       	pop	r0
     488:	df 91       	pop	r29
     48a:	cf 91       	pop	r28
     48c:	1f 91       	pop	r17
     48e:	0f 91       	pop	r16
     490:	ff 90       	pop	r15
     492:	ef 90       	pop	r14
     494:	08 95       	ret

00000496 <RTC_Get_Date>:
     496:	ef 92       	push	r14
     498:	ff 92       	push	r15
     49a:	0f 93       	push	r16
     49c:	cf 93       	push	r28
     49e:	df 93       	push	r29
     4a0:	00 d0       	rcall	.+0      	; 0x4a2 <RTC_Get_Date+0xc>
     4a2:	00 d0       	rcall	.+0      	; 0x4a4 <RTC_Get_Date+0xe>
     4a4:	1f 92       	push	r1
     4a6:	cd b7       	in	r28, 0x3d	; 61
     4a8:	de b7       	in	r29, 0x3e	; 62
     4aa:	7c 01       	movw	r14, r24
     4ac:	04 e0       	ldi	r16, 0x04	; 4
     4ae:	9e 01       	movw	r18, r28
     4b0:	2f 5f       	subi	r18, 0xFF	; 255
     4b2:	3f 4f       	sbci	r19, 0xFF	; 255
     4b4:	43 e0       	ldi	r20, 0x03	; 3
     4b6:	60 ed       	ldi	r22, 0xD0	; 208
     4b8:	86 e6       	ldi	r24, 0x66	; 102
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	0e 94 a3 01 	call	0x346	; 0x346 <HAL_I2C_Mem_Read>
     4c0:	f7 01       	movw	r30, r14
     4c2:	84 81       	ldd	r24, Z+4	; 0x04
     4c4:	82 30       	cpi	r24, 0x02	; 2
     4c6:	81 f4       	brne	.+32     	; 0x4e8 <RTC_Get_Date+0x52>
     4c8:	8a 81       	ldd	r24, Y+2	; 0x02
     4ca:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <Convert_BCD_To_BIN>
     4ce:	f7 01       	movw	r30, r14
     4d0:	81 83       	std	Z+1, r24	; 0x01
     4d2:	8b 81       	ldd	r24, Y+3	; 0x03
     4d4:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <Convert_BCD_To_BIN>
     4d8:	f7 01       	movw	r30, r14
     4da:	82 83       	std	Z+2, r24	; 0x02
     4dc:	8c 81       	ldd	r24, Y+4	; 0x04
     4de:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <Convert_BCD_To_BIN>
     4e2:	f7 01       	movw	r30, r14
     4e4:	83 83       	std	Z+3, r24	; 0x03
     4e6:	07 c0       	rjmp	.+14     	; 0x4f6 <RTC_Get_Date+0x60>
     4e8:	8a 81       	ldd	r24, Y+2	; 0x02
     4ea:	f7 01       	movw	r30, r14
     4ec:	81 83       	std	Z+1, r24	; 0x01
     4ee:	8b 81       	ldd	r24, Y+3	; 0x03
     4f0:	82 83       	std	Z+2, r24	; 0x02
     4f2:	8c 81       	ldd	r24, Y+4	; 0x04
     4f4:	83 83       	std	Z+3, r24	; 0x03
     4f6:	89 81       	ldd	r24, Y+1	; 0x01
     4f8:	f7 01       	movw	r30, r14
     4fa:	80 83       	st	Z, r24
     4fc:	0f 90       	pop	r0
     4fe:	0f 90       	pop	r0
     500:	0f 90       	pop	r0
     502:	0f 90       	pop	r0
     504:	0f 90       	pop	r0
     506:	df 91       	pop	r29
     508:	cf 91       	pop	r28
     50a:	0f 91       	pop	r16
     50c:	ff 90       	pop	r15
     50e:	ef 90       	pop	r14
     510:	08 95       	ret

00000512 <Convert_BIN_To_BCD>:
{
	
	uint8_t BCD_Low =0;
	
	
	if(BIN_Num > 99u) // check if the wrong data send from the Application
     512:	84 36       	cpi	r24, 0x64	; 100
     514:	d8 f4       	brcc	.+54     	; 0x54c <Convert_BIN_To_BCD+0x3a>
	return 0x99u;
	if(BIN_Num == 0)
     516:	88 23       	and	r24, r24
     518:	d9 f0       	breq	.+54     	; 0x550 <Convert_BIN_To_BCD+0x3e>
	return 0;
	
	BCD_Low = BIN_Num % 10u ;
     51a:	9d ec       	ldi	r25, 0xCD	; 205
     51c:	89 9f       	mul	r24, r25
     51e:	91 2d       	mov	r25, r1
     520:	11 24       	eor	r1, r1
     522:	49 2f       	mov	r20, r25
     524:	46 95       	lsr	r20
     526:	46 95       	lsr	r20
     528:	46 95       	lsr	r20
     52a:	44 0f       	add	r20, r20
     52c:	24 2f       	mov	r18, r20
     52e:	22 0f       	add	r18, r18
     530:	22 0f       	add	r18, r18
     532:	42 0f       	add	r20, r18
     534:	84 1b       	sub	r24, r20
     536:	48 2f       	mov	r20, r24
	BIN_Num /= 10u ;
     538:	96 95       	lsr	r25
     53a:	96 95       	lsr	r25
     53c:	96 95       	lsr	r25
	return (BIN_Num <<4u | BCD_Low );
     53e:	80 e1       	ldi	r24, 0x10	; 16
     540:	98 9f       	mul	r25, r24
     542:	90 01       	movw	r18, r0
     544:	11 24       	eor	r1, r1
     546:	84 2f       	mov	r24, r20
     548:	82 2b       	or	r24, r18
     54a:	08 95       	ret
	
	uint8_t BCD_Low =0;
	
	
	if(BIN_Num > 99u) // check if the wrong data send from the Application
	return 0x99u;
     54c:	89 e9       	ldi	r24, 0x99	; 153
     54e:	08 95       	ret
	if(BIN_Num == 0)
	return 0;
     550:	80 e0       	ldi	r24, 0x00	; 0
	BIN_Num /= 10u ;
	return (BIN_Num <<4u | BCD_Low );
	
	
	
}
     552:	08 95       	ret

00000554 <RTC_Set_Time>:
/* brief : this function used to set DS1305 Time 
 * param : Time_Typedef handler struct pointer hold all Time informations 
 * return : void 
 */
void RTC_Set_Time(Time_Typedef * Time)
{
     554:	0f 93       	push	r16
     556:	1f 93       	push	r17
     558:	cf 93       	push	r28
     55a:	df 93       	push	r29
     55c:	00 d0       	rcall	.+0      	; 0x55e <RTC_Set_Time+0xa>
     55e:	00 d0       	rcall	.+0      	; 0x560 <RTC_Set_Time+0xc>
     560:	1f 92       	push	r1
     562:	cd b7       	in	r28, 0x3d	; 61
     564:	de b7       	in	r29, 0x3e	; 62
     566:	8c 01       	movw	r16, r24
	/* temp handler to hold all actual timing info that will send to DS1305 */
	Time_Typedef TempTime ;
	
	/* check if any need to convert to BCD formate */
	if(Time->RTC_Time_Format == RTC_Format_BIN)
     568:	fc 01       	movw	r30, r24
     56a:	83 81       	ldd	r24, Z+3	; 0x03
     56c:	82 30       	cpi	r24, 0x02	; 2
     56e:	79 f4       	brne	.+30     	; 0x58e <RTC_Set_Time+0x3a>
	{
		TempTime.Hours   = Convert_BIN_To_BCD(Time->Hours);
     570:	82 81       	ldd	r24, Z+2	; 0x02
     572:	0e 94 89 02 	call	0x512	; 0x512 <Convert_BIN_To_BCD>
     576:	8b 83       	std	Y+3, r24	; 0x03
		TempTime.Minutes = Convert_BIN_To_BCD(Time->Minutes);
     578:	f8 01       	movw	r30, r16
     57a:	81 81       	ldd	r24, Z+1	; 0x01
     57c:	0e 94 89 02 	call	0x512	; 0x512 <Convert_BIN_To_BCD>
     580:	8a 83       	std	Y+2, r24	; 0x02
		TempTime.Seconds = Convert_BIN_To_BCD(Time->Seconds);							
     582:	f8 01       	movw	r30, r16
     584:	80 81       	ld	r24, Z
     586:	0e 94 89 02 	call	0x512	; 0x512 <Convert_BIN_To_BCD>
     58a:	89 83       	std	Y+1, r24	; 0x01
     58c:	0a c0       	rjmp	.+20     	; 0x5a2 <RTC_Set_Time+0x4e>
	}else{
		TempTime.Hours   = Time->Hours	  & 0x7f ;
     58e:	f8 01       	movw	r30, r16
     590:	82 81       	ldd	r24, Z+2	; 0x02
     592:	8f 77       	andi	r24, 0x7F	; 127
     594:	8b 83       	std	Y+3, r24	; 0x03
		TempTime.Minutes = Time->Minutes & 0x7f ;
     596:	81 81       	ldd	r24, Z+1	; 0x01
     598:	8f 77       	andi	r24, 0x7F	; 127
     59a:	8a 83       	std	Y+2, r24	; 0x02
		TempTime.Seconds = Time->Seconds & 0x7f ;
     59c:	80 81       	ld	r24, Z
     59e:	8f 77       	andi	r24, 0x7F	; 127
     5a0:	89 83       	std	Y+1, r24	; 0x01
	}

if(Time->RTC_AM_PM != 0u)
     5a2:	f8 01       	movw	r30, r16
     5a4:	84 81       	ldd	r24, Z+4	; 0x04
     5a6:	88 23       	and	r24, r24
     5a8:	49 f0       	breq	.+18     	; 0x5bc <RTC_Set_Time+0x68>
{
	
	if(Time->RTC_AM_PM == RTC_Time_PM )	// PM logic high & AM logic low
     5aa:	82 30       	cpi	r24, 0x02	; 2
     5ac:	21 f4       	brne	.+8      	; 0x5b6 <RTC_Set_Time+0x62>
	TempTime.Hours |= 0x40u ;
     5ae:	8b 81       	ldd	r24, Y+3	; 0x03
     5b0:	80 64       	ori	r24, 0x40	; 64
     5b2:	8b 83       	std	Y+3, r24	; 0x03
     5b4:	03 c0       	rjmp	.+6      	; 0x5bc <RTC_Set_Time+0x68>
	else
	TempTime.Hours |= 0x60u ;
     5b6:	8b 81       	ldd	r24, Y+3	; 0x03
     5b8:	80 66       	ori	r24, 0x60	; 96
     5ba:	8b 83       	std	Y+3, r24	; 0x03
}


/*here we'll send all Time information to DS1305 Module */
HAL_I2C_Mem_Write(&I2cHandler,0xd0,0x00,&TempTime.Seconds,3);
     5bc:	03 e0       	ldi	r16, 0x03	; 3
     5be:	9e 01       	movw	r18, r28
     5c0:	2f 5f       	subi	r18, 0xFF	; 255
     5c2:	3f 4f       	sbci	r19, 0xFF	; 255
     5c4:	40 e0       	ldi	r20, 0x00	; 0
     5c6:	60 ed       	ldi	r22, 0xD0	; 208
     5c8:	86 e6       	ldi	r24, 0x66	; 102
     5ca:	90 e0       	ldi	r25, 0x00	; 0
     5cc:	0e 94 74 01 	call	0x2e8	; 0x2e8 <HAL_I2C_Mem_Write>
	
	
	
}/* End_Of RTC_Set_Time() */
     5d0:	0f 90       	pop	r0
     5d2:	0f 90       	pop	r0
     5d4:	0f 90       	pop	r0
     5d6:	0f 90       	pop	r0
     5d8:	0f 90       	pop	r0
     5da:	df 91       	pop	r29
     5dc:	cf 91       	pop	r28
     5de:	1f 91       	pop	r17
     5e0:	0f 91       	pop	r16
     5e2:	08 95       	ret

000005e4 <RTC_Set_Date>:
/* brief : this function used to Set DS1305 Current Date 
 * param : Date_Typedef handler struct pointer hold all Date informations that will send from DS1305 
 * return : void 
 */
void RTC_Set_Date(Date_Typedef * Date)
{
     5e4:	0f 93       	push	r16
     5e6:	1f 93       	push	r17
     5e8:	cf 93       	push	r28
     5ea:	df 93       	push	r29
     5ec:	00 d0       	rcall	.+0      	; 0x5ee <RTC_Set_Date+0xa>
     5ee:	00 d0       	rcall	.+0      	; 0x5f0 <RTC_Set_Date+0xc>
     5f0:	1f 92       	push	r1
     5f2:	cd b7       	in	r28, 0x3d	; 61
     5f4:	de b7       	in	r29, 0x3e	; 62
     5f6:	8c 01       	movw	r16, r24
	Date_Typedef TempDate ;
	
	/* check the format of the data that send by the user in Date_Typedef Var */
	if(Date->RTC_Time_Format == RTC_Format_BIN)
     5f8:	fc 01       	movw	r30, r24
     5fa:	84 81       	ldd	r24, Z+4	; 0x04
     5fc:	82 30       	cpi	r24, 0x02	; 2
     5fe:	79 f4       	brne	.+30     	; 0x61e <RTC_Set_Date+0x3a>
	{
		
		TempDate.DayDate   = Convert_BIN_To_BCD(Date->DayDate);
     600:	81 81       	ldd	r24, Z+1	; 0x01
     602:	0e 94 89 02 	call	0x512	; 0x512 <Convert_BIN_To_BCD>
     606:	8a 83       	std	Y+2, r24	; 0x02
		TempDate.Year = Convert_BIN_To_BCD(Date->Year);
     608:	f8 01       	movw	r30, r16
     60a:	83 81       	ldd	r24, Z+3	; 0x03
     60c:	0e 94 89 02 	call	0x512	; 0x512 <Convert_BIN_To_BCD>
     610:	8c 83       	std	Y+4, r24	; 0x04
		TempDate.month = Convert_BIN_To_BCD(Date->month);
     612:	f8 01       	movw	r30, r16
     614:	82 81       	ldd	r24, Z+2	; 0x02
     616:	0e 94 89 02 	call	0x512	; 0x512 <Convert_BIN_To_BCD>
     61a:	8b 83       	std	Y+3, r24	; 0x03
     61c:	09 c0       	rjmp	.+18     	; 0x630 <RTC_Set_Date+0x4c>
		
		}else{
		TempDate.DayDate   = Date->DayDate   & 0x3f ;
     61e:	f8 01       	movw	r30, r16
     620:	81 81       	ldd	r24, Z+1	; 0x01
     622:	8f 73       	andi	r24, 0x3F	; 63
     624:	8a 83       	std	Y+2, r24	; 0x02
		TempDate.Year  = Date->Year  ;
     626:	83 81       	ldd	r24, Z+3	; 0x03
     628:	8c 83       	std	Y+4, r24	; 0x04
		TempDate.month = Date->month & 0x3f ;
     62a:	82 81       	ldd	r24, Z+2	; 0x02
     62c:	8f 73       	andi	r24, 0x3F	; 63
     62e:	8b 83       	std	Y+3, r24	; 0x03
		}
	TempDate.Day = Date->Day;
     630:	f8 01       	movw	r30, r16
     632:	80 81       	ld	r24, Z
     634:	89 83       	std	Y+1, r24	; 0x01
	
	/* here we'll set up the data For Ds1305 Module */
	HAL_I2C_Mem_Write(&I2cHandler,0xd0,0x03,&TempDate.Day,4);
     636:	04 e0       	ldi	r16, 0x04	; 4
     638:	9e 01       	movw	r18, r28
     63a:	2f 5f       	subi	r18, 0xFF	; 255
     63c:	3f 4f       	sbci	r19, 0xFF	; 255
     63e:	43 e0       	ldi	r20, 0x03	; 3
     640:	60 ed       	ldi	r22, 0xD0	; 208
     642:	86 e6       	ldi	r24, 0x66	; 102
     644:	90 e0       	ldi	r25, 0x00	; 0
     646:	0e 94 74 01 	call	0x2e8	; 0x2e8 <HAL_I2C_Mem_Write>

	
}/* End_Of RTC_Set_Time() */
     64a:	0f 90       	pop	r0
     64c:	0f 90       	pop	r0
     64e:	0f 90       	pop	r0
     650:	0f 90       	pop	r0
     652:	0f 90       	pop	r0
     654:	df 91       	pop	r29
     656:	cf 91       	pop	r28
     658:	1f 91       	pop	r17
     65a:	0f 91       	pop	r16
     65c:	08 95       	ret

0000065e <S7egment_Init>:



	
void S7egment_Init(Seg7_Handler *  Segment_Handler)
{
     65e:	ef 92       	push	r14
     660:	ff 92       	push	r15
     662:	0f 93       	push	r16
     664:	1f 93       	push	r17
     666:	cf 93       	push	r28
     668:	df 93       	push	r29
     66a:	00 d0       	rcall	.+0      	; 0x66c <S7egment_Init+0xe>
     66c:	1f 92       	push	r1
     66e:	cd b7       	in	r28, 0x3d	; 61
     670:	de b7       	in	r29, 0x3e	; 62
     672:	7c 01       	movw	r14, r24
		GPIO_InitTypeDef  S7eg_PIN_CONFIG ;

	
	S7eg_PIN_CONFIG.mode = GPIO_MODE_OUTPUT ;
     674:	81 e0       	ldi	r24, 0x01	; 1
     676:	8a 83       	std	Y+2, r24	; 0x02
	S7eg_PIN_CONFIG.pull = GPIO_NOPULL ;
     678:	1b 82       	std	Y+3, r1	; 0x03
	/*initialize all control bits  */
	for (int i=0 ; i < 6 ;i++ )
     67a:	00 e0       	ldi	r16, 0x00	; 0
     67c:	10 e0       	ldi	r17, 0x00	; 0
     67e:	12 c0       	rjmp	.+36     	; 0x6a4 <S7egment_Init+0x46>
	{
		S7eg_PIN_CONFIG.pinS = Segment_Handler->S7eg_Control[i].Pin_Num ;	
     680:	f8 01       	movw	r30, r16
     682:	ee 0f       	add	r30, r30
     684:	ff 1f       	adc	r31, r31
     686:	e0 0f       	add	r30, r16
     688:	f1 1f       	adc	r31, r17
     68a:	ee 0d       	add	r30, r14
     68c:	ff 1d       	adc	r31, r15
     68e:	82 81       	ldd	r24, Z+2	; 0x02
     690:	89 83       	std	Y+1, r24	; 0x01
		HAL_GPIO_INIT_PIN(Segment_Handler->S7eg_Control[i].Port,&S7eg_PIN_CONFIG);	
     692:	be 01       	movw	r22, r28
     694:	6f 5f       	subi	r22, 0xFF	; 255
     696:	7f 4f       	sbci	r23, 0xFF	; 255
     698:	80 81       	ld	r24, Z
     69a:	91 81       	ldd	r25, Z+1	; 0x01
     69c:	0e 94 05 01 	call	0x20a	; 0x20a <HAL_GPIO_INIT_PIN>

	
	S7eg_PIN_CONFIG.mode = GPIO_MODE_OUTPUT ;
	S7eg_PIN_CONFIG.pull = GPIO_NOPULL ;
	/*initialize all control bits  */
	for (int i=0 ; i < 6 ;i++ )
     6a0:	0f 5f       	subi	r16, 0xFF	; 255
     6a2:	1f 4f       	sbci	r17, 0xFF	; 255
     6a4:	06 30       	cpi	r16, 0x06	; 6
     6a6:	11 05       	cpc	r17, r1
     6a8:	5c f3       	brlt	.-42     	; 0x680 <S7egment_Init+0x22>
     6aa:	00 e0       	ldi	r16, 0x00	; 0
     6ac:	10 e0       	ldi	r17, 0x00	; 0
     6ae:	12 c0       	rjmp	.+36     	; 0x6d4 <S7egment_Init+0x76>


	/*initialize 7 segment BCD Bits */	
	for (int i=0 ; i < 4 ;i++ )
	{
		S7eg_PIN_CONFIG.pinS = Segment_Handler->S7eg_Bits[i].Pin_Num;
     6b0:	f8 01       	movw	r30, r16
     6b2:	ee 0f       	add	r30, r30
     6b4:	ff 1f       	adc	r31, r31
     6b6:	e0 0f       	add	r30, r16
     6b8:	f1 1f       	adc	r31, r17
     6ba:	ee 0d       	add	r30, r14
     6bc:	ff 1d       	adc	r31, r15
     6be:	84 89       	ldd	r24, Z+20	; 0x14
     6c0:	89 83       	std	Y+1, r24	; 0x01
		HAL_GPIO_INIT_PIN(Segment_Handler->S7eg_Bits[i].Port,&S7eg_PIN_CONFIG);
     6c2:	be 01       	movw	r22, r28
     6c4:	6f 5f       	subi	r22, 0xFF	; 255
     6c6:	7f 4f       	sbci	r23, 0xFF	; 255
     6c8:	82 89       	ldd	r24, Z+18	; 0x12
     6ca:	93 89       	ldd	r25, Z+19	; 0x13
     6cc:	0e 94 05 01 	call	0x20a	; 0x20a <HAL_GPIO_INIT_PIN>
		HAL_GPIO_INIT_PIN(Segment_Handler->S7eg_Control[i].Port,&S7eg_PIN_CONFIG);	
	}


	/*initialize 7 segment BCD Bits */	
	for (int i=0 ; i < 4 ;i++ )
     6d0:	0f 5f       	subi	r16, 0xFF	; 255
     6d2:	1f 4f       	sbci	r17, 0xFF	; 255
     6d4:	04 30       	cpi	r16, 0x04	; 4
     6d6:	11 05       	cpc	r17, r1
     6d8:	5c f3       	brlt	.-42     	; 0x6b0 <S7egment_Init+0x52>
		HAL_GPIO_INIT_PIN(Segment_Handler->S7eg_Bits[i].Port,&S7eg_PIN_CONFIG);
	}	
	
	
	
}
     6da:	0f 90       	pop	r0
     6dc:	0f 90       	pop	r0
     6de:	0f 90       	pop	r0
     6e0:	df 91       	pop	r29
     6e2:	cf 91       	pop	r28
     6e4:	1f 91       	pop	r17
     6e6:	0f 91       	pop	r16
     6e8:	ff 90       	pop	r15
     6ea:	ef 90       	pop	r14
     6ec:	08 95       	ret

000006ee <S7egment_Write>:
void S7egment_Write(uint8_t Num_To_S7eg , uint8_t S7eg_Num,Seg7_Handler *  Segment_Handler)
{
     6ee:	df 92       	push	r13
     6f0:	ef 92       	push	r14
     6f2:	ff 92       	push	r15
     6f4:	0f 93       	push	r16
     6f6:	1f 93       	push	r17
     6f8:	cf 93       	push	r28
     6fa:	df 93       	push	r29
     6fc:	06 2f       	mov	r16, r22
     6fe:	ea 01       	movw	r28, r20


	uint8_t High_Num=0,Low_Num=0 ;
	Low_Num = Num_To_S7eg % 10 ;
     700:	9d ec       	ldi	r25, 0xCD	; 205
     702:	89 9f       	mul	r24, r25
     704:	d1 2c       	mov	r13, r1
     706:	11 24       	eor	r1, r1
     708:	d6 94       	lsr	r13
     70a:	d6 94       	lsr	r13
     70c:	d6 94       	lsr	r13
     70e:	dd 0c       	add	r13, r13
     710:	9d 2d       	mov	r25, r13
     712:	99 0f       	add	r25, r25
     714:	99 0f       	add	r25, r25
     716:	d9 0e       	add	r13, r25
     718:	98 2f       	mov	r25, r24
     71a:	9d 19       	sub	r25, r13
     71c:	d9 2e       	mov	r13, r25
	if (Num_To_S7eg == 0)
     71e:	88 23       	and	r24, r24
     720:	b9 f0       	breq	.+46     	; 0x750 <S7egment_Write+0x62>
	{
		
	}
	else
	{
	Num_To_S7eg /= 10 ;
     722:	9d ec       	ldi	r25, 0xCD	; 205
     724:	89 9f       	mul	r24, r25
     726:	81 2d       	mov	r24, r1
     728:	11 24       	eor	r1, r1
     72a:	86 95       	lsr	r24
     72c:	86 95       	lsr	r24
     72e:	86 95       	lsr	r24
	if (Num_To_S7eg > 0){
     730:	89 f0       	breq	.+34     	; 0x754 <S7egment_Write+0x66>
		High_Num = Num_To_S7eg % 10 ;
     732:	1d ec       	ldi	r17, 0xCD	; 205
     734:	81 9f       	mul	r24, r17
     736:	11 2d       	mov	r17, r1
     738:	11 24       	eor	r1, r1
     73a:	16 95       	lsr	r17
     73c:	16 95       	lsr	r17
     73e:	16 95       	lsr	r17
     740:	11 0f       	add	r17, r17
     742:	91 2f       	mov	r25, r17
     744:	99 0f       	add	r25, r25
     746:	99 0f       	add	r25, r25
     748:	19 0f       	add	r17, r25
     74a:	81 1b       	sub	r24, r17
     74c:	18 2f       	mov	r17, r24
     74e:	03 c0       	rjmp	.+6      	; 0x756 <S7egment_Write+0x68>
}
void S7egment_Write(uint8_t Num_To_S7eg , uint8_t S7eg_Num,Seg7_Handler *  Segment_Handler)
{


	uint8_t High_Num=0,Low_Num=0 ;
     750:	10 e0       	ldi	r17, 0x00	; 0
     752:	01 c0       	rjmp	.+2      	; 0x756 <S7egment_Write+0x68>
	{
	Num_To_S7eg /= 10 ;
	if (Num_To_S7eg > 0){
		High_Num = Num_To_S7eg % 10 ;
		}else{
		High_Num = 0 ;
     754:	10 e0       	ldi	r17, 0x00	; 0
	}
	}

	for(int i =0 ;i<4 ;i++)
     756:	e1 2c       	mov	r14, r1
     758:	f1 2c       	mov	r15, r1
     75a:	18 c0       	rjmp	.+48     	; 0x78c <S7egment_Write+0x9e>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Bits[i].Port,Segment_Handler->S7eg_Bits[i].Pin_Num,(High_Num>>i)&(0x01));
     75c:	41 2f       	mov	r20, r17
     75e:	50 e0       	ldi	r21, 0x00	; 0
     760:	0e 2c       	mov	r0, r14
     762:	02 c0       	rjmp	.+4      	; 0x768 <S7egment_Write+0x7a>
     764:	55 95       	asr	r21
     766:	47 95       	ror	r20
     768:	0a 94       	dec	r0
     76a:	e2 f7       	brpl	.-8      	; 0x764 <S7egment_Write+0x76>
     76c:	41 70       	andi	r20, 0x01	; 1
     76e:	f7 01       	movw	r30, r14
     770:	ee 0f       	add	r30, r30
     772:	ff 1f       	adc	r31, r31
     774:	ee 0d       	add	r30, r14
     776:	ff 1d       	adc	r31, r15
     778:	ec 0f       	add	r30, r28
     77a:	fd 1f       	adc	r31, r29
     77c:	64 89       	ldd	r22, Z+20	; 0x14
     77e:	82 89       	ldd	r24, Z+18	; 0x12
     780:	93 89       	ldd	r25, Z+19	; 0x13
     782:	0e 94 26 01 	call	0x24c	; 0x24c <HAL_GPIO_WRITEPIN>
		}else{
		High_Num = 0 ;
	}
	}

	for(int i =0 ;i<4 ;i++)
     786:	ef ef       	ldi	r30, 0xFF	; 255
     788:	ee 1a       	sub	r14, r30
     78a:	fe 0a       	sbc	r15, r30
     78c:	f4 e0       	ldi	r31, 0x04	; 4
     78e:	ef 16       	cp	r14, r31
     790:	f1 04       	cpc	r15, r1
     792:	24 f3       	brlt	.-56     	; 0x75c <S7egment_Write+0x6e>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Bits[i].Port,Segment_Handler->S7eg_Bits[i].Pin_Num,(High_Num>>i)&(0x01));
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Control[S7eg_Num].Port,Segment_Handler->S7eg_Control[S7eg_Num].Pin_Num,1);
     794:	10 e0       	ldi	r17, 0x00	; 0
     796:	78 01       	movw	r14, r16
     798:	ee 0c       	add	r14, r14
     79a:	ff 1c       	adc	r15, r15
     79c:	e0 0e       	add	r14, r16
     79e:	f1 1e       	adc	r15, r17
     7a0:	ec 0e       	add	r14, r28
     7a2:	fd 1e       	adc	r15, r29
     7a4:	41 e0       	ldi	r20, 0x01	; 1
     7a6:	f7 01       	movw	r30, r14
     7a8:	62 81       	ldd	r22, Z+2	; 0x02
     7aa:	80 81       	ld	r24, Z
     7ac:	91 81       	ldd	r25, Z+1	; 0x01
     7ae:	0e 94 26 01 	call	0x24c	; 0x24c <HAL_GPIO_WRITEPIN>
	vTaskDelay(1);
     7b2:	81 e0       	ldi	r24, 0x01	; 1
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <vTaskDelay>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Control[S7eg_Num].Port,Segment_Handler->S7eg_Control[S7eg_Num].Pin_Num,0);
     7ba:	40 e0       	ldi	r20, 0x00	; 0
     7bc:	f7 01       	movw	r30, r14
     7be:	62 81       	ldd	r22, Z+2	; 0x02
     7c0:	80 81       	ld	r24, Z
     7c2:	91 81       	ldd	r25, Z+1	; 0x01
     7c4:	0e 94 26 01 	call	0x24c	; 0x24c <HAL_GPIO_WRITEPIN>

	
	for(int i =0 ;i<4 ;i++)
     7c8:	e1 2c       	mov	r14, r1
     7ca:	f1 2c       	mov	r15, r1
     7cc:	18 c0       	rjmp	.+48     	; 0x7fe <S7egment_Write+0x110>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Bits[i].Port,Segment_Handler->S7eg_Bits[i].Pin_Num,(Low_Num>>i)&(0x01));
     7ce:	4d 2d       	mov	r20, r13
     7d0:	50 e0       	ldi	r21, 0x00	; 0
     7d2:	0e 2c       	mov	r0, r14
     7d4:	02 c0       	rjmp	.+4      	; 0x7da <S7egment_Write+0xec>
     7d6:	55 95       	asr	r21
     7d8:	47 95       	ror	r20
     7da:	0a 94       	dec	r0
     7dc:	e2 f7       	brpl	.-8      	; 0x7d6 <S7egment_Write+0xe8>
     7de:	41 70       	andi	r20, 0x01	; 1
     7e0:	f7 01       	movw	r30, r14
     7e2:	ee 0f       	add	r30, r30
     7e4:	ff 1f       	adc	r31, r31
     7e6:	ee 0d       	add	r30, r14
     7e8:	ff 1d       	adc	r31, r15
     7ea:	ec 0f       	add	r30, r28
     7ec:	fd 1f       	adc	r31, r29
     7ee:	64 89       	ldd	r22, Z+20	; 0x14
     7f0:	82 89       	ldd	r24, Z+18	; 0x12
     7f2:	93 89       	ldd	r25, Z+19	; 0x13
     7f4:	0e 94 26 01 	call	0x24c	; 0x24c <HAL_GPIO_WRITEPIN>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Control[S7eg_Num].Port,Segment_Handler->S7eg_Control[S7eg_Num].Pin_Num,1);
	vTaskDelay(1);
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Control[S7eg_Num].Port,Segment_Handler->S7eg_Control[S7eg_Num].Pin_Num,0);

	
	for(int i =0 ;i<4 ;i++)
     7f8:	ff ef       	ldi	r31, 0xFF	; 255
     7fa:	ef 1a       	sub	r14, r31
     7fc:	ff 0a       	sbc	r15, r31
     7fe:	84 e0       	ldi	r24, 0x04	; 4
     800:	e8 16       	cp	r14, r24
     802:	f1 04       	cpc	r15, r1
     804:	24 f3       	brlt	.-56     	; 0x7ce <S7egment_Write+0xe0>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Bits[i].Port,Segment_Handler->S7eg_Bits[i].Pin_Num,(Low_Num>>i)&(0x01));
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Control[S7eg_Num+1].Port,Segment_Handler->S7eg_Control[S7eg_Num+1].Pin_Num,1);
     806:	0f 5f       	subi	r16, 0xFF	; 255
     808:	1f 4f       	sbci	r17, 0xFF	; 255
     80a:	c8 01       	movw	r24, r16
     80c:	88 0f       	add	r24, r24
     80e:	99 1f       	adc	r25, r25
     810:	08 0f       	add	r16, r24
     812:	19 1f       	adc	r17, r25
     814:	c0 0f       	add	r28, r16
     816:	d1 1f       	adc	r29, r17
     818:	41 e0       	ldi	r20, 0x01	; 1
     81a:	6a 81       	ldd	r22, Y+2	; 0x02
     81c:	88 81       	ld	r24, Y
     81e:	99 81       	ldd	r25, Y+1	; 0x01
     820:	0e 94 26 01 	call	0x24c	; 0x24c <HAL_GPIO_WRITEPIN>
	vTaskDelay(6);	
     824:	86 e0       	ldi	r24, 0x06	; 6
     826:	90 e0       	ldi	r25, 0x00	; 0
     828:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <vTaskDelay>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Control[S7eg_Num+1].Port,Segment_Handler->S7eg_Control[S7eg_Num+1].Pin_Num,0);
     82c:	40 e0       	ldi	r20, 0x00	; 0
     82e:	6a 81       	ldd	r22, Y+2	; 0x02
     830:	88 81       	ld	r24, Y
     832:	99 81       	ldd	r25, Y+1	; 0x01
     834:	0e 94 26 01 	call	0x24c	; 0x24c <HAL_GPIO_WRITEPIN>
     838:	df 91       	pop	r29
     83a:	cf 91       	pop	r28
     83c:	1f 91       	pop	r17
     83e:	0f 91       	pop	r16
     840:	ff 90       	pop	r15
     842:	ef 90       	pop	r14
     844:	df 90       	pop	r13
     846:	08 95       	ret

00000848 <InterrutInt>:
EXIT_Handler_t  exti_handler ;



void InterrutInt(void)
{
     848:	cf 93       	push	r28
     84a:	df 93       	push	r29
		exti_handler.EXTI_NUM = EXTI_NUM_0 ;
     84c:	ca e0       	ldi	r28, 0x0A	; 10
     84e:	d1 e0       	ldi	r29, 0x01	; 1
     850:	81 e0       	ldi	r24, 0x01	; 1
     852:	88 83       	st	Y, r24
		exti_handler.EXTI_EDGE_DETECTION = EXTI_EDGE_LOW_LENEL ;
     854:	19 82       	std	Y+1, r1	; 0x01
		EXTI_Init(&exti_handler);
     856:	ce 01       	movw	r24, r28
     858:	0e 94 49 00 	call	0x92	; 0x92 <EXTI_Init>
		
		exti_handler.EXTI_NUM = EXTI_NUM_1 ;
     85c:	82 e0       	ldi	r24, 0x02	; 2
     85e:	88 83       	st	Y, r24
		exti_handler.EXTI_EDGE_DETECTION = EXTI_EDGE_LOW_LENEL ;
     860:	19 82       	std	Y+1, r1	; 0x01
		EXTI_Init(&exti_handler);
     862:	ce 01       	movw	r24, r28
     864:	0e 94 49 00 	call	0x92	; 0x92 <EXTI_Init>
		
		exti_handler.EXTI_NUM = EXTI_NUM_2 ;
     868:	18 82       	st	Y, r1
		exti_handler.EXTI_EDGE_DETECTION = EXTI_EDGE_LOW_LENEL ;
     86a:	19 82       	std	Y+1, r1	; 0x01
		EXTI_Init(&exti_handler);
     86c:	ce 01       	movw	r24, r28
     86e:	0e 94 49 00 	call	0x92	; 0x92 <EXTI_Init>
		
	
     872:	df 91       	pop	r29
     874:	cf 91       	pop	r28
     876:	08 95       	ret

00000878 <INT0_Handler>:
void INT0_Handler(void )
{

	 static uint8_t i =0 ;

		xQueueSendFromISR(XQueueSYNC , &i , NULL);
     878:	20 e0       	ldi	r18, 0x00	; 0
     87a:	40 e0       	ldi	r20, 0x00	; 0
     87c:	50 e0       	ldi	r21, 0x00	; 0
     87e:	6c e9       	ldi	r22, 0x9C	; 156
     880:	70 e0       	ldi	r23, 0x00	; 0
     882:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <XQueueSYNC>
     886:	90 91 13 01 	lds	r25, 0x0113	; 0x800113 <XQueueSYNC+0x1>
     88a:	0e 94 2d 0a 	call	0x145a	; 0x145a <xQueueGenericSendFromISR>
		
		
	if(i++ == 1)
     88e:	80 91 9c 00 	lds	r24, 0x009C	; 0x80009c <__data_end>
     892:	91 e0       	ldi	r25, 0x01	; 1
     894:	98 0f       	add	r25, r24
     896:	90 93 9c 00 	sts	0x009C, r25	; 0x80009c <__data_end>
     89a:	81 30       	cpi	r24, 0x01	; 1
     89c:	11 f4       	brne	.+4      	; 0x8a2 <INT0_Handler+0x2a>
		i=0 ;
     89e:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <__data_end>
     8a2:	08 95       	ret

000008a4 <INT1_Handler>:
}

void INT1_Handler(void )
{
     8a4:	cf 93       	push	r28
     8a6:	df 93       	push	r29
     8a8:	1f 92       	push	r1
     8aa:	cd b7       	in	r28, 0x3d	; 61
     8ac:	de b7       	in	r29, 0x3e	; 62
	uint8_t state  =  Increase  ;
     8ae:	19 82       	std	Y+1, r1	; 0x01
	xQueueSendFromISR(XQueueUpdateRTC,&state,NULL);	
     8b0:	20 e0       	ldi	r18, 0x00	; 0
     8b2:	40 e0       	ldi	r20, 0x00	; 0
     8b4:	50 e0       	ldi	r21, 0x00	; 0
     8b6:	be 01       	movw	r22, r28
     8b8:	6f 5f       	subi	r22, 0xFF	; 255
     8ba:	7f 4f       	sbci	r23, 0xFF	; 255
     8bc:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <XQueueUpdateRTC>
     8c0:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <XQueueUpdateRTC+0x1>
     8c4:	0e 94 2d 0a 	call	0x145a	; 0x145a <xQueueGenericSendFromISR>

}
     8c8:	0f 90       	pop	r0
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	08 95       	ret

000008d0 <INT2_Handler>:

void INT2_Handler(void )
{
     8d0:	cf 93       	push	r28
     8d2:	df 93       	push	r29
     8d4:	1f 92       	push	r1
     8d6:	cd b7       	in	r28, 0x3d	; 61
     8d8:	de b7       	in	r29, 0x3e	; 62
	uint8_t state = Decrease ;
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	89 83       	std	Y+1, r24	; 0x01
	
	xQueueSendFromISR(XQueueUpdateRTC,&state,NULL);	
     8de:	20 e0       	ldi	r18, 0x00	; 0
     8e0:	40 e0       	ldi	r20, 0x00	; 0
     8e2:	50 e0       	ldi	r21, 0x00	; 0
     8e4:	be 01       	movw	r22, r28
     8e6:	6f 5f       	subi	r22, 0xFF	; 255
     8e8:	7f 4f       	sbci	r23, 0xFF	; 255
     8ea:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <XQueueUpdateRTC>
     8ee:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <XQueueUpdateRTC+0x1>
     8f2:	0e 94 2d 0a 	call	0x145a	; 0x145a <xQueueGenericSendFromISR>

}
     8f6:	0f 90       	pop	r0
     8f8:	df 91       	pop	r29
     8fa:	cf 91       	pop	r28
     8fc:	08 95       	ret

000008fe <SYNC_Task>:



void SYNC_Task(void  * Param) 
{
     8fe:	cf 93       	push	r28
     900:	df 93       	push	r29
     902:	00 d0       	rcall	.+0      	; 0x904 <SYNC_Task+0x6>
     904:	cd b7       	in	r28, 0x3d	; 61
     906:	de b7       	in	r29, 0x3e	; 62
int i =0 ;
     908:	1a 82       	std	Y+2, r1	; 0x02
     90a:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		xQueueReceive(XQueueSYNC , &i ,portMAX_DELAY);
     90c:	20 e0       	ldi	r18, 0x00	; 0
     90e:	4f ef       	ldi	r20, 0xFF	; 255
     910:	5f ef       	ldi	r21, 0xFF	; 255
     912:	be 01       	movw	r22, r28
     914:	6f 5f       	subi	r22, 0xFF	; 255
     916:	7f 4f       	sbci	r23, 0xFF	; 255
     918:	80 91 12 01 	lds	r24, 0x0112	; 0x800112 <XQueueSYNC>
     91c:	90 91 13 01 	lds	r25, 0x0113	; 0x800113 <XQueueSYNC+0x1>
     920:	0e 94 67 0a 	call	0x14ce	; 0x14ce <xQueueGenericReceive>
		if (i == 0)
     924:	89 81       	ldd	r24, Y+1	; 0x01
     926:	9a 81       	ldd	r25, Y+2	; 0x02
     928:	89 2b       	or	r24, r25
     92a:	a1 f4       	brne	.+40     	; 0x954 <SYNC_Task+0x56>
		{
		
		vTaskSuspend(ShowTimeTaskhandler);
     92c:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <ShowTimeTaskhandler>
     930:	90 91 0f 01 	lds	r25, 0x010F	; 0x80010f <ShowTimeTaskhandler+0x1>
     934:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <vTaskSuspend>
		vTaskResume(ShowDateTaskhandler);
     938:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <ShowDateTaskhandler>
     93c:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <ShowDateTaskhandler+0x1>
     940:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <vTaskResume>
		taskENTER_CRITICAL();
     944:	0f b6       	in	r0, 0x3f	; 63
     946:	f8 94       	cli
     948:	0f 92       	push	r0
		ShowTimeStatus  =  Suspend ;
     94a:	10 92 9d 00 	sts	0x009D, r1	; 0x80009d <ShowTimeStatus>
		taskEXIT_CRITICAL();
     94e:	0f 90       	pop	r0
     950:	0f be       	out	0x3f, r0	; 63
     952:	14 c0       	rjmp	.+40     	; 0x97c <SYNC_Task+0x7e>
		
		
		}
		else
		{
		vTaskSuspend(ShowDateTaskhandler);
     954:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <ShowDateTaskhandler>
     958:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <ShowDateTaskhandler+0x1>
     95c:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <vTaskSuspend>
		vTaskResume(ShowTimeTaskhandler);	
     960:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <ShowTimeTaskhandler>
     964:	90 91 0f 01 	lds	r25, 0x010F	; 0x80010f <ShowTimeTaskhandler+0x1>
     968:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <vTaskResume>
		
		taskENTER_CRITICAL();
     96c:	0f b6       	in	r0, 0x3f	; 63
     96e:	f8 94       	cli
     970:	0f 92       	push	r0
		ShowTimeStatus  =  Resumed ;	
     972:	81 e0       	ldi	r24, 0x01	; 1
     974:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <ShowTimeStatus>
		taskEXIT_CRITICAL();		
     978:	0f 90       	pop	r0
     97a:	0f be       	out	0x3f, r0	; 63
				
			
		}
		vTaskDelay(5);
     97c:	85 e0       	ldi	r24, 0x05	; 5
     97e:	90 e0       	ldi	r25, 0x00	; 0
     980:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <vTaskDelay>
		
	}
     984:	c3 cf       	rjmp	.-122    	; 0x90c <SYNC_Task+0xe>

00000986 <main>:


int main(void)
{
	
	DS1305_Init();
     986:	0e 94 e3 01 	call	0x3c6	; 0x3c6 <DS1305_Init>
	S7egment_Init(&S7egHendler);
     98a:	89 e7       	ldi	r24, 0x79	; 121
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	0e 94 2f 03 	call	0x65e	; 0x65e <S7egment_Init>
	RTC_Set_Time(&Time);
     992:	84 e7       	ldi	r24, 0x74	; 116
     994:	90 e0       	ldi	r25, 0x00	; 0
     996:	0e 94 aa 02 	call	0x554	; 0x554 <RTC_Set_Time>
	RTC_Set_Date(&Date);
     99a:	8f e6       	ldi	r24, 0x6F	; 111
     99c:	90 e0       	ldi	r25, 0x00	; 0
     99e:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <RTC_Set_Date>
	
	
	InterrutInt();
     9a2:	0e 94 24 04 	call	0x848	; 0x848 <InterrutInt>
	EXIT_INT0_CallBack(INT0_Handler);
     9a6:	8c e3       	ldi	r24, 0x3C	; 60
     9a8:	94 e0       	ldi	r25, 0x04	; 4
     9aa:	0e 94 81 00 	call	0x102	; 0x102 <EXIT_INT0_CallBack>
	EXIT_INT1_CallBack(INT1_Handler);
     9ae:	82 e5       	ldi	r24, 0x52	; 82
     9b0:	94 e0       	ldi	r25, 0x04	; 4
     9b2:	0e 94 86 00 	call	0x10c	; 0x10c <EXIT_INT1_CallBack>
	EXIT_INT2_CallBack(INT2_Handler);
     9b6:	88 e6       	ldi	r24, 0x68	; 104
     9b8:	94 e0       	ldi	r25, 0x04	; 4
     9ba:	0e 94 8b 00 	call	0x116	; 0x116 <EXIT_INT2_CallBack>
	
		
	xMutexGoalKeeper = xSemaphoreCreateMutex();	
     9be:	81 e0       	ldi	r24, 0x01	; 1
     9c0:	0e 94 1f 0a 	call	0x143e	; 0x143e <xQueueCreateMutex>
     9c4:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <xMutexGoalKeeper+0x1>
     9c8:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <xMutexGoalKeeper>
	
	
	
	XMailboxGoalKeeper  =		xQueueCreate(1,sizeof(RTC_Data));
     9cc:	40 e0       	ldi	r20, 0x00	; 0
     9ce:	6a e0       	ldi	r22, 0x0A	; 10
     9d0:	81 e0       	ldi	r24, 0x01	; 1
     9d2:	0e 94 53 09 	call	0x12a6	; 0x12a6 <xQueueGenericCreate>
     9d6:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <XMailboxGoalKeeper+0x1>
     9da:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <XMailboxGoalKeeper>
	
	XQueueSYNC			=		xQueueCreate(1,sizeof(uint8_t));
     9de:	40 e0       	ldi	r20, 0x00	; 0
     9e0:	61 e0       	ldi	r22, 0x01	; 1
     9e2:	81 e0       	ldi	r24, 0x01	; 1
     9e4:	0e 94 53 09 	call	0x12a6	; 0x12a6 <xQueueGenericCreate>
     9e8:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <XQueueSYNC+0x1>
     9ec:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <XQueueSYNC>
	
	XQueueUpdateRTC		=		xQueueCreate(1,sizeof(uint8_t));
     9f0:	40 e0       	ldi	r20, 0x00	; 0
     9f2:	61 e0       	ldi	r22, 0x01	; 1
     9f4:	81 e0       	ldi	r24, 0x01	; 1
     9f6:	0e 94 53 09 	call	0x12a6	; 0x12a6 <xQueueGenericCreate>
     9fa:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <XQueueUpdateRTC+0x1>
     9fe:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <XQueueUpdateRTC>
	
	
	xTaskCreate(ShowTimeTask,NULL,200,NULL,1,&ShowTimeTaskhandler);
     a02:	0f 2e       	mov	r0, r31
     a04:	fe e0       	ldi	r31, 0x0E	; 14
     a06:	ef 2e       	mov	r14, r31
     a08:	f1 e0       	ldi	r31, 0x01	; 1
     a0a:	ff 2e       	mov	r15, r31
     a0c:	f0 2d       	mov	r31, r0
     a0e:	01 e0       	ldi	r16, 0x01	; 1
     a10:	20 e0       	ldi	r18, 0x00	; 0
     a12:	30 e0       	ldi	r19, 0x00	; 0
     a14:	48 ec       	ldi	r20, 0xC8	; 200
     a16:	50 e0       	ldi	r21, 0x00	; 0
     a18:	60 e0       	ldi	r22, 0x00	; 0
     a1a:	70 e0       	ldi	r23, 0x00	; 0
     a1c:	87 e4       	ldi	r24, 0x47	; 71
     a1e:	95 e0       	ldi	r25, 0x05	; 5
     a20:	0e 94 b8 0c 	call	0x1970	; 0x1970 <xTaskCreate>
	xTaskCreate(ShowDateTask,NULL,200,NULL,1,&ShowDateTaskhandler);	
     a24:	0f 2e       	mov	r0, r31
     a26:	f0 e2       	ldi	r31, 0x20	; 32
     a28:	ef 2e       	mov	r14, r31
     a2a:	f1 e0       	ldi	r31, 0x01	; 1
     a2c:	ff 2e       	mov	r15, r31
     a2e:	f0 2d       	mov	r31, r0
     a30:	20 e0       	ldi	r18, 0x00	; 0
     a32:	30 e0       	ldi	r19, 0x00	; 0
     a34:	48 ec       	ldi	r20, 0xC8	; 200
     a36:	50 e0       	ldi	r21, 0x00	; 0
     a38:	60 e0       	ldi	r22, 0x00	; 0
     a3a:	70 e0       	ldi	r23, 0x00	; 0
     a3c:	8e e6       	ldi	r24, 0x6E	; 110
     a3e:	95 e0       	ldi	r25, 0x05	; 5
     a40:	0e 94 b8 0c 	call	0x1970	; 0x1970 <xTaskCreate>
	xTaskCreate(GoalKeeper_Task,NULL,200,NULL,3,NULL);	
     a44:	e1 2c       	mov	r14, r1
     a46:	f1 2c       	mov	r15, r1
     a48:	03 e0       	ldi	r16, 0x03	; 3
     a4a:	20 e0       	ldi	r18, 0x00	; 0
     a4c:	30 e0       	ldi	r19, 0x00	; 0
     a4e:	48 ec       	ldi	r20, 0xC8	; 200
     a50:	50 e0       	ldi	r21, 0x00	; 0
     a52:	60 e0       	ldi	r22, 0x00	; 0
     a54:	70 e0       	ldi	r23, 0x00	; 0
     a56:	85 e9       	ldi	r24, 0x95	; 149
     a58:	95 e0       	ldi	r25, 0x05	; 5
     a5a:	0e 94 b8 0c 	call	0x1970	; 0x1970 <xTaskCreate>
	xTaskCreate(SYNC_Task,NULL,85,NULL,3,NULL);	
     a5e:	20 e0       	ldi	r18, 0x00	; 0
     a60:	30 e0       	ldi	r19, 0x00	; 0
     a62:	45 e5       	ldi	r20, 0x55	; 85
     a64:	50 e0       	ldi	r21, 0x00	; 0
     a66:	60 e0       	ldi	r22, 0x00	; 0
     a68:	70 e0       	ldi	r23, 0x00	; 0
     a6a:	8f e7       	ldi	r24, 0x7F	; 127
     a6c:	94 e0       	ldi	r25, 0x04	; 4
     a6e:	0e 94 b8 0c 	call	0x1970	; 0x1970 <xTaskCreate>
	xTaskCreate(UpdateRTC_Task,NULL,100,NULL,4,NULL);	
     a72:	04 e0       	ldi	r16, 0x04	; 4
     a74:	20 e0       	ldi	r18, 0x00	; 0
     a76:	30 e0       	ldi	r19, 0x00	; 0
     a78:	44 e6       	ldi	r20, 0x64	; 100
     a7a:	50 e0       	ldi	r21, 0x00	; 0
     a7c:	60 e0       	ldi	r22, 0x00	; 0
     a7e:	70 e0       	ldi	r23, 0x00	; 0
     a80:	8e ec       	ldi	r24, 0xCE	; 206
     a82:	95 e0       	ldi	r25, 0x05	; 5
     a84:	0e 94 b8 0c 	call	0x1970	; 0x1970 <xTaskCreate>
	
		vTaskStartScheduler();
     a88:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <vTaskStartScheduler>
     a8c:	ff cf       	rjmp	.-2      	; 0xa8c <main+0x106>

00000a8e <ShowTimeTask>:
void   ShowTimeTask(void  * param)
{

	

			Buf.RTCTime.RTC_Time_Format = RTC_Format_BIN ;
     a8e:	82 e0       	ldi	r24, 0x02	; 2
     a90:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <Buf+0x3>

	
	while(1)
	{
			xQueueReceive(XMailboxGoalKeeper, &Buf ,1);	
     a94:	20 e0       	ldi	r18, 0x00	; 0
     a96:	41 e0       	ldi	r20, 0x01	; 1
     a98:	50 e0       	ldi	r21, 0x00	; 0
     a9a:	6e e9       	ldi	r22, 0x9E	; 158
     a9c:	70 e0       	ldi	r23, 0x00	; 0
     a9e:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <XMailboxGoalKeeper>
     aa2:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <XMailboxGoalKeeper+0x1>
     aa6:	0e 94 67 0a 	call	0x14ce	; 0x14ce <xQueueGenericReceive>
			S7egment_Write(Buf.RTCTime.Hours  , 0,&S7egHendler);
     aaa:	ce e9       	ldi	r28, 0x9E	; 158
     aac:	d0 e0       	ldi	r29, 0x00	; 0
     aae:	49 e7       	ldi	r20, 0x79	; 121
     ab0:	50 e0       	ldi	r21, 0x00	; 0
     ab2:	60 e0       	ldi	r22, 0x00	; 0
     ab4:	8a 81       	ldd	r24, Y+2	; 0x02
     ab6:	0e 94 77 03 	call	0x6ee	; 0x6ee <S7egment_Write>
			S7egment_Write(Buf.RTCTime.Minutes ,2,&S7egHendler);
     aba:	49 e7       	ldi	r20, 0x79	; 121
     abc:	50 e0       	ldi	r21, 0x00	; 0
     abe:	62 e0       	ldi	r22, 0x02	; 2
     ac0:	89 81       	ldd	r24, Y+1	; 0x01
     ac2:	0e 94 77 03 	call	0x6ee	; 0x6ee <S7egment_Write>
			S7egment_Write(Buf.RTCTime.Seconds ,4,&S7egHendler);	
     ac6:	49 e7       	ldi	r20, 0x79	; 121
     ac8:	50 e0       	ldi	r21, 0x00	; 0
     aca:	64 e0       	ldi	r22, 0x04	; 4
     acc:	88 81       	ld	r24, Y
     ace:	0e 94 77 03 	call	0x6ee	; 0x6ee <S7egment_Write>
			vTaskDelay(1);
     ad2:	81 e0       	ldi	r24, 0x01	; 1
     ad4:	90 e0       	ldi	r25, 0x00	; 0
     ad6:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <vTaskDelay>
     ada:	dc cf       	rjmp	.-72     	; 0xa94 <ShowTimeTask+0x6>

00000adc <ShowDateTask>:
{
	
	
	

	Buf.RTCDate.RTC_Time_Format = RTC_Format_BIN ;
     adc:	82 e0       	ldi	r24, 0x02	; 2
     ade:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <Buf+0x9>
	
	while(1)
	{
		
			xQueueReceive(XMailboxGoalKeeper, &Buf ,1);			
     ae2:	20 e0       	ldi	r18, 0x00	; 0
     ae4:	41 e0       	ldi	r20, 0x01	; 1
     ae6:	50 e0       	ldi	r21, 0x00	; 0
     ae8:	6e e9       	ldi	r22, 0x9E	; 158
     aea:	70 e0       	ldi	r23, 0x00	; 0
     aec:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <XMailboxGoalKeeper>
     af0:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <XMailboxGoalKeeper+0x1>
     af4:	0e 94 67 0a 	call	0x14ce	; 0x14ce <xQueueGenericReceive>
			S7egment_Write(Buf.RTCDate.Year , 0,&S7egHendler);
     af8:	ce e9       	ldi	r28, 0x9E	; 158
     afa:	d0 e0       	ldi	r29, 0x00	; 0
     afc:	49 e7       	ldi	r20, 0x79	; 121
     afe:	50 e0       	ldi	r21, 0x00	; 0
     b00:	60 e0       	ldi	r22, 0x00	; 0
     b02:	88 85       	ldd	r24, Y+8	; 0x08
     b04:	0e 94 77 03 	call	0x6ee	; 0x6ee <S7egment_Write>
			S7egment_Write(Buf.RTCDate.month,2,&S7egHendler);
     b08:	49 e7       	ldi	r20, 0x79	; 121
     b0a:	50 e0       	ldi	r21, 0x00	; 0
     b0c:	62 e0       	ldi	r22, 0x02	; 2
     b0e:	8f 81       	ldd	r24, Y+7	; 0x07
     b10:	0e 94 77 03 	call	0x6ee	; 0x6ee <S7egment_Write>
			S7egment_Write(Buf.RTCDate.DayDate  ,4,&S7egHendler);
     b14:	49 e7       	ldi	r20, 0x79	; 121
     b16:	50 e0       	ldi	r21, 0x00	; 0
     b18:	64 e0       	ldi	r22, 0x04	; 4
     b1a:	8e 81       	ldd	r24, Y+6	; 0x06
     b1c:	0e 94 77 03 	call	0x6ee	; 0x6ee <S7egment_Write>
			vTaskDelay(1);	
     b20:	81 e0       	ldi	r24, 0x01	; 1
     b22:	90 e0       	ldi	r25, 0x00	; 0
     b24:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <vTaskDelay>
     b28:	dc cf       	rjmp	.-72     	; 0xae2 <ShowDateTask+0x6>

00000b2a <GoalKeeper_Task>:
}

void  GoalKeeper_Task(void * Param)
{

		Buf.RTCDate.RTC_Time_Format = RTC_Format_BIN ;
     b2a:	ee e9       	ldi	r30, 0x9E	; 158
     b2c:	f0 e0       	ldi	r31, 0x00	; 0
     b2e:	82 e0       	ldi	r24, 0x02	; 2
     b30:	81 87       	std	Z+9, r24	; 0x09
		Buf.RTCTime.RTC_Time_Format = RTC_Format_BIN ;
     b32:	83 83       	std	Z+3, r24	; 0x03
		vTaskSuspend(ShowDateTaskhandler);
     b34:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <ShowDateTaskhandler>
     b38:	90 91 21 01 	lds	r25, 0x0121	; 0x800121 <ShowDateTaskhandler+0x1>
     b3c:	0e 94 14 0f 	call	0x1e28	; 0x1e28 <vTaskSuspend>

	while(1)
	{
		/* access I2C non shared resources so we need to protect it through mutex */
		xSemaphoreTake(xMutexGoalKeeper,portMAX_DELAY);
     b40:	20 e0       	ldi	r18, 0x00	; 0
     b42:	4f ef       	ldi	r20, 0xFF	; 255
     b44:	5f ef       	ldi	r21, 0xFF	; 255
     b46:	60 e0       	ldi	r22, 0x00	; 0
     b48:	70 e0       	ldi	r23, 0x00	; 0
     b4a:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <xMutexGoalKeeper>
     b4e:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <xMutexGoalKeeper+0x1>
     b52:	0e 94 67 0a 	call	0x14ce	; 0x14ce <xQueueGenericReceive>
		RTC_Get_Time(&Buf.RTCTime);
     b56:	8e e9       	ldi	r24, 0x9E	; 158
     b58:	90 e0       	ldi	r25, 0x00	; 0
     b5a:	0e 94 f5 01 	call	0x3ea	; 0x3ea <RTC_Get_Time>
		RTC_Get_Date(&Buf.RTCDate);
     b5e:	83 ea       	ldi	r24, 0xA3	; 163
     b60:	90 e0       	ldi	r25, 0x00	; 0
     b62:	0e 94 4b 02 	call	0x496	; 0x496 <RTC_Get_Date>
		xSemaphoreGive(xMutexGoalKeeper);		
     b66:	20 e0       	ldi	r18, 0x00	; 0
     b68:	40 e0       	ldi	r20, 0x00	; 0
     b6a:	50 e0       	ldi	r21, 0x00	; 0
     b6c:	60 e0       	ldi	r22, 0x00	; 0
     b6e:	70 e0       	ldi	r23, 0x00	; 0
     b70:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <xMutexGoalKeeper>
     b74:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <xMutexGoalKeeper+0x1>
     b78:	0e 94 7d 09 	call	0x12fa	; 0x12fa <xQueueGenericSend>
		
		/* use mailbox to send message */
		xQueueOverwrite(XMailboxGoalKeeper,&Buf);
     b7c:	22 e0       	ldi	r18, 0x02	; 2
     b7e:	40 e0       	ldi	r20, 0x00	; 0
     b80:	50 e0       	ldi	r21, 0x00	; 0
     b82:	6e e9       	ldi	r22, 0x9E	; 158
     b84:	70 e0       	ldi	r23, 0x00	; 0
     b86:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <XMailboxGoalKeeper>
     b8a:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <XMailboxGoalKeeper+0x1>
     b8e:	0e 94 7d 09 	call	0x12fa	; 0x12fa <xQueueGenericSend>
		vTaskDelay(400);
     b92:	80 e9       	ldi	r24, 0x90	; 144
     b94:	91 e0       	ldi	r25, 0x01	; 1
     b96:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <vTaskDelay>
     b9a:	d2 cf       	rjmp	.-92     	; 0xb40 <GoalKeeper_Task+0x16>

00000b9c <UpdateRTC_Task>:
}



void UpdateRTC_Task(void * Param)
{
     b9c:	cf 93       	push	r28
     b9e:	df 93       	push	r29
     ba0:	1f 92       	push	r1
     ba2:	cd b7       	in	r28, 0x3d	; 61
     ba4:	de b7       	in	r29, 0x3e	; 62
	
	uint8_t state = 0;
     ba6:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		xQueueReceive(XQueueUpdateRTC,&state,portMAX_DELAY);
     ba8:	20 e0       	ldi	r18, 0x00	; 0
     baa:	4f ef       	ldi	r20, 0xFF	; 255
     bac:	5f ef       	ldi	r21, 0xFF	; 255
     bae:	be 01       	movw	r22, r28
     bb0:	6f 5f       	subi	r22, 0xFF	; 255
     bb2:	7f 4f       	sbci	r23, 0xFF	; 255
     bb4:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <XQueueUpdateRTC>
     bb8:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <XQueueUpdateRTC+0x1>
     bbc:	0e 94 67 0a 	call	0x14ce	; 0x14ce <xQueueGenericReceive>
		xSemaphoreTake(xMutexGoalKeeper,portMAX_DELAY);		/* must take mutex before enter critical section (I2C)*/
     bc0:	20 e0       	ldi	r18, 0x00	; 0
     bc2:	4f ef       	ldi	r20, 0xFF	; 255
     bc4:	5f ef       	ldi	r21, 0xFF	; 255
     bc6:	60 e0       	ldi	r22, 0x00	; 0
     bc8:	70 e0       	ldi	r23, 0x00	; 0
     bca:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <xMutexGoalKeeper>
     bce:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <xMutexGoalKeeper+0x1>
     bd2:	0e 94 67 0a 	call	0x14ce	; 0x14ce <xQueueGenericReceive>
		RTC_Get_Time(&Buf.RTCTime);
     bd6:	8e e9       	ldi	r24, 0x9E	; 158
     bd8:	90 e0       	ldi	r25, 0x00	; 0
     bda:	0e 94 f5 01 	call	0x3ea	; 0x3ea <RTC_Get_Time>
		RTC_Get_Date(&Buf.RTCDate);
     bde:	83 ea       	ldi	r24, 0xA3	; 163
     be0:	90 e0       	ldi	r25, 0x00	; 0
     be2:	0e 94 4b 02 	call	0x496	; 0x496 <RTC_Get_Date>
		taskENTER_CRITICAL();
     be6:	0f b6       	in	r0, 0x3f	; 63
     be8:	f8 94       	cli
     bea:	0f 92       	push	r0
	if(state == Decrease)
     bec:	89 81       	ldd	r24, Y+1	; 0x01
     bee:	81 30       	cpi	r24, 0x01	; 1
     bf0:	81 f4       	brne	.+32     	; 0xc12 <UpdateRTC_Task+0x76>
	{
		if(ShowTimeStatus == Suspend)  // increase time
     bf2:	80 91 9d 00 	lds	r24, 0x009D	; 0x80009d <ShowTimeStatus>
     bf6:	81 11       	cpse	r24, r1
     bf8:	06 c0       	rjmp	.+12     	; 0xc06 <UpdateRTC_Task+0x6a>
		{
				Buf.RTCTime.Seconds--;	
     bfa:	ee e9       	ldi	r30, 0x9E	; 158
     bfc:	f0 e0       	ldi	r31, 0x00	; 0
     bfe:	80 81       	ld	r24, Z
     c00:	81 50       	subi	r24, 0x01	; 1
     c02:	80 83       	st	Z, r24
     c04:	15 c0       	rjmp	.+42     	; 0xc30 <UpdateRTC_Task+0x94>
		}
		else   // increase date 
		{
				Buf.RTCDate.DayDate--;
     c06:	ee e9       	ldi	r30, 0x9E	; 158
     c08:	f0 e0       	ldi	r31, 0x00	; 0
     c0a:	86 81       	ldd	r24, Z+6	; 0x06
     c0c:	81 50       	subi	r24, 0x01	; 1
     c0e:	86 83       	std	Z+6, r24	; 0x06
     c10:	0f c0       	rjmp	.+30     	; 0xc30 <UpdateRTC_Task+0x94>
		}
	}else
	{
		
		if(ShowTimeStatus == Suspend)  // increase time
     c12:	80 91 9d 00 	lds	r24, 0x009D	; 0x80009d <ShowTimeStatus>
     c16:	81 11       	cpse	r24, r1
     c18:	06 c0       	rjmp	.+12     	; 0xc26 <UpdateRTC_Task+0x8a>
		{
			Buf.RTCTime.Seconds++;
     c1a:	ee e9       	ldi	r30, 0x9E	; 158
     c1c:	f0 e0       	ldi	r31, 0x00	; 0
     c1e:	80 81       	ld	r24, Z
     c20:	8f 5f       	subi	r24, 0xFF	; 255
     c22:	80 83       	st	Z, r24
     c24:	05 c0       	rjmp	.+10     	; 0xc30 <UpdateRTC_Task+0x94>
		}
		else   // increase date
		{
			Buf.RTCDate.DayDate++;
     c26:	ee e9       	ldi	r30, 0x9E	; 158
     c28:	f0 e0       	ldi	r31, 0x00	; 0
     c2a:	86 81       	ldd	r24, Z+6	; 0x06
     c2c:	8f 5f       	subi	r24, 0xFF	; 255
     c2e:	86 83       	std	Z+6, r24	; 0x06
		}
		
	}
		taskEXIT_CRITICAL();
     c30:	0f 90       	pop	r0
     c32:	0f be       	out	0x3f, r0	; 63
		
		
		
		RTC_Set_Time(&Buf.RTCTime);
     c34:	8e e9       	ldi	r24, 0x9E	; 158
     c36:	90 e0       	ldi	r25, 0x00	; 0
     c38:	0e 94 aa 02 	call	0x554	; 0x554 <RTC_Set_Time>
		RTC_Set_Date(&Buf.RTCDate);
     c3c:	83 ea       	ldi	r24, 0xA3	; 163
     c3e:	90 e0       	ldi	r25, 0x00	; 0
     c40:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <RTC_Set_Date>
		xSemaphoreGive(xMutexGoalKeeper);		
     c44:	20 e0       	ldi	r18, 0x00	; 0
     c46:	40 e0       	ldi	r20, 0x00	; 0
     c48:	50 e0       	ldi	r21, 0x00	; 0
     c4a:	60 e0       	ldi	r22, 0x00	; 0
     c4c:	70 e0       	ldi	r23, 0x00	; 0
     c4e:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <xMutexGoalKeeper>
     c52:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <xMutexGoalKeeper+0x1>
     c56:	0e 94 7d 09 	call	0x12fa	; 0x12fa <xQueueGenericSend>
		
	}
     c5a:	a6 cf       	rjmp	.-180    	; 0xba8 <UpdateRTC_Task+0xc>

00000c5c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     c5c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c5e:	03 96       	adiw	r24, 0x03	; 3
     c60:	92 83       	std	Z+2, r25	; 0x02
     c62:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     c64:	2f ef       	ldi	r18, 0xFF	; 255
     c66:	3f ef       	ldi	r19, 0xFF	; 255
     c68:	34 83       	std	Z+4, r19	; 0x04
     c6a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c6c:	96 83       	std	Z+6, r25	; 0x06
     c6e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c70:	90 87       	std	Z+8, r25	; 0x08
     c72:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     c74:	10 82       	st	Z, r1
     c76:	08 95       	ret

00000c78 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     c78:	fc 01       	movw	r30, r24
     c7a:	11 86       	std	Z+9, r1	; 0x09
     c7c:	10 86       	std	Z+8, r1	; 0x08
     c7e:	08 95       	ret

00000c80 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     c80:	cf 93       	push	r28
     c82:	df 93       	push	r29
     c84:	9c 01       	movw	r18, r24
     c86:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     c88:	dc 01       	movw	r26, r24
     c8a:	11 96       	adiw	r26, 0x01	; 1
     c8c:	cd 91       	ld	r28, X+
     c8e:	dc 91       	ld	r29, X
     c90:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     c92:	d3 83       	std	Z+3, r29	; 0x03
     c94:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     c96:	8c 81       	ldd	r24, Y+4	; 0x04
     c98:	9d 81       	ldd	r25, Y+5	; 0x05
     c9a:	95 83       	std	Z+5, r25	; 0x05
     c9c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     c9e:	8c 81       	ldd	r24, Y+4	; 0x04
     ca0:	9d 81       	ldd	r25, Y+5	; 0x05
     ca2:	dc 01       	movw	r26, r24
     ca4:	13 96       	adiw	r26, 0x03	; 3
     ca6:	7c 93       	st	X, r23
     ca8:	6e 93       	st	-X, r22
     caa:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     cac:	7d 83       	std	Y+5, r23	; 0x05
     cae:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     cb0:	31 87       	std	Z+9, r19	; 0x09
     cb2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     cb4:	f9 01       	movw	r30, r18
     cb6:	80 81       	ld	r24, Z
     cb8:	8f 5f       	subi	r24, 0xFF	; 255
     cba:	80 83       	st	Z, r24
}
     cbc:	df 91       	pop	r29
     cbe:	cf 91       	pop	r28
     cc0:	08 95       	ret

00000cc2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     cc2:	cf 93       	push	r28
     cc4:	df 93       	push	r29
     cc6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     cc8:	48 81       	ld	r20, Y
     cca:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     ccc:	4f 3f       	cpi	r20, 0xFF	; 255
     cce:	2f ef       	ldi	r18, 0xFF	; 255
     cd0:	52 07       	cpc	r21, r18
     cd2:	21 f4       	brne	.+8      	; 0xcdc <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     cd4:	fc 01       	movw	r30, r24
     cd6:	a7 81       	ldd	r26, Z+7	; 0x07
     cd8:	b0 85       	ldd	r27, Z+8	; 0x08
     cda:	0d c0       	rjmp	.+26     	; 0xcf6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     cdc:	dc 01       	movw	r26, r24
     cde:	13 96       	adiw	r26, 0x03	; 3
     ce0:	01 c0       	rjmp	.+2      	; 0xce4 <vListInsert+0x22>
     ce2:	df 01       	movw	r26, r30
     ce4:	12 96       	adiw	r26, 0x02	; 2
     ce6:	ed 91       	ld	r30, X+
     ce8:	fc 91       	ld	r31, X
     cea:	13 97       	sbiw	r26, 0x03	; 3
     cec:	20 81       	ld	r18, Z
     cee:	31 81       	ldd	r19, Z+1	; 0x01
     cf0:	42 17       	cp	r20, r18
     cf2:	53 07       	cpc	r21, r19
     cf4:	b0 f7       	brcc	.-20     	; 0xce2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     cf6:	12 96       	adiw	r26, 0x02	; 2
     cf8:	ed 91       	ld	r30, X+
     cfa:	fc 91       	ld	r31, X
     cfc:	13 97       	sbiw	r26, 0x03	; 3
     cfe:	fb 83       	std	Y+3, r31	; 0x03
     d00:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     d02:	d5 83       	std	Z+5, r29	; 0x05
     d04:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     d06:	bd 83       	std	Y+5, r27	; 0x05
     d08:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     d0a:	13 96       	adiw	r26, 0x03	; 3
     d0c:	dc 93       	st	X, r29
     d0e:	ce 93       	st	-X, r28
     d10:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     d12:	99 87       	std	Y+9, r25	; 0x09
     d14:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     d16:	fc 01       	movw	r30, r24
     d18:	20 81       	ld	r18, Z
     d1a:	2f 5f       	subi	r18, 0xFF	; 255
     d1c:	20 83       	st	Z, r18
}
     d1e:	df 91       	pop	r29
     d20:	cf 91       	pop	r28
     d22:	08 95       	ret

00000d24 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     d24:	cf 93       	push	r28
     d26:	df 93       	push	r29
     d28:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     d2a:	a0 85       	ldd	r26, Z+8	; 0x08
     d2c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     d2e:	c2 81       	ldd	r28, Z+2	; 0x02
     d30:	d3 81       	ldd	r29, Z+3	; 0x03
     d32:	84 81       	ldd	r24, Z+4	; 0x04
     d34:	95 81       	ldd	r25, Z+5	; 0x05
     d36:	9d 83       	std	Y+5, r25	; 0x05
     d38:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     d3a:	c4 81       	ldd	r28, Z+4	; 0x04
     d3c:	d5 81       	ldd	r29, Z+5	; 0x05
     d3e:	82 81       	ldd	r24, Z+2	; 0x02
     d40:	93 81       	ldd	r25, Z+3	; 0x03
     d42:	9b 83       	std	Y+3, r25	; 0x03
     d44:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     d46:	11 96       	adiw	r26, 0x01	; 1
     d48:	8d 91       	ld	r24, X+
     d4a:	9c 91       	ld	r25, X
     d4c:	12 97       	sbiw	r26, 0x02	; 2
     d4e:	e8 17       	cp	r30, r24
     d50:	f9 07       	cpc	r31, r25
     d52:	31 f4       	brne	.+12     	; 0xd60 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     d54:	84 81       	ldd	r24, Z+4	; 0x04
     d56:	95 81       	ldd	r25, Z+5	; 0x05
     d58:	12 96       	adiw	r26, 0x02	; 2
     d5a:	9c 93       	st	X, r25
     d5c:	8e 93       	st	-X, r24
     d5e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     d60:	11 86       	std	Z+9, r1	; 0x09
     d62:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     d64:	8c 91       	ld	r24, X
     d66:	81 50       	subi	r24, 0x01	; 1
     d68:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     d6a:	df 91       	pop	r29
     d6c:	cf 91       	pop	r28
     d6e:	08 95       	ret

00000d70 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     d70:	1b bc       	out	0x2b, r1	; 43
     d72:	89 ef       	ldi	r24, 0xF9	; 249
     d74:	8a bd       	out	0x2a, r24	; 42
     d76:	8b e0       	ldi	r24, 0x0B	; 11
     d78:	8e bd       	out	0x2e, r24	; 46
     d7a:	89 b7       	in	r24, 0x39	; 57
     d7c:	80 61       	ori	r24, 0x10	; 16
     d7e:	89 bf       	out	0x39, r24	; 57
     d80:	08 95       	ret

00000d82 <pxPortInitialiseStack>:
     d82:	31 e1       	ldi	r19, 0x11	; 17
     d84:	fc 01       	movw	r30, r24
     d86:	30 83       	st	Z, r19
     d88:	31 97       	sbiw	r30, 0x01	; 1
     d8a:	22 e2       	ldi	r18, 0x22	; 34
     d8c:	20 83       	st	Z, r18
     d8e:	31 97       	sbiw	r30, 0x01	; 1
     d90:	a3 e3       	ldi	r26, 0x33	; 51
     d92:	a0 83       	st	Z, r26
     d94:	31 97       	sbiw	r30, 0x01	; 1
     d96:	60 83       	st	Z, r22
     d98:	31 97       	sbiw	r30, 0x01	; 1
     d9a:	70 83       	st	Z, r23
     d9c:	31 97       	sbiw	r30, 0x01	; 1
     d9e:	10 82       	st	Z, r1
     da0:	31 97       	sbiw	r30, 0x01	; 1
     da2:	60 e8       	ldi	r22, 0x80	; 128
     da4:	60 83       	st	Z, r22
     da6:	31 97       	sbiw	r30, 0x01	; 1
     da8:	10 82       	st	Z, r1
     daa:	31 97       	sbiw	r30, 0x01	; 1
     dac:	62 e0       	ldi	r22, 0x02	; 2
     dae:	60 83       	st	Z, r22
     db0:	31 97       	sbiw	r30, 0x01	; 1
     db2:	63 e0       	ldi	r22, 0x03	; 3
     db4:	60 83       	st	Z, r22
     db6:	31 97       	sbiw	r30, 0x01	; 1
     db8:	64 e0       	ldi	r22, 0x04	; 4
     dba:	60 83       	st	Z, r22
     dbc:	31 97       	sbiw	r30, 0x01	; 1
     dbe:	65 e0       	ldi	r22, 0x05	; 5
     dc0:	60 83       	st	Z, r22
     dc2:	31 97       	sbiw	r30, 0x01	; 1
     dc4:	66 e0       	ldi	r22, 0x06	; 6
     dc6:	60 83       	st	Z, r22
     dc8:	31 97       	sbiw	r30, 0x01	; 1
     dca:	67 e0       	ldi	r22, 0x07	; 7
     dcc:	60 83       	st	Z, r22
     dce:	31 97       	sbiw	r30, 0x01	; 1
     dd0:	68 e0       	ldi	r22, 0x08	; 8
     dd2:	60 83       	st	Z, r22
     dd4:	31 97       	sbiw	r30, 0x01	; 1
     dd6:	69 e0       	ldi	r22, 0x09	; 9
     dd8:	60 83       	st	Z, r22
     dda:	31 97       	sbiw	r30, 0x01	; 1
     ddc:	60 e1       	ldi	r22, 0x10	; 16
     dde:	60 83       	st	Z, r22
     de0:	31 97       	sbiw	r30, 0x01	; 1
     de2:	30 83       	st	Z, r19
     de4:	31 97       	sbiw	r30, 0x01	; 1
     de6:	32 e1       	ldi	r19, 0x12	; 18
     de8:	30 83       	st	Z, r19
     dea:	31 97       	sbiw	r30, 0x01	; 1
     dec:	33 e1       	ldi	r19, 0x13	; 19
     dee:	30 83       	st	Z, r19
     df0:	31 97       	sbiw	r30, 0x01	; 1
     df2:	34 e1       	ldi	r19, 0x14	; 20
     df4:	30 83       	st	Z, r19
     df6:	31 97       	sbiw	r30, 0x01	; 1
     df8:	35 e1       	ldi	r19, 0x15	; 21
     dfa:	30 83       	st	Z, r19
     dfc:	31 97       	sbiw	r30, 0x01	; 1
     dfe:	36 e1       	ldi	r19, 0x16	; 22
     e00:	30 83       	st	Z, r19
     e02:	31 97       	sbiw	r30, 0x01	; 1
     e04:	37 e1       	ldi	r19, 0x17	; 23
     e06:	30 83       	st	Z, r19
     e08:	31 97       	sbiw	r30, 0x01	; 1
     e0a:	38 e1       	ldi	r19, 0x18	; 24
     e0c:	30 83       	st	Z, r19
     e0e:	31 97       	sbiw	r30, 0x01	; 1
     e10:	39 e1       	ldi	r19, 0x19	; 25
     e12:	30 83       	st	Z, r19
     e14:	31 97       	sbiw	r30, 0x01	; 1
     e16:	30 e2       	ldi	r19, 0x20	; 32
     e18:	30 83       	st	Z, r19
     e1a:	31 97       	sbiw	r30, 0x01	; 1
     e1c:	31 e2       	ldi	r19, 0x21	; 33
     e1e:	30 83       	st	Z, r19
     e20:	31 97       	sbiw	r30, 0x01	; 1
     e22:	20 83       	st	Z, r18
     e24:	31 97       	sbiw	r30, 0x01	; 1
     e26:	23 e2       	ldi	r18, 0x23	; 35
     e28:	20 83       	st	Z, r18
     e2a:	31 97       	sbiw	r30, 0x01	; 1
     e2c:	40 83       	st	Z, r20
     e2e:	31 97       	sbiw	r30, 0x01	; 1
     e30:	50 83       	st	Z, r21
     e32:	31 97       	sbiw	r30, 0x01	; 1
     e34:	26 e2       	ldi	r18, 0x26	; 38
     e36:	20 83       	st	Z, r18
     e38:	31 97       	sbiw	r30, 0x01	; 1
     e3a:	27 e2       	ldi	r18, 0x27	; 39
     e3c:	20 83       	st	Z, r18
     e3e:	31 97       	sbiw	r30, 0x01	; 1
     e40:	28 e2       	ldi	r18, 0x28	; 40
     e42:	20 83       	st	Z, r18
     e44:	31 97       	sbiw	r30, 0x01	; 1
     e46:	29 e2       	ldi	r18, 0x29	; 41
     e48:	20 83       	st	Z, r18
     e4a:	31 97       	sbiw	r30, 0x01	; 1
     e4c:	20 e3       	ldi	r18, 0x30	; 48
     e4e:	20 83       	st	Z, r18
     e50:	31 97       	sbiw	r30, 0x01	; 1
     e52:	21 e3       	ldi	r18, 0x31	; 49
     e54:	20 83       	st	Z, r18
     e56:	86 97       	sbiw	r24, 0x26	; 38
     e58:	08 95       	ret

00000e5a <xPortStartScheduler>:
     e5a:	0e 94 b8 06 	call	0xd70	; 0xd70 <prvSetupTimerInterrupt>
     e5e:	a0 91 02 01 	lds	r26, 0x0102	; 0x800102 <pxCurrentTCB>
     e62:	b0 91 03 01 	lds	r27, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
     e66:	cd 91       	ld	r28, X+
     e68:	cd bf       	out	0x3d, r28	; 61
     e6a:	dd 91       	ld	r29, X+
     e6c:	de bf       	out	0x3e, r29	; 62
     e6e:	ff 91       	pop	r31
     e70:	ef 91       	pop	r30
     e72:	df 91       	pop	r29
     e74:	cf 91       	pop	r28
     e76:	bf 91       	pop	r27
     e78:	af 91       	pop	r26
     e7a:	9f 91       	pop	r25
     e7c:	8f 91       	pop	r24
     e7e:	7f 91       	pop	r23
     e80:	6f 91       	pop	r22
     e82:	5f 91       	pop	r21
     e84:	4f 91       	pop	r20
     e86:	3f 91       	pop	r19
     e88:	2f 91       	pop	r18
     e8a:	1f 91       	pop	r17
     e8c:	0f 91       	pop	r16
     e8e:	ff 90       	pop	r15
     e90:	ef 90       	pop	r14
     e92:	df 90       	pop	r13
     e94:	cf 90       	pop	r12
     e96:	bf 90       	pop	r11
     e98:	af 90       	pop	r10
     e9a:	9f 90       	pop	r9
     e9c:	8f 90       	pop	r8
     e9e:	7f 90       	pop	r7
     ea0:	6f 90       	pop	r6
     ea2:	5f 90       	pop	r5
     ea4:	4f 90       	pop	r4
     ea6:	3f 90       	pop	r3
     ea8:	2f 90       	pop	r2
     eaa:	1f 90       	pop	r1
     eac:	0f 90       	pop	r0
     eae:	0f be       	out	0x3f, r0	; 63
     eb0:	0f 90       	pop	r0
     eb2:	08 95       	ret
     eb4:	81 e0       	ldi	r24, 0x01	; 1
     eb6:	08 95       	ret

00000eb8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     eb8:	0f 92       	push	r0
     eba:	0f b6       	in	r0, 0x3f	; 63
     ebc:	f8 94       	cli
     ebe:	0f 92       	push	r0
     ec0:	1f 92       	push	r1
     ec2:	11 24       	eor	r1, r1
     ec4:	2f 92       	push	r2
     ec6:	3f 92       	push	r3
     ec8:	4f 92       	push	r4
     eca:	5f 92       	push	r5
     ecc:	6f 92       	push	r6
     ece:	7f 92       	push	r7
     ed0:	8f 92       	push	r8
     ed2:	9f 92       	push	r9
     ed4:	af 92       	push	r10
     ed6:	bf 92       	push	r11
     ed8:	cf 92       	push	r12
     eda:	df 92       	push	r13
     edc:	ef 92       	push	r14
     ede:	ff 92       	push	r15
     ee0:	0f 93       	push	r16
     ee2:	1f 93       	push	r17
     ee4:	2f 93       	push	r18
     ee6:	3f 93       	push	r19
     ee8:	4f 93       	push	r20
     eea:	5f 93       	push	r21
     eec:	6f 93       	push	r22
     eee:	7f 93       	push	r23
     ef0:	8f 93       	push	r24
     ef2:	9f 93       	push	r25
     ef4:	af 93       	push	r26
     ef6:	bf 93       	push	r27
     ef8:	cf 93       	push	r28
     efa:	df 93       	push	r29
     efc:	ef 93       	push	r30
     efe:	ff 93       	push	r31
     f00:	a0 91 02 01 	lds	r26, 0x0102	; 0x800102 <pxCurrentTCB>
     f04:	b0 91 03 01 	lds	r27, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
     f08:	0d b6       	in	r0, 0x3d	; 61
     f0a:	0d 92       	st	X+, r0
     f0c:	0e b6       	in	r0, 0x3e	; 62
     f0e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     f10:	0e 94 c0 0e 	call	0x1d80	; 0x1d80 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     f14:	a0 91 02 01 	lds	r26, 0x0102	; 0x800102 <pxCurrentTCB>
     f18:	b0 91 03 01 	lds	r27, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
     f1c:	cd 91       	ld	r28, X+
     f1e:	cd bf       	out	0x3d, r28	; 61
     f20:	dd 91       	ld	r29, X+
     f22:	de bf       	out	0x3e, r29	; 62
     f24:	ff 91       	pop	r31
     f26:	ef 91       	pop	r30
     f28:	df 91       	pop	r29
     f2a:	cf 91       	pop	r28
     f2c:	bf 91       	pop	r27
     f2e:	af 91       	pop	r26
     f30:	9f 91       	pop	r25
     f32:	8f 91       	pop	r24
     f34:	7f 91       	pop	r23
     f36:	6f 91       	pop	r22
     f38:	5f 91       	pop	r21
     f3a:	4f 91       	pop	r20
     f3c:	3f 91       	pop	r19
     f3e:	2f 91       	pop	r18
     f40:	1f 91       	pop	r17
     f42:	0f 91       	pop	r16
     f44:	ff 90       	pop	r15
     f46:	ef 90       	pop	r14
     f48:	df 90       	pop	r13
     f4a:	cf 90       	pop	r12
     f4c:	bf 90       	pop	r11
     f4e:	af 90       	pop	r10
     f50:	9f 90       	pop	r9
     f52:	8f 90       	pop	r8
     f54:	7f 90       	pop	r7
     f56:	6f 90       	pop	r6
     f58:	5f 90       	pop	r5
     f5a:	4f 90       	pop	r4
     f5c:	3f 90       	pop	r3
     f5e:	2f 90       	pop	r2
     f60:	1f 90       	pop	r1
     f62:	0f 90       	pop	r0
     f64:	0f be       	out	0x3f, r0	; 63
     f66:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f68:	08 95       	ret

00000f6a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     f6a:	0f 92       	push	r0
     f6c:	0f b6       	in	r0, 0x3f	; 63
     f6e:	f8 94       	cli
     f70:	0f 92       	push	r0
     f72:	1f 92       	push	r1
     f74:	11 24       	eor	r1, r1
     f76:	2f 92       	push	r2
     f78:	3f 92       	push	r3
     f7a:	4f 92       	push	r4
     f7c:	5f 92       	push	r5
     f7e:	6f 92       	push	r6
     f80:	7f 92       	push	r7
     f82:	8f 92       	push	r8
     f84:	9f 92       	push	r9
     f86:	af 92       	push	r10
     f88:	bf 92       	push	r11
     f8a:	cf 92       	push	r12
     f8c:	df 92       	push	r13
     f8e:	ef 92       	push	r14
     f90:	ff 92       	push	r15
     f92:	0f 93       	push	r16
     f94:	1f 93       	push	r17
     f96:	2f 93       	push	r18
     f98:	3f 93       	push	r19
     f9a:	4f 93       	push	r20
     f9c:	5f 93       	push	r21
     f9e:	6f 93       	push	r22
     fa0:	7f 93       	push	r23
     fa2:	8f 93       	push	r24
     fa4:	9f 93       	push	r25
     fa6:	af 93       	push	r26
     fa8:	bf 93       	push	r27
     faa:	cf 93       	push	r28
     fac:	df 93       	push	r29
     fae:	ef 93       	push	r30
     fb0:	ff 93       	push	r31
     fb2:	a0 91 02 01 	lds	r26, 0x0102	; 0x800102 <pxCurrentTCB>
     fb6:	b0 91 03 01 	lds	r27, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
     fba:	0d b6       	in	r0, 0x3d	; 61
     fbc:	0d 92       	st	X+, r0
     fbe:	0e b6       	in	r0, 0x3e	; 62
     fc0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     fc2:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xTaskIncrementTick>
     fc6:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     fc8:	0e 94 c0 0e 	call	0x1d80	; 0x1d80 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     fcc:	a0 91 02 01 	lds	r26, 0x0102	; 0x800102 <pxCurrentTCB>
     fd0:	b0 91 03 01 	lds	r27, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
     fd4:	cd 91       	ld	r28, X+
     fd6:	cd bf       	out	0x3d, r28	; 61
     fd8:	dd 91       	ld	r29, X+
     fda:	de bf       	out	0x3e, r29	; 62
     fdc:	ff 91       	pop	r31
     fde:	ef 91       	pop	r30
     fe0:	df 91       	pop	r29
     fe2:	cf 91       	pop	r28
     fe4:	bf 91       	pop	r27
     fe6:	af 91       	pop	r26
     fe8:	9f 91       	pop	r25
     fea:	8f 91       	pop	r24
     fec:	7f 91       	pop	r23
     fee:	6f 91       	pop	r22
     ff0:	5f 91       	pop	r21
     ff2:	4f 91       	pop	r20
     ff4:	3f 91       	pop	r19
     ff6:	2f 91       	pop	r18
     ff8:	1f 91       	pop	r17
     ffa:	0f 91       	pop	r16
     ffc:	ff 90       	pop	r15
     ffe:	ef 90       	pop	r14
    1000:	df 90       	pop	r13
    1002:	cf 90       	pop	r12
    1004:	bf 90       	pop	r11
    1006:	af 90       	pop	r10
    1008:	9f 90       	pop	r9
    100a:	8f 90       	pop	r8
    100c:	7f 90       	pop	r7
    100e:	6f 90       	pop	r6
    1010:	5f 90       	pop	r5
    1012:	4f 90       	pop	r4
    1014:	3f 90       	pop	r3
    1016:	2f 90       	pop	r2
    1018:	1f 90       	pop	r1
    101a:	0f 90       	pop	r0
    101c:	0f be       	out	0x3f, r0	; 63
    101e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1020:	08 95       	ret

00001022 <__vector_7>:
	 * DeeThe: Changed from SIG_OUTPUT_COMPARE1A to TIMER1_COMPA_vect
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1022:	0e 94 b5 07 	call	0xf6a	; 0xf6a <vPortYieldFromTick>
		asm volatile ( "reti" );
    1026:	18 95       	reti

00001028 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1028:	cf 93       	push	r28
    102a:	df 93       	push	r29
    102c:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    102e:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    1032:	ce 01       	movw	r24, r28
    1034:	0e 94 04 11 	call	0x2208	; 0x2208 <malloc>
    1038:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    103a:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    103e:	ce 01       	movw	r24, r28
    1040:	df 91       	pop	r29
    1042:	cf 91       	pop	r28
    1044:	08 95       	ret

00001046 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1046:	cf 93       	push	r28
    1048:	df 93       	push	r29
	if( pv )
    104a:	00 97       	sbiw	r24, 0x00	; 0
    104c:	41 f0       	breq	.+16     	; 0x105e <vPortFree+0x18>
    104e:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    1050:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <vTaskSuspendAll>
		{
			free( pv );
    1054:	ce 01       	movw	r24, r28
    1056:	0e 94 9c 11 	call	0x2338	; 0x2338 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    105a:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <xTaskResumeAll>
	}
}
    105e:	df 91       	pop	r29
    1060:	cf 91       	pop	r28
    1062:	08 95       	ret

00001064 <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1064:	0f b6       	in	r0, 0x3f	; 63
    1066:	f8 94       	cli
    1068:	0f 92       	push	r0
    106a:	fc 01       	movw	r30, r24
    106c:	82 8d       	ldd	r24, Z+26	; 0x1a
    106e:	81 11       	cpse	r24, r1
    1070:	02 c0       	rjmp	.+4      	; 0x1076 <prvIsQueueEmpty+0x12>
    1072:	81 e0       	ldi	r24, 0x01	; 1
    1074:	01 c0       	rjmp	.+2      	; 0x1078 <prvIsQueueEmpty+0x14>
    1076:	80 e0       	ldi	r24, 0x00	; 0
    1078:	0f 90       	pop	r0
    107a:	0f be       	out	0x3f, r0	; 63
    107c:	08 95       	ret

0000107e <prvIsQueueFull>:
    107e:	0f b6       	in	r0, 0x3f	; 63
    1080:	f8 94       	cli
    1082:	0f 92       	push	r0
    1084:	fc 01       	movw	r30, r24
    1086:	22 8d       	ldd	r18, Z+26	; 0x1a
    1088:	83 8d       	ldd	r24, Z+27	; 0x1b
    108a:	28 13       	cpse	r18, r24
    108c:	02 c0       	rjmp	.+4      	; 0x1092 <prvIsQueueFull+0x14>
    108e:	81 e0       	ldi	r24, 0x01	; 1
    1090:	01 c0       	rjmp	.+2      	; 0x1094 <prvIsQueueFull+0x16>
    1092:	80 e0       	ldi	r24, 0x00	; 0
    1094:	0f 90       	pop	r0
    1096:	0f be       	out	0x3f, r0	; 63
    1098:	08 95       	ret

0000109a <prvCopyDataToQueue>:
    109a:	0f 93       	push	r16
    109c:	1f 93       	push	r17
    109e:	cf 93       	push	r28
    10a0:	df 93       	push	r29
    10a2:	ec 01       	movw	r28, r24
    10a4:	04 2f       	mov	r16, r20
    10a6:	1a 8d       	ldd	r17, Y+26	; 0x1a
    10a8:	4c 8d       	ldd	r20, Y+28	; 0x1c
    10aa:	41 11       	cpse	r20, r1
    10ac:	0c c0       	rjmp	.+24     	; 0x10c6 <prvCopyDataToQueue+0x2c>
    10ae:	88 81       	ld	r24, Y
    10b0:	99 81       	ldd	r25, Y+1	; 0x01
    10b2:	89 2b       	or	r24, r25
    10b4:	09 f0       	breq	.+2      	; 0x10b8 <prvCopyDataToQueue+0x1e>
    10b6:	42 c0       	rjmp	.+132    	; 0x113c <prvCopyDataToQueue+0xa2>
    10b8:	8a 81       	ldd	r24, Y+2	; 0x02
    10ba:	9b 81       	ldd	r25, Y+3	; 0x03
    10bc:	0e 94 66 10 	call	0x20cc	; 0x20cc <xTaskPriorityDisinherit>
    10c0:	1b 82       	std	Y+3, r1	; 0x03
    10c2:	1a 82       	std	Y+2, r1	; 0x02
    10c4:	42 c0       	rjmp	.+132    	; 0x114a <prvCopyDataToQueue+0xb0>
    10c6:	01 11       	cpse	r16, r1
    10c8:	17 c0       	rjmp	.+46     	; 0x10f8 <prvCopyDataToQueue+0x5e>
    10ca:	50 e0       	ldi	r21, 0x00	; 0
    10cc:	8c 81       	ldd	r24, Y+4	; 0x04
    10ce:	9d 81       	ldd	r25, Y+5	; 0x05
    10d0:	0e 94 25 12 	call	0x244a	; 0x244a <memcpy>
    10d4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    10d6:	8c 81       	ldd	r24, Y+4	; 0x04
    10d8:	9d 81       	ldd	r25, Y+5	; 0x05
    10da:	82 0f       	add	r24, r18
    10dc:	91 1d       	adc	r25, r1
    10de:	9d 83       	std	Y+5, r25	; 0x05
    10e0:	8c 83       	std	Y+4, r24	; 0x04
    10e2:	2a 81       	ldd	r18, Y+2	; 0x02
    10e4:	3b 81       	ldd	r19, Y+3	; 0x03
    10e6:	82 17       	cp	r24, r18
    10e8:	93 07       	cpc	r25, r19
    10ea:	50 f1       	brcs	.+84     	; 0x1140 <prvCopyDataToQueue+0xa6>
    10ec:	88 81       	ld	r24, Y
    10ee:	99 81       	ldd	r25, Y+1	; 0x01
    10f0:	9d 83       	std	Y+5, r25	; 0x05
    10f2:	8c 83       	std	Y+4, r24	; 0x04
    10f4:	80 e0       	ldi	r24, 0x00	; 0
    10f6:	29 c0       	rjmp	.+82     	; 0x114a <prvCopyDataToQueue+0xb0>
    10f8:	50 e0       	ldi	r21, 0x00	; 0
    10fa:	8e 81       	ldd	r24, Y+6	; 0x06
    10fc:	9f 81       	ldd	r25, Y+7	; 0x07
    10fe:	0e 94 25 12 	call	0x244a	; 0x244a <memcpy>
    1102:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1104:	90 e0       	ldi	r25, 0x00	; 0
    1106:	91 95       	neg	r25
    1108:	81 95       	neg	r24
    110a:	91 09       	sbc	r25, r1
    110c:	2e 81       	ldd	r18, Y+6	; 0x06
    110e:	3f 81       	ldd	r19, Y+7	; 0x07
    1110:	28 0f       	add	r18, r24
    1112:	39 1f       	adc	r19, r25
    1114:	3f 83       	std	Y+7, r19	; 0x07
    1116:	2e 83       	std	Y+6, r18	; 0x06
    1118:	48 81       	ld	r20, Y
    111a:	59 81       	ldd	r21, Y+1	; 0x01
    111c:	24 17       	cp	r18, r20
    111e:	35 07       	cpc	r19, r21
    1120:	30 f4       	brcc	.+12     	; 0x112e <prvCopyDataToQueue+0x94>
    1122:	2a 81       	ldd	r18, Y+2	; 0x02
    1124:	3b 81       	ldd	r19, Y+3	; 0x03
    1126:	82 0f       	add	r24, r18
    1128:	93 1f       	adc	r25, r19
    112a:	9f 83       	std	Y+7, r25	; 0x07
    112c:	8e 83       	std	Y+6, r24	; 0x06
    112e:	02 30       	cpi	r16, 0x02	; 2
    1130:	49 f4       	brne	.+18     	; 0x1144 <prvCopyDataToQueue+0xaa>
    1132:	11 23       	and	r17, r17
    1134:	49 f0       	breq	.+18     	; 0x1148 <prvCopyDataToQueue+0xae>
    1136:	11 50       	subi	r17, 0x01	; 1
    1138:	80 e0       	ldi	r24, 0x00	; 0
    113a:	07 c0       	rjmp	.+14     	; 0x114a <prvCopyDataToQueue+0xb0>
    113c:	80 e0       	ldi	r24, 0x00	; 0
    113e:	05 c0       	rjmp	.+10     	; 0x114a <prvCopyDataToQueue+0xb0>
    1140:	80 e0       	ldi	r24, 0x00	; 0
    1142:	03 c0       	rjmp	.+6      	; 0x114a <prvCopyDataToQueue+0xb0>
    1144:	80 e0       	ldi	r24, 0x00	; 0
    1146:	01 c0       	rjmp	.+2      	; 0x114a <prvCopyDataToQueue+0xb0>
    1148:	80 e0       	ldi	r24, 0x00	; 0
    114a:	1f 5f       	subi	r17, 0xFF	; 255
    114c:	1a 8f       	std	Y+26, r17	; 0x1a
    114e:	df 91       	pop	r29
    1150:	cf 91       	pop	r28
    1152:	1f 91       	pop	r17
    1154:	0f 91       	pop	r16
    1156:	08 95       	ret

00001158 <prvCopyDataFromQueue>:
    1158:	fc 01       	movw	r30, r24
    115a:	44 8d       	ldd	r20, Z+28	; 0x1c
    115c:	44 23       	and	r20, r20
    115e:	a9 f0       	breq	.+42     	; 0x118a <prvCopyDataFromQueue+0x32>
    1160:	50 e0       	ldi	r21, 0x00	; 0
    1162:	26 81       	ldd	r18, Z+6	; 0x06
    1164:	37 81       	ldd	r19, Z+7	; 0x07
    1166:	24 0f       	add	r18, r20
    1168:	35 1f       	adc	r19, r21
    116a:	37 83       	std	Z+7, r19	; 0x07
    116c:	26 83       	std	Z+6, r18	; 0x06
    116e:	82 81       	ldd	r24, Z+2	; 0x02
    1170:	93 81       	ldd	r25, Z+3	; 0x03
    1172:	28 17       	cp	r18, r24
    1174:	39 07       	cpc	r19, r25
    1176:	20 f0       	brcs	.+8      	; 0x1180 <prvCopyDataFromQueue+0x28>
    1178:	80 81       	ld	r24, Z
    117a:	91 81       	ldd	r25, Z+1	; 0x01
    117c:	97 83       	std	Z+7, r25	; 0x07
    117e:	86 83       	std	Z+6, r24	; 0x06
    1180:	cb 01       	movw	r24, r22
    1182:	66 81       	ldd	r22, Z+6	; 0x06
    1184:	77 81       	ldd	r23, Z+7	; 0x07
    1186:	0e 94 25 12 	call	0x244a	; 0x244a <memcpy>
    118a:	08 95       	ret

0000118c <prvUnlockQueue>:
    118c:	1f 93       	push	r17
    118e:	cf 93       	push	r28
    1190:	df 93       	push	r29
    1192:	ec 01       	movw	r28, r24
    1194:	0f b6       	in	r0, 0x3f	; 63
    1196:	f8 94       	cli
    1198:	0f 92       	push	r0
    119a:	1e 8d       	ldd	r17, Y+30	; 0x1e
    119c:	0b c0       	rjmp	.+22     	; 0x11b4 <prvUnlockQueue+0x28>
    119e:	89 89       	ldd	r24, Y+17	; 0x11
    11a0:	88 23       	and	r24, r24
    11a2:	51 f0       	breq	.+20     	; 0x11b8 <prvUnlockQueue+0x2c>
    11a4:	ce 01       	movw	r24, r28
    11a6:	41 96       	adiw	r24, 0x11	; 17
    11a8:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <xTaskRemoveFromEventList>
    11ac:	81 11       	cpse	r24, r1
    11ae:	0e 94 00 10 	call	0x2000	; 0x2000 <vTaskMissedYield>
    11b2:	11 50       	subi	r17, 0x01	; 1
    11b4:	11 16       	cp	r1, r17
    11b6:	9c f3       	brlt	.-26     	; 0x119e <prvUnlockQueue+0x12>
    11b8:	8f ef       	ldi	r24, 0xFF	; 255
    11ba:	8e 8f       	std	Y+30, r24	; 0x1e
    11bc:	0f 90       	pop	r0
    11be:	0f be       	out	0x3f, r0	; 63
    11c0:	0f b6       	in	r0, 0x3f	; 63
    11c2:	f8 94       	cli
    11c4:	0f 92       	push	r0
    11c6:	1d 8d       	ldd	r17, Y+29	; 0x1d
    11c8:	0b c0       	rjmp	.+22     	; 0x11e0 <prvUnlockQueue+0x54>
    11ca:	88 85       	ldd	r24, Y+8	; 0x08
    11cc:	88 23       	and	r24, r24
    11ce:	51 f0       	breq	.+20     	; 0x11e4 <prvUnlockQueue+0x58>
    11d0:	ce 01       	movw	r24, r28
    11d2:	08 96       	adiw	r24, 0x08	; 8
    11d4:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <xTaskRemoveFromEventList>
    11d8:	81 11       	cpse	r24, r1
    11da:	0e 94 00 10 	call	0x2000	; 0x2000 <vTaskMissedYield>
    11de:	11 50       	subi	r17, 0x01	; 1
    11e0:	11 16       	cp	r1, r17
    11e2:	9c f3       	brlt	.-26     	; 0x11ca <prvUnlockQueue+0x3e>
    11e4:	8f ef       	ldi	r24, 0xFF	; 255
    11e6:	8d 8f       	std	Y+29, r24	; 0x1d
    11e8:	0f 90       	pop	r0
    11ea:	0f be       	out	0x3f, r0	; 63
    11ec:	df 91       	pop	r29
    11ee:	cf 91       	pop	r28
    11f0:	1f 91       	pop	r17
    11f2:	08 95       	ret

000011f4 <xQueueGenericReset>:
    11f4:	cf 93       	push	r28
    11f6:	df 93       	push	r29
    11f8:	ec 01       	movw	r28, r24
    11fa:	0f b6       	in	r0, 0x3f	; 63
    11fc:	f8 94       	cli
    11fe:	0f 92       	push	r0
    1200:	e8 81       	ld	r30, Y
    1202:	f9 81       	ldd	r31, Y+1	; 0x01
    1204:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1206:	90 e0       	ldi	r25, 0x00	; 0
    1208:	2c 8d       	ldd	r18, Y+28	; 0x1c
    120a:	30 e0       	ldi	r19, 0x00	; 0
    120c:	82 9f       	mul	r24, r18
    120e:	a0 01       	movw	r20, r0
    1210:	83 9f       	mul	r24, r19
    1212:	50 0d       	add	r21, r0
    1214:	92 9f       	mul	r25, r18
    1216:	50 0d       	add	r21, r0
    1218:	11 24       	eor	r1, r1
    121a:	4e 0f       	add	r20, r30
    121c:	5f 1f       	adc	r21, r31
    121e:	5b 83       	std	Y+3, r21	; 0x03
    1220:	4a 83       	std	Y+2, r20	; 0x02
    1222:	1a 8e       	std	Y+26, r1	; 0x1a
    1224:	fd 83       	std	Y+5, r31	; 0x05
    1226:	ec 83       	std	Y+4, r30	; 0x04
    1228:	01 97       	sbiw	r24, 0x01	; 1
    122a:	28 9f       	mul	r18, r24
    122c:	a0 01       	movw	r20, r0
    122e:	29 9f       	mul	r18, r25
    1230:	50 0d       	add	r21, r0
    1232:	38 9f       	mul	r19, r24
    1234:	50 0d       	add	r21, r0
    1236:	11 24       	eor	r1, r1
    1238:	cf 01       	movw	r24, r30
    123a:	84 0f       	add	r24, r20
    123c:	95 1f       	adc	r25, r21
    123e:	9f 83       	std	Y+7, r25	; 0x07
    1240:	8e 83       	std	Y+6, r24	; 0x06
    1242:	8f ef       	ldi	r24, 0xFF	; 255
    1244:	8d 8f       	std	Y+29, r24	; 0x1d
    1246:	8e 8f       	std	Y+30, r24	; 0x1e
    1248:	61 11       	cpse	r22, r1
    124a:	0c c0       	rjmp	.+24     	; 0x1264 <xQueueGenericReset+0x70>
    124c:	88 85       	ldd	r24, Y+8	; 0x08
    124e:	88 23       	and	r24, r24
    1250:	89 f0       	breq	.+34     	; 0x1274 <xQueueGenericReset+0x80>
    1252:	ce 01       	movw	r24, r28
    1254:	08 96       	adiw	r24, 0x08	; 8
    1256:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <xTaskRemoveFromEventList>
    125a:	88 23       	and	r24, r24
    125c:	59 f0       	breq	.+22     	; 0x1274 <xQueueGenericReset+0x80>
    125e:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vPortYield>
    1262:	08 c0       	rjmp	.+16     	; 0x1274 <xQueueGenericReset+0x80>
    1264:	ce 01       	movw	r24, r28
    1266:	08 96       	adiw	r24, 0x08	; 8
    1268:	0e 94 2e 06 	call	0xc5c	; 0xc5c <vListInitialise>
    126c:	ce 01       	movw	r24, r28
    126e:	41 96       	adiw	r24, 0x11	; 17
    1270:	0e 94 2e 06 	call	0xc5c	; 0xc5c <vListInitialise>
    1274:	0f 90       	pop	r0
    1276:	0f be       	out	0x3f, r0	; 63
    1278:	81 e0       	ldi	r24, 0x01	; 1
    127a:	df 91       	pop	r29
    127c:	cf 91       	pop	r28
    127e:	08 95       	ret

00001280 <prvInitialiseNewQueue>:
    1280:	0f 93       	push	r16
    1282:	1f 93       	push	r17
    1284:	f8 01       	movw	r30, r16
    1286:	61 11       	cpse	r22, r1
    1288:	03 c0       	rjmp	.+6      	; 0x1290 <prvInitialiseNewQueue+0x10>
    128a:	11 83       	std	Z+1, r17	; 0x01
    128c:	00 83       	st	Z, r16
    128e:	02 c0       	rjmp	.+4      	; 0x1294 <prvInitialiseNewQueue+0x14>
    1290:	51 83       	std	Z+1, r21	; 0x01
    1292:	40 83       	st	Z, r20
    1294:	83 8f       	std	Z+27, r24	; 0x1b
    1296:	64 8f       	std	Z+28, r22	; 0x1c
    1298:	61 e0       	ldi	r22, 0x01	; 1
    129a:	cf 01       	movw	r24, r30
    129c:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <xQueueGenericReset>
    12a0:	1f 91       	pop	r17
    12a2:	0f 91       	pop	r16
    12a4:	08 95       	ret

000012a6 <xQueueGenericCreate>:
    12a6:	df 92       	push	r13
    12a8:	ef 92       	push	r14
    12aa:	ff 92       	push	r15
    12ac:	0f 93       	push	r16
    12ae:	1f 93       	push	r17
    12b0:	cf 93       	push	r28
    12b2:	df 93       	push	r29
    12b4:	e8 2e       	mov	r14, r24
    12b6:	f6 2e       	mov	r15, r22
    12b8:	d4 2e       	mov	r13, r20
    12ba:	66 23       	and	r22, r22
    12bc:	21 f0       	breq	.+8      	; 0x12c6 <xQueueGenericCreate+0x20>
    12be:	86 9f       	mul	r24, r22
    12c0:	c0 01       	movw	r24, r0
    12c2:	11 24       	eor	r1, r1
    12c4:	02 c0       	rjmp	.+4      	; 0x12ca <xQueueGenericCreate+0x24>
    12c6:	80 e0       	ldi	r24, 0x00	; 0
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	4f 96       	adiw	r24, 0x1f	; 31
    12cc:	0e 94 14 08 	call	0x1028	; 0x1028 <pvPortMalloc>
    12d0:	ec 01       	movw	r28, r24
    12d2:	00 97       	sbiw	r24, 0x00	; 0
    12d4:	49 f0       	breq	.+18     	; 0x12e8 <xQueueGenericCreate+0x42>
    12d6:	8c 01       	movw	r16, r24
    12d8:	2d 2d       	mov	r18, r13
    12da:	ac 01       	movw	r20, r24
    12dc:	41 5e       	subi	r20, 0xE1	; 225
    12de:	5f 4f       	sbci	r21, 0xFF	; 255
    12e0:	6f 2d       	mov	r22, r15
    12e2:	8e 2d       	mov	r24, r14
    12e4:	0e 94 40 09 	call	0x1280	; 0x1280 <prvInitialiseNewQueue>
    12e8:	ce 01       	movw	r24, r28
    12ea:	df 91       	pop	r29
    12ec:	cf 91       	pop	r28
    12ee:	1f 91       	pop	r17
    12f0:	0f 91       	pop	r16
    12f2:	ff 90       	pop	r15
    12f4:	ef 90       	pop	r14
    12f6:	df 90       	pop	r13
    12f8:	08 95       	ret

000012fa <xQueueGenericSend>:
    12fa:	cf 92       	push	r12
    12fc:	df 92       	push	r13
    12fe:	ef 92       	push	r14
    1300:	ff 92       	push	r15
    1302:	0f 93       	push	r16
    1304:	1f 93       	push	r17
    1306:	cf 93       	push	r28
    1308:	df 93       	push	r29
    130a:	00 d0       	rcall	.+0      	; 0x130c <xQueueGenericSend+0x12>
    130c:	00 d0       	rcall	.+0      	; 0x130e <xQueueGenericSend+0x14>
    130e:	1f 92       	push	r1
    1310:	cd b7       	in	r28, 0x3d	; 61
    1312:	de b7       	in	r29, 0x3e	; 62
    1314:	8c 01       	movw	r16, r24
    1316:	7b 01       	movw	r14, r22
    1318:	5d 83       	std	Y+5, r21	; 0x05
    131a:	4c 83       	std	Y+4, r20	; 0x04
    131c:	c2 2e       	mov	r12, r18
    131e:	d1 2c       	mov	r13, r1
    1320:	0f b6       	in	r0, 0x3f	; 63
    1322:	f8 94       	cli
    1324:	0f 92       	push	r0
    1326:	f8 01       	movw	r30, r16
    1328:	92 8d       	ldd	r25, Z+26	; 0x1a
    132a:	83 8d       	ldd	r24, Z+27	; 0x1b
    132c:	98 17       	cp	r25, r24
    132e:	18 f0       	brcs	.+6      	; 0x1336 <xQueueGenericSend+0x3c>
    1330:	f2 e0       	ldi	r31, 0x02	; 2
    1332:	cf 12       	cpse	r12, r31
    1334:	19 c0       	rjmp	.+50     	; 0x1368 <xQueueGenericSend+0x6e>
    1336:	4c 2d       	mov	r20, r12
    1338:	b7 01       	movw	r22, r14
    133a:	c8 01       	movw	r24, r16
    133c:	0e 94 4d 08 	call	0x109a	; 0x109a <prvCopyDataToQueue>
    1340:	f8 01       	movw	r30, r16
    1342:	91 89       	ldd	r25, Z+17	; 0x11
    1344:	99 23       	and	r25, r25
    1346:	49 f0       	breq	.+18     	; 0x135a <xQueueGenericSend+0x60>
    1348:	c8 01       	movw	r24, r16
    134a:	41 96       	adiw	r24, 0x11	; 17
    134c:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <xTaskRemoveFromEventList>
    1350:	88 23       	and	r24, r24
    1352:	31 f0       	breq	.+12     	; 0x1360 <xQueueGenericSend+0x66>
    1354:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vPortYield>
    1358:	03 c0       	rjmp	.+6      	; 0x1360 <xQueueGenericSend+0x66>
    135a:	81 11       	cpse	r24, r1
    135c:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vPortYield>
    1360:	0f 90       	pop	r0
    1362:	0f be       	out	0x3f, r0	; 63
    1364:	81 e0       	ldi	r24, 0x01	; 1
    1366:	4d c0       	rjmp	.+154    	; 0x1402 <xQueueGenericSend+0x108>
    1368:	8c 81       	ldd	r24, Y+4	; 0x04
    136a:	9d 81       	ldd	r25, Y+5	; 0x05
    136c:	89 2b       	or	r24, r25
    136e:	21 f4       	brne	.+8      	; 0x1378 <xQueueGenericSend+0x7e>
    1370:	0f 90       	pop	r0
    1372:	0f be       	out	0x3f, r0	; 63
    1374:	80 e0       	ldi	r24, 0x00	; 0
    1376:	45 c0       	rjmp	.+138    	; 0x1402 <xQueueGenericSend+0x108>
    1378:	d1 10       	cpse	r13, r1
    137a:	06 c0       	rjmp	.+12     	; 0x1388 <xQueueGenericSend+0x8e>
    137c:	ce 01       	movw	r24, r28
    137e:	01 96       	adiw	r24, 0x01	; 1
    1380:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <vTaskSetTimeOutState>
    1384:	dd 24       	eor	r13, r13
    1386:	d3 94       	inc	r13
    1388:	0f 90       	pop	r0
    138a:	0f be       	out	0x3f, r0	; 63
    138c:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <vTaskSuspendAll>
    1390:	0f b6       	in	r0, 0x3f	; 63
    1392:	f8 94       	cli
    1394:	0f 92       	push	r0
    1396:	f8 01       	movw	r30, r16
    1398:	85 8d       	ldd	r24, Z+29	; 0x1d
    139a:	8f 3f       	cpi	r24, 0xFF	; 255
    139c:	09 f4       	brne	.+2      	; 0x13a0 <xQueueGenericSend+0xa6>
    139e:	15 8e       	std	Z+29, r1	; 0x1d
    13a0:	f8 01       	movw	r30, r16
    13a2:	86 8d       	ldd	r24, Z+30	; 0x1e
    13a4:	8f 3f       	cpi	r24, 0xFF	; 255
    13a6:	09 f4       	brne	.+2      	; 0x13aa <xQueueGenericSend+0xb0>
    13a8:	16 8e       	std	Z+30, r1	; 0x1e
    13aa:	0f 90       	pop	r0
    13ac:	0f be       	out	0x3f, r0	; 63
    13ae:	be 01       	movw	r22, r28
    13b0:	6c 5f       	subi	r22, 0xFC	; 252
    13b2:	7f 4f       	sbci	r23, 0xFF	; 255
    13b4:	ce 01       	movw	r24, r28
    13b6:	01 96       	adiw	r24, 0x01	; 1
    13b8:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <xTaskCheckForTimeOut>
    13bc:	81 11       	cpse	r24, r1
    13be:	1b c0       	rjmp	.+54     	; 0x13f6 <xQueueGenericSend+0xfc>
    13c0:	c8 01       	movw	r24, r16
    13c2:	0e 94 3f 08 	call	0x107e	; 0x107e <prvIsQueueFull>
    13c6:	88 23       	and	r24, r24
    13c8:	81 f0       	breq	.+32     	; 0x13ea <xQueueGenericSend+0xf0>
    13ca:	6c 81       	ldd	r22, Y+4	; 0x04
    13cc:	7d 81       	ldd	r23, Y+5	; 0x05
    13ce:	c8 01       	movw	r24, r16
    13d0:	08 96       	adiw	r24, 0x08	; 8
    13d2:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <vTaskPlaceOnEventList>
    13d6:	c8 01       	movw	r24, r16
    13d8:	0e 94 c6 08 	call	0x118c	; 0x118c <prvUnlockQueue>
    13dc:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <xTaskResumeAll>
    13e0:	81 11       	cpse	r24, r1
    13e2:	9e cf       	rjmp	.-196    	; 0x1320 <xQueueGenericSend+0x26>
    13e4:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vPortYield>
    13e8:	9b cf       	rjmp	.-202    	; 0x1320 <xQueueGenericSend+0x26>
    13ea:	c8 01       	movw	r24, r16
    13ec:	0e 94 c6 08 	call	0x118c	; 0x118c <prvUnlockQueue>
    13f0:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <xTaskResumeAll>
    13f4:	95 cf       	rjmp	.-214    	; 0x1320 <xQueueGenericSend+0x26>
    13f6:	c8 01       	movw	r24, r16
    13f8:	0e 94 c6 08 	call	0x118c	; 0x118c <prvUnlockQueue>
    13fc:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <xTaskResumeAll>
    1400:	80 e0       	ldi	r24, 0x00	; 0
    1402:	0f 90       	pop	r0
    1404:	0f 90       	pop	r0
    1406:	0f 90       	pop	r0
    1408:	0f 90       	pop	r0
    140a:	0f 90       	pop	r0
    140c:	df 91       	pop	r29
    140e:	cf 91       	pop	r28
    1410:	1f 91       	pop	r17
    1412:	0f 91       	pop	r16
    1414:	ff 90       	pop	r15
    1416:	ef 90       	pop	r14
    1418:	df 90       	pop	r13
    141a:	cf 90       	pop	r12
    141c:	08 95       	ret

0000141e <prvInitialiseMutex>:
    141e:	00 97       	sbiw	r24, 0x00	; 0
    1420:	69 f0       	breq	.+26     	; 0x143c <prvInitialiseMutex+0x1e>
    1422:	fc 01       	movw	r30, r24
    1424:	13 82       	std	Z+3, r1	; 0x03
    1426:	12 82       	std	Z+2, r1	; 0x02
    1428:	11 82       	std	Z+1, r1	; 0x01
    142a:	10 82       	st	Z, r1
    142c:	16 82       	std	Z+6, r1	; 0x06
    142e:	20 e0       	ldi	r18, 0x00	; 0
    1430:	40 e0       	ldi	r20, 0x00	; 0
    1432:	50 e0       	ldi	r21, 0x00	; 0
    1434:	60 e0       	ldi	r22, 0x00	; 0
    1436:	70 e0       	ldi	r23, 0x00	; 0
    1438:	0e 94 7d 09 	call	0x12fa	; 0x12fa <xQueueGenericSend>
    143c:	08 95       	ret

0000143e <xQueueCreateMutex>:
    143e:	cf 93       	push	r28
    1440:	df 93       	push	r29
    1442:	48 2f       	mov	r20, r24
    1444:	60 e0       	ldi	r22, 0x00	; 0
    1446:	81 e0       	ldi	r24, 0x01	; 1
    1448:	0e 94 53 09 	call	0x12a6	; 0x12a6 <xQueueGenericCreate>
    144c:	ec 01       	movw	r28, r24
    144e:	0e 94 0f 0a 	call	0x141e	; 0x141e <prvInitialiseMutex>
    1452:	ce 01       	movw	r24, r28
    1454:	df 91       	pop	r29
    1456:	cf 91       	pop	r28
    1458:	08 95       	ret

0000145a <xQueueGenericSendFromISR>:
    145a:	ef 92       	push	r14
    145c:	ff 92       	push	r15
    145e:	0f 93       	push	r16
    1460:	1f 93       	push	r17
    1462:	cf 93       	push	r28
    1464:	df 93       	push	r29
    1466:	8a 01       	movw	r16, r20
    1468:	fc 01       	movw	r30, r24
    146a:	52 8d       	ldd	r21, Z+26	; 0x1a
    146c:	33 8d       	ldd	r19, Z+27	; 0x1b
    146e:	53 17       	cp	r21, r19
    1470:	10 f0       	brcs	.+4      	; 0x1476 <xQueueGenericSendFromISR+0x1c>
    1472:	22 30       	cpi	r18, 0x02	; 2
    1474:	f1 f4       	brne	.+60     	; 0x14b2 <xQueueGenericSendFromISR+0x58>
    1476:	42 2f       	mov	r20, r18
    1478:	78 01       	movw	r14, r16
    147a:	ec 01       	movw	r28, r24
    147c:	1e 8d       	ldd	r17, Y+30	; 0x1e
    147e:	0e 94 4d 08 	call	0x109a	; 0x109a <prvCopyDataToQueue>
    1482:	1f 3f       	cpi	r17, 0xFF	; 255
    1484:	81 f4       	brne	.+32     	; 0x14a6 <xQueueGenericSendFromISR+0x4c>
    1486:	89 89       	ldd	r24, Y+17	; 0x11
    1488:	88 23       	and	r24, r24
    148a:	a9 f0       	breq	.+42     	; 0x14b6 <xQueueGenericSendFromISR+0x5c>
    148c:	ce 01       	movw	r24, r28
    148e:	41 96       	adiw	r24, 0x11	; 17
    1490:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <xTaskRemoveFromEventList>
    1494:	88 23       	and	r24, r24
    1496:	89 f0       	breq	.+34     	; 0x14ba <xQueueGenericSendFromISR+0x60>
    1498:	e1 14       	cp	r14, r1
    149a:	f1 04       	cpc	r15, r1
    149c:	81 f0       	breq	.+32     	; 0x14be <xQueueGenericSendFromISR+0x64>
    149e:	81 e0       	ldi	r24, 0x01	; 1
    14a0:	f7 01       	movw	r30, r14
    14a2:	80 83       	st	Z, r24
    14a4:	0d c0       	rjmp	.+26     	; 0x14c0 <xQueueGenericSendFromISR+0x66>
    14a6:	ff 24       	eor	r15, r15
    14a8:	f3 94       	inc	r15
    14aa:	f1 0e       	add	r15, r17
    14ac:	fe 8e       	std	Y+30, r15	; 0x1e
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	07 c0       	rjmp	.+14     	; 0x14c0 <xQueueGenericSendFromISR+0x66>
    14b2:	80 e0       	ldi	r24, 0x00	; 0
    14b4:	05 c0       	rjmp	.+10     	; 0x14c0 <xQueueGenericSendFromISR+0x66>
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	03 c0       	rjmp	.+6      	; 0x14c0 <xQueueGenericSendFromISR+0x66>
    14ba:	81 e0       	ldi	r24, 0x01	; 1
    14bc:	01 c0       	rjmp	.+2      	; 0x14c0 <xQueueGenericSendFromISR+0x66>
    14be:	81 e0       	ldi	r24, 0x01	; 1
    14c0:	df 91       	pop	r29
    14c2:	cf 91       	pop	r28
    14c4:	1f 91       	pop	r17
    14c6:	0f 91       	pop	r16
    14c8:	ff 90       	pop	r15
    14ca:	ef 90       	pop	r14
    14cc:	08 95       	ret

000014ce <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    14ce:	8f 92       	push	r8
    14d0:	9f 92       	push	r9
    14d2:	bf 92       	push	r11
    14d4:	cf 92       	push	r12
    14d6:	df 92       	push	r13
    14d8:	ef 92       	push	r14
    14da:	ff 92       	push	r15
    14dc:	0f 93       	push	r16
    14de:	1f 93       	push	r17
    14e0:	cf 93       	push	r28
    14e2:	df 93       	push	r29
    14e4:	00 d0       	rcall	.+0      	; 0x14e6 <xQueueGenericReceive+0x18>
    14e6:	00 d0       	rcall	.+0      	; 0x14e8 <xQueueGenericReceive+0x1a>
    14e8:	1f 92       	push	r1
    14ea:	cd b7       	in	r28, 0x3d	; 61
    14ec:	de b7       	in	r29, 0x3e	; 62
    14ee:	8c 01       	movw	r16, r24
    14f0:	6b 01       	movw	r12, r22
    14f2:	5d 83       	std	Y+5, r21	; 0x05
    14f4:	4c 83       	std	Y+4, r20	; 0x04
    14f6:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    14f8:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    14fa:	0f b6       	in	r0, 0x3f	; 63
    14fc:	f8 94       	cli
    14fe:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1500:	f8 01       	movw	r30, r16
    1502:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1504:	ff 20       	and	r15, r15
    1506:	91 f1       	breq	.+100    	; 0x156c <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1508:	86 80       	ldd	r8, Z+6	; 0x06
    150a:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    150c:	b6 01       	movw	r22, r12
    150e:	c8 01       	movw	r24, r16
    1510:	0e 94 ac 08 	call	0x1158	; 0x1158 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1514:	b1 10       	cpse	r11, r1
    1516:	19 c0       	rjmp	.+50     	; 0x154a <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1518:	fa 94       	dec	r15
    151a:	f8 01       	movw	r30, r16
    151c:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    151e:	80 81       	ld	r24, Z
    1520:	91 81       	ldd	r25, Z+1	; 0x01
    1522:	89 2b       	or	r24, r25
    1524:	29 f4       	brne	.+10     	; 0x1530 <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1526:	0e 94 a6 10 	call	0x214c	; 0x214c <pvTaskIncrementMutexHeldCount>
    152a:	f8 01       	movw	r30, r16
    152c:	93 83       	std	Z+3, r25	; 0x03
    152e:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1530:	f8 01       	movw	r30, r16
    1532:	80 85       	ldd	r24, Z+8	; 0x08
    1534:	88 23       	and	r24, r24
    1536:	b1 f0       	breq	.+44     	; 0x1564 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1538:	c8 01       	movw	r24, r16
    153a:	08 96       	adiw	r24, 0x08	; 8
    153c:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <xTaskRemoveFromEventList>
    1540:	88 23       	and	r24, r24
    1542:	81 f0       	breq	.+32     	; 0x1564 <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1544:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vPortYield>
    1548:	0d c0       	rjmp	.+26     	; 0x1564 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    154a:	f8 01       	movw	r30, r16
    154c:	97 82       	std	Z+7, r9	; 0x07
    154e:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1550:	81 89       	ldd	r24, Z+17	; 0x11
    1552:	88 23       	and	r24, r24
    1554:	39 f0       	breq	.+14     	; 0x1564 <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1556:	c8 01       	movw	r24, r16
    1558:	41 96       	adiw	r24, 0x11	; 17
    155a:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <xTaskRemoveFromEventList>
    155e:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1560:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1564:	0f 90       	pop	r0
    1566:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1568:	81 e0       	ldi	r24, 0x01	; 1
    156a:	61 c0       	rjmp	.+194    	; 0x162e <xQueueGenericReceive+0x160>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    156c:	8c 81       	ldd	r24, Y+4	; 0x04
    156e:	9d 81       	ldd	r25, Y+5	; 0x05
    1570:	89 2b       	or	r24, r25
    1572:	21 f4       	brne	.+8      	; 0x157c <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1574:	0f 90       	pop	r0
    1576:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1578:	80 e0       	ldi	r24, 0x00	; 0
    157a:	59 c0       	rjmp	.+178    	; 0x162e <xQueueGenericReceive+0x160>
				}
				else if( xEntryTimeSet == pdFALSE )
    157c:	e1 10       	cpse	r14, r1
    157e:	06 c0       	rjmp	.+12     	; 0x158c <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1580:	ce 01       	movw	r24, r28
    1582:	01 96       	adiw	r24, 0x01	; 1
    1584:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1588:	ee 24       	eor	r14, r14
    158a:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    158c:	0f 90       	pop	r0
    158e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1590:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1594:	0f b6       	in	r0, 0x3f	; 63
    1596:	f8 94       	cli
    1598:	0f 92       	push	r0
    159a:	f8 01       	movw	r30, r16
    159c:	85 8d       	ldd	r24, Z+29	; 0x1d
    159e:	8f 3f       	cpi	r24, 0xFF	; 255
    15a0:	09 f4       	brne	.+2      	; 0x15a4 <xQueueGenericReceive+0xd6>
    15a2:	15 8e       	std	Z+29, r1	; 0x1d
    15a4:	f8 01       	movw	r30, r16
    15a6:	86 8d       	ldd	r24, Z+30	; 0x1e
    15a8:	8f 3f       	cpi	r24, 0xFF	; 255
    15aa:	09 f4       	brne	.+2      	; 0x15ae <xQueueGenericReceive+0xe0>
    15ac:	16 8e       	std	Z+30, r1	; 0x1e
    15ae:	0f 90       	pop	r0
    15b0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15b2:	be 01       	movw	r22, r28
    15b4:	6c 5f       	subi	r22, 0xFC	; 252
    15b6:	7f 4f       	sbci	r23, 0xFF	; 255
    15b8:	ce 01       	movw	r24, r28
    15ba:	01 96       	adiw	r24, 0x01	; 1
    15bc:	0e 94 c7 0f 	call	0x1f8e	; 0x1f8e <xTaskCheckForTimeOut>
    15c0:	81 11       	cpse	r24, r1
    15c2:	29 c0       	rjmp	.+82     	; 0x1616 <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    15c4:	c8 01       	movw	r24, r16
    15c6:	0e 94 32 08 	call	0x1064	; 0x1064 <prvIsQueueEmpty>
    15ca:	88 23       	and	r24, r24
    15cc:	f1 f0       	breq	.+60     	; 0x160a <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    15ce:	f8 01       	movw	r30, r16
    15d0:	80 81       	ld	r24, Z
    15d2:	91 81       	ldd	r25, Z+1	; 0x01
    15d4:	89 2b       	or	r24, r25
    15d6:	49 f4       	brne	.+18     	; 0x15ea <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
    15d8:	0f b6       	in	r0, 0x3f	; 63
    15da:	f8 94       	cli
    15dc:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    15de:	82 81       	ldd	r24, Z+2	; 0x02
    15e0:	93 81       	ldd	r25, Z+3	; 0x03
    15e2:	0e 94 04 10 	call	0x2008	; 0x2008 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    15e6:	0f 90       	pop	r0
    15e8:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    15ea:	6c 81       	ldd	r22, Y+4	; 0x04
    15ec:	7d 81       	ldd	r23, Y+5	; 0x05
    15ee:	c8 01       	movw	r24, r16
    15f0:	41 96       	adiw	r24, 0x11	; 17
    15f2:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    15f6:	c8 01       	movw	r24, r16
    15f8:	0e 94 c6 08 	call	0x118c	; 0x118c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    15fc:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <xTaskResumeAll>
    1600:	81 11       	cpse	r24, r1
    1602:	7b cf       	rjmp	.-266    	; 0x14fa <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    1604:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vPortYield>
    1608:	78 cf       	rjmp	.-272    	; 0x14fa <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    160a:	c8 01       	movw	r24, r16
    160c:	0e 94 c6 08 	call	0x118c	; 0x118c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1610:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <xTaskResumeAll>
    1614:	72 cf       	rjmp	.-284    	; 0x14fa <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1616:	c8 01       	movw	r24, r16
    1618:	0e 94 c6 08 	call	0x118c	; 0x118c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    161c:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1620:	c8 01       	movw	r24, r16
    1622:	0e 94 32 08 	call	0x1064	; 0x1064 <prvIsQueueEmpty>
    1626:	88 23       	and	r24, r24
    1628:	09 f4       	brne	.+2      	; 0x162c <xQueueGenericReceive+0x15e>
    162a:	67 cf       	rjmp	.-306    	; 0x14fa <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    162c:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    162e:	0f 90       	pop	r0
    1630:	0f 90       	pop	r0
    1632:	0f 90       	pop	r0
    1634:	0f 90       	pop	r0
    1636:	0f 90       	pop	r0
    1638:	df 91       	pop	r29
    163a:	cf 91       	pop	r28
    163c:	1f 91       	pop	r17
    163e:	0f 91       	pop	r16
    1640:	ff 90       	pop	r15
    1642:	ef 90       	pop	r14
    1644:	df 90       	pop	r13
    1646:	cf 90       	pop	r12
    1648:	bf 90       	pop	r11
    164a:	9f 90       	pop	r9
    164c:	8f 90       	pop	r8
    164e:	08 95       	ret

00001650 <prvTaskIsTaskSuspended>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1650:	fc 01       	movw	r30, r24
    1652:	22 85       	ldd	r18, Z+10	; 0x0a
    1654:	33 85       	ldd	r19, Z+11	; 0x0b
    1656:	26 5b       	subi	r18, 0xB6	; 182
    1658:	30 40       	sbci	r19, 0x00	; 0
    165a:	59 f4       	brne	.+22     	; 0x1672 <prvTaskIsTaskSuspended+0x22>
    165c:	fc 01       	movw	r30, r24
    165e:	84 89       	ldd	r24, Z+20	; 0x14
    1660:	95 89       	ldd	r25, Z+21	; 0x15
    1662:	f0 e0       	ldi	r31, 0x00	; 0
    1664:	8f 3b       	cpi	r24, 0xBF	; 191
    1666:	9f 07       	cpc	r25, r31
    1668:	31 f0       	breq	.+12     	; 0x1676 <prvTaskIsTaskSuspended+0x26>
    166a:	89 2b       	or	r24, r25
    166c:	31 f0       	breq	.+12     	; 0x167a <prvTaskIsTaskSuspended+0x2a>
    166e:	80 e0       	ldi	r24, 0x00	; 0
    1670:	08 95       	ret
    1672:	80 e0       	ldi	r24, 0x00	; 0
    1674:	08 95       	ret
    1676:	80 e0       	ldi	r24, 0x00	; 0
    1678:	08 95       	ret
    167a:	81 e0       	ldi	r24, 0x01	; 1
    167c:	08 95       	ret

0000167e <prvResetNextTaskUnblockTime>:
    167e:	e0 91 ca 00 	lds	r30, 0x00CA	; 0x8000ca <pxDelayedTaskList>
    1682:	f0 91 cb 00 	lds	r31, 0x00CB	; 0x8000cb <pxDelayedTaskList+0x1>
    1686:	80 81       	ld	r24, Z
    1688:	81 11       	cpse	r24, r1
    168a:	07 c0       	rjmp	.+14     	; 0x169a <prvResetNextTaskUnblockTime+0x1c>
    168c:	8f ef       	ldi	r24, 0xFF	; 255
    168e:	9f ef       	ldi	r25, 0xFF	; 255
    1690:	90 93 ac 00 	sts	0x00AC, r25	; 0x8000ac <xNextTaskUnblockTime+0x1>
    1694:	80 93 ab 00 	sts	0x00AB, r24	; 0x8000ab <xNextTaskUnblockTime>
    1698:	08 95       	ret
    169a:	e0 91 ca 00 	lds	r30, 0x00CA	; 0x8000ca <pxDelayedTaskList>
    169e:	f0 91 cb 00 	lds	r31, 0x00CB	; 0x8000cb <pxDelayedTaskList+0x1>
    16a2:	05 80       	ldd	r0, Z+5	; 0x05
    16a4:	f6 81       	ldd	r31, Z+6	; 0x06
    16a6:	e0 2d       	mov	r30, r0
    16a8:	06 80       	ldd	r0, Z+6	; 0x06
    16aa:	f7 81       	ldd	r31, Z+7	; 0x07
    16ac:	e0 2d       	mov	r30, r0
    16ae:	82 81       	ldd	r24, Z+2	; 0x02
    16b0:	93 81       	ldd	r25, Z+3	; 0x03
    16b2:	90 93 ac 00 	sts	0x00AC, r25	; 0x8000ac <xNextTaskUnblockTime+0x1>
    16b6:	80 93 ab 00 	sts	0x00AB, r24	; 0x8000ab <xNextTaskUnblockTime>
    16ba:	08 95       	ret

000016bc <prvInitialiseNewTask>:
    16bc:	6f 92       	push	r6
    16be:	7f 92       	push	r7
    16c0:	8f 92       	push	r8
    16c2:	9f 92       	push	r9
    16c4:	af 92       	push	r10
    16c6:	bf 92       	push	r11
    16c8:	cf 92       	push	r12
    16ca:	df 92       	push	r13
    16cc:	ef 92       	push	r14
    16ce:	0f 93       	push	r16
    16d0:	1f 93       	push	r17
    16d2:	cf 93       	push	r28
    16d4:	df 93       	push	r29
    16d6:	cd b7       	in	r28, 0x3d	; 61
    16d8:	de b7       	in	r29, 0x3e	; 62
    16da:	4c 01       	movw	r8, r24
    16dc:	f5 01       	movw	r30, r10
    16de:	87 89       	ldd	r24, Z+23	; 0x17
    16e0:	90 8d       	ldd	r25, Z+24	; 0x18
    16e2:	21 50       	subi	r18, 0x01	; 1
    16e4:	31 09       	sbc	r19, r1
    16e6:	3c 01       	movw	r6, r24
    16e8:	62 0e       	add	r6, r18
    16ea:	73 1e       	adc	r7, r19
    16ec:	20 e0       	ldi	r18, 0x00	; 0
    16ee:	0f c0       	rjmp	.+30     	; 0x170e <prvInitialiseNewTask+0x52>
    16f0:	82 2f       	mov	r24, r18
    16f2:	90 e0       	ldi	r25, 0x00	; 0
    16f4:	fb 01       	movw	r30, r22
    16f6:	e8 0f       	add	r30, r24
    16f8:	f9 1f       	adc	r31, r25
    16fa:	30 81       	ld	r19, Z
    16fc:	d5 01       	movw	r26, r10
    16fe:	a8 0f       	add	r26, r24
    1700:	b9 1f       	adc	r27, r25
    1702:	59 96       	adiw	r26, 0x19	; 25
    1704:	3c 93       	st	X, r19
    1706:	80 81       	ld	r24, Z
    1708:	88 23       	and	r24, r24
    170a:	19 f0       	breq	.+6      	; 0x1712 <prvInitialiseNewTask+0x56>
    170c:	2f 5f       	subi	r18, 0xFF	; 255
    170e:	28 30       	cpi	r18, 0x08	; 8
    1710:	78 f3       	brcs	.-34     	; 0x16f0 <prvInitialiseNewTask+0x34>
    1712:	f5 01       	movw	r30, r10
    1714:	10 a2       	std	Z+32, r1	; 0x20
    1716:	f3 e0       	ldi	r31, 0x03	; 3
    1718:	fe 15       	cp	r31, r14
    171a:	20 f4       	brcc	.+8      	; 0x1724 <prvInitialiseNewTask+0x68>
    171c:	0f 2e       	mov	r0, r31
    171e:	f3 e0       	ldi	r31, 0x03	; 3
    1720:	ef 2e       	mov	r14, r31
    1722:	f0 2d       	mov	r31, r0
    1724:	f5 01       	movw	r30, r10
    1726:	e6 8a       	std	Z+22, r14	; 0x16
    1728:	e1 a2       	std	Z+33, r14	; 0x21
    172a:	12 a2       	std	Z+34, r1	; 0x22
    172c:	c5 01       	movw	r24, r10
    172e:	02 96       	adiw	r24, 0x02	; 2
    1730:	0e 94 3c 06 	call	0xc78	; 0xc78 <vListInitialiseItem>
    1734:	c5 01       	movw	r24, r10
    1736:	0c 96       	adiw	r24, 0x0c	; 12
    1738:	0e 94 3c 06 	call	0xc78	; 0xc78 <vListInitialiseItem>
    173c:	f5 01       	movw	r30, r10
    173e:	b1 86       	std	Z+9, r11	; 0x09
    1740:	a0 86       	std	Z+8, r10	; 0x08
    1742:	84 e0       	ldi	r24, 0x04	; 4
    1744:	90 e0       	ldi	r25, 0x00	; 0
    1746:	8e 19       	sub	r24, r14
    1748:	91 09       	sbc	r25, r1
    174a:	95 87       	std	Z+13, r25	; 0x0d
    174c:	84 87       	std	Z+12, r24	; 0x0c
    174e:	b3 8a       	std	Z+19, r11	; 0x13
    1750:	a2 8a       	std	Z+18, r10	; 0x12
    1752:	13 a2       	std	Z+35, r1	; 0x23
    1754:	14 a2       	std	Z+36, r1	; 0x24
    1756:	15 a2       	std	Z+37, r1	; 0x25
    1758:	16 a2       	std	Z+38, r1	; 0x26
    175a:	17 a2       	std	Z+39, r1	; 0x27
    175c:	a8 01       	movw	r20, r16
    175e:	b4 01       	movw	r22, r8
    1760:	c3 01       	movw	r24, r6
    1762:	0e 94 c1 06 	call	0xd82	; 0xd82 <pxPortInitialiseStack>
    1766:	f5 01       	movw	r30, r10
    1768:	91 83       	std	Z+1, r25	; 0x01
    176a:	80 83       	st	Z, r24
    176c:	c1 14       	cp	r12, r1
    176e:	d1 04       	cpc	r13, r1
    1770:	19 f0       	breq	.+6      	; 0x1778 <prvInitialiseNewTask+0xbc>
    1772:	f6 01       	movw	r30, r12
    1774:	b1 82       	std	Z+1, r11	; 0x01
    1776:	a0 82       	st	Z, r10
    1778:	df 91       	pop	r29
    177a:	cf 91       	pop	r28
    177c:	1f 91       	pop	r17
    177e:	0f 91       	pop	r16
    1780:	ef 90       	pop	r14
    1782:	df 90       	pop	r13
    1784:	cf 90       	pop	r12
    1786:	bf 90       	pop	r11
    1788:	af 90       	pop	r10
    178a:	9f 90       	pop	r9
    178c:	8f 90       	pop	r8
    178e:	7f 90       	pop	r7
    1790:	6f 90       	pop	r6
    1792:	08 95       	ret

00001794 <prvIdleTask>:
    1794:	80 91 de 00 	lds	r24, 0x00DE	; 0x8000de <pxReadyTasksLists>
    1798:	82 30       	cpi	r24, 0x02	; 2
    179a:	e0 f3       	brcs	.-8      	; 0x1794 <prvIdleTask>
    179c:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vPortYield>
    17a0:	f9 cf       	rjmp	.-14     	; 0x1794 <prvIdleTask>

000017a2 <prvInitialiseTaskLists>:
    17a2:	cf 93       	push	r28
    17a4:	c0 e0       	ldi	r28, 0x00	; 0
    17a6:	10 c0       	rjmp	.+32     	; 0x17c8 <prvInitialiseTaskLists+0x26>
    17a8:	8c 2f       	mov	r24, r28
    17aa:	90 e0       	ldi	r25, 0x00	; 0
    17ac:	9c 01       	movw	r18, r24
    17ae:	22 0f       	add	r18, r18
    17b0:	33 1f       	adc	r19, r19
    17b2:	22 0f       	add	r18, r18
    17b4:	33 1f       	adc	r19, r19
    17b6:	22 0f       	add	r18, r18
    17b8:	33 1f       	adc	r19, r19
    17ba:	82 0f       	add	r24, r18
    17bc:	93 1f       	adc	r25, r19
    17be:	82 52       	subi	r24, 0x22	; 34
    17c0:	9f 4f       	sbci	r25, 0xFF	; 255
    17c2:	0e 94 2e 06 	call	0xc5c	; 0xc5c <vListInitialise>
    17c6:	cf 5f       	subi	r28, 0xFF	; 255
    17c8:	c4 30       	cpi	r28, 0x04	; 4
    17ca:	70 f3       	brcs	.-36     	; 0x17a8 <prvInitialiseTaskLists+0x6>
    17cc:	85 ed       	ldi	r24, 0xD5	; 213
    17ce:	90 e0       	ldi	r25, 0x00	; 0
    17d0:	0e 94 2e 06 	call	0xc5c	; 0xc5c <vListInitialise>
    17d4:	8c ec       	ldi	r24, 0xCC	; 204
    17d6:	90 e0       	ldi	r25, 0x00	; 0
    17d8:	0e 94 2e 06 	call	0xc5c	; 0xc5c <vListInitialise>
    17dc:	8f eb       	ldi	r24, 0xBF	; 191
    17de:	90 e0       	ldi	r25, 0x00	; 0
    17e0:	0e 94 2e 06 	call	0xc5c	; 0xc5c <vListInitialise>
    17e4:	86 eb       	ldi	r24, 0xB6	; 182
    17e6:	90 e0       	ldi	r25, 0x00	; 0
    17e8:	0e 94 2e 06 	call	0xc5c	; 0xc5c <vListInitialise>
    17ec:	85 ed       	ldi	r24, 0xD5	; 213
    17ee:	90 e0       	ldi	r25, 0x00	; 0
    17f0:	90 93 cb 00 	sts	0x00CB, r25	; 0x8000cb <pxDelayedTaskList+0x1>
    17f4:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <pxDelayedTaskList>
    17f8:	8c ec       	ldi	r24, 0xCC	; 204
    17fa:	90 e0       	ldi	r25, 0x00	; 0
    17fc:	90 93 c9 00 	sts	0x00C9, r25	; 0x8000c9 <pxOverflowDelayedTaskList+0x1>
    1800:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <pxOverflowDelayedTaskList>
    1804:	cf 91       	pop	r28
    1806:	08 95       	ret

00001808 <prvAddNewTaskToReadyList>:
    1808:	cf 93       	push	r28
    180a:	df 93       	push	r29
    180c:	ec 01       	movw	r28, r24
    180e:	0f b6       	in	r0, 0x3f	; 63
    1810:	f8 94       	cli
    1812:	0f 92       	push	r0
    1814:	80 91 b5 00 	lds	r24, 0x00B5	; 0x8000b5 <uxCurrentNumberOfTasks>
    1818:	8f 5f       	subi	r24, 0xFF	; 255
    181a:	80 93 b5 00 	sts	0x00B5, r24	; 0x8000b5 <uxCurrentNumberOfTasks>
    181e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <pxCurrentTCB>
    1822:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    1826:	89 2b       	or	r24, r25
    1828:	59 f4       	brne	.+22     	; 0x1840 <prvAddNewTaskToReadyList+0x38>
    182a:	d0 93 03 01 	sts	0x0103, r29	; 0x800103 <pxCurrentTCB+0x1>
    182e:	c0 93 02 01 	sts	0x0102, r28	; 0x800102 <pxCurrentTCB>
    1832:	80 91 b5 00 	lds	r24, 0x00B5	; 0x8000b5 <uxCurrentNumberOfTasks>
    1836:	81 30       	cpi	r24, 0x01	; 1
    1838:	99 f4       	brne	.+38     	; 0x1860 <prvAddNewTaskToReadyList+0x58>
    183a:	0e 94 d1 0b 	call	0x17a2	; 0x17a2 <prvInitialiseTaskLists>
    183e:	10 c0       	rjmp	.+32     	; 0x1860 <prvAddNewTaskToReadyList+0x58>
    1840:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <xSchedulerRunning>
    1844:	81 11       	cpse	r24, r1
    1846:	0c c0       	rjmp	.+24     	; 0x1860 <prvAddNewTaskToReadyList+0x58>
    1848:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <pxCurrentTCB>
    184c:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    1850:	96 89       	ldd	r25, Z+22	; 0x16
    1852:	8e 89       	ldd	r24, Y+22	; 0x16
    1854:	89 17       	cp	r24, r25
    1856:	20 f0       	brcs	.+8      	; 0x1860 <prvAddNewTaskToReadyList+0x58>
    1858:	d0 93 03 01 	sts	0x0103, r29	; 0x800103 <pxCurrentTCB+0x1>
    185c:	c0 93 02 01 	sts	0x0102, r28	; 0x800102 <pxCurrentTCB>
    1860:	80 91 ad 00 	lds	r24, 0x00AD	; 0x8000ad <uxTaskNumber>
    1864:	8f 5f       	subi	r24, 0xFF	; 255
    1866:	80 93 ad 00 	sts	0x00AD, r24	; 0x8000ad <uxTaskNumber>
    186a:	8e 89       	ldd	r24, Y+22	; 0x16
    186c:	90 91 b2 00 	lds	r25, 0x00B2	; 0x8000b2 <uxTopReadyPriority>
    1870:	98 17       	cp	r25, r24
    1872:	10 f4       	brcc	.+4      	; 0x1878 <prvAddNewTaskToReadyList+0x70>
    1874:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <uxTopReadyPriority>
    1878:	90 e0       	ldi	r25, 0x00	; 0
    187a:	9c 01       	movw	r18, r24
    187c:	22 0f       	add	r18, r18
    187e:	33 1f       	adc	r19, r19
    1880:	22 0f       	add	r18, r18
    1882:	33 1f       	adc	r19, r19
    1884:	22 0f       	add	r18, r18
    1886:	33 1f       	adc	r19, r19
    1888:	82 0f       	add	r24, r18
    188a:	93 1f       	adc	r25, r19
    188c:	be 01       	movw	r22, r28
    188e:	6e 5f       	subi	r22, 0xFE	; 254
    1890:	7f 4f       	sbci	r23, 0xFF	; 255
    1892:	82 52       	subi	r24, 0x22	; 34
    1894:	9f 4f       	sbci	r25, 0xFF	; 255
    1896:	0e 94 40 06 	call	0xc80	; 0xc80 <vListInsertEnd>
    189a:	0f 90       	pop	r0
    189c:	0f be       	out	0x3f, r0	; 63
    189e:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <xSchedulerRunning>
    18a2:	88 23       	and	r24, r24
    18a4:	51 f0       	breq	.+20     	; 0x18ba <prvAddNewTaskToReadyList+0xb2>
    18a6:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <pxCurrentTCB>
    18aa:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    18ae:	96 89       	ldd	r25, Z+22	; 0x16
    18b0:	8e 89       	ldd	r24, Y+22	; 0x16
    18b2:	98 17       	cp	r25, r24
    18b4:	10 f4       	brcc	.+4      	; 0x18ba <prvAddNewTaskToReadyList+0xb2>
    18b6:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vPortYield>
    18ba:	df 91       	pop	r29
    18bc:	cf 91       	pop	r28
    18be:	08 95       	ret

000018c0 <prvAddCurrentTaskToDelayedList>:
    18c0:	ff 92       	push	r15
    18c2:	0f 93       	push	r16
    18c4:	1f 93       	push	r17
    18c6:	cf 93       	push	r28
    18c8:	df 93       	push	r29
    18ca:	ec 01       	movw	r28, r24
    18cc:	f6 2e       	mov	r15, r22
    18ce:	00 91 b3 00 	lds	r16, 0x00B3	; 0x8000b3 <xTickCount>
    18d2:	10 91 b4 00 	lds	r17, 0x00B4	; 0x8000b4 <xTickCount+0x1>
    18d6:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <pxCurrentTCB>
    18da:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    18de:	02 96       	adiw	r24, 0x02	; 2
    18e0:	0e 94 92 06 	call	0xd24	; 0xd24 <uxListRemove>
    18e4:	cf 3f       	cpi	r28, 0xFF	; 255
    18e6:	8f ef       	ldi	r24, 0xFF	; 255
    18e8:	d8 07       	cpc	r29, r24
    18ea:	69 f4       	brne	.+26     	; 0x1906 <prvAddCurrentTaskToDelayedList+0x46>
    18ec:	ff 20       	and	r15, r15
    18ee:	59 f0       	breq	.+22     	; 0x1906 <prvAddCurrentTaskToDelayedList+0x46>
    18f0:	60 91 02 01 	lds	r22, 0x0102	; 0x800102 <pxCurrentTCB>
    18f4:	70 91 03 01 	lds	r23, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    18f8:	6e 5f       	subi	r22, 0xFE	; 254
    18fa:	7f 4f       	sbci	r23, 0xFF	; 255
    18fc:	86 eb       	ldi	r24, 0xB6	; 182
    18fe:	90 e0       	ldi	r25, 0x00	; 0
    1900:	0e 94 40 06 	call	0xc80	; 0xc80 <vListInsertEnd>
    1904:	2f c0       	rjmp	.+94     	; 0x1964 <prvAddCurrentTaskToDelayedList+0xa4>
    1906:	c0 0f       	add	r28, r16
    1908:	d1 1f       	adc	r29, r17
    190a:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <pxCurrentTCB>
    190e:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    1912:	d3 83       	std	Z+3, r29	; 0x03
    1914:	c2 83       	std	Z+2, r28	; 0x02
    1916:	c0 17       	cp	r28, r16
    1918:	d1 07       	cpc	r29, r17
    191a:	68 f4       	brcc	.+26     	; 0x1936 <prvAddCurrentTaskToDelayedList+0x76>
    191c:	60 91 02 01 	lds	r22, 0x0102	; 0x800102 <pxCurrentTCB>
    1920:	70 91 03 01 	lds	r23, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    1924:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <pxOverflowDelayedTaskList>
    1928:	90 91 c9 00 	lds	r25, 0x00C9	; 0x8000c9 <pxOverflowDelayedTaskList+0x1>
    192c:	6e 5f       	subi	r22, 0xFE	; 254
    192e:	7f 4f       	sbci	r23, 0xFF	; 255
    1930:	0e 94 61 06 	call	0xcc2	; 0xcc2 <vListInsert>
    1934:	17 c0       	rjmp	.+46     	; 0x1964 <prvAddCurrentTaskToDelayedList+0xa4>
    1936:	60 91 02 01 	lds	r22, 0x0102	; 0x800102 <pxCurrentTCB>
    193a:	70 91 03 01 	lds	r23, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    193e:	80 91 ca 00 	lds	r24, 0x00CA	; 0x8000ca <pxDelayedTaskList>
    1942:	90 91 cb 00 	lds	r25, 0x00CB	; 0x8000cb <pxDelayedTaskList+0x1>
    1946:	6e 5f       	subi	r22, 0xFE	; 254
    1948:	7f 4f       	sbci	r23, 0xFF	; 255
    194a:	0e 94 61 06 	call	0xcc2	; 0xcc2 <vListInsert>
    194e:	80 91 ab 00 	lds	r24, 0x00AB	; 0x8000ab <xNextTaskUnblockTime>
    1952:	90 91 ac 00 	lds	r25, 0x00AC	; 0x8000ac <xNextTaskUnblockTime+0x1>
    1956:	c8 17       	cp	r28, r24
    1958:	d9 07       	cpc	r29, r25
    195a:	20 f4       	brcc	.+8      	; 0x1964 <prvAddCurrentTaskToDelayedList+0xa4>
    195c:	d0 93 ac 00 	sts	0x00AC, r29	; 0x8000ac <xNextTaskUnblockTime+0x1>
    1960:	c0 93 ab 00 	sts	0x00AB, r28	; 0x8000ab <xNextTaskUnblockTime>
    1964:	df 91       	pop	r29
    1966:	cf 91       	pop	r28
    1968:	1f 91       	pop	r17
    196a:	0f 91       	pop	r16
    196c:	ff 90       	pop	r15
    196e:	08 95       	ret

00001970 <xTaskCreate>:
    1970:	2f 92       	push	r2
    1972:	3f 92       	push	r3
    1974:	4f 92       	push	r4
    1976:	5f 92       	push	r5
    1978:	6f 92       	push	r6
    197a:	7f 92       	push	r7
    197c:	8f 92       	push	r8
    197e:	9f 92       	push	r9
    1980:	af 92       	push	r10
    1982:	bf 92       	push	r11
    1984:	cf 92       	push	r12
    1986:	df 92       	push	r13
    1988:	ef 92       	push	r14
    198a:	ff 92       	push	r15
    198c:	0f 93       	push	r16
    198e:	1f 93       	push	r17
    1990:	cf 93       	push	r28
    1992:	df 93       	push	r29
    1994:	3c 01       	movw	r6, r24
    1996:	1b 01       	movw	r2, r22
    1998:	5a 01       	movw	r10, r20
    199a:	29 01       	movw	r4, r18
    199c:	ca 01       	movw	r24, r20
    199e:	0e 94 14 08 	call	0x1028	; 0x1028 <pvPortMalloc>
    19a2:	6c 01       	movw	r12, r24
    19a4:	89 2b       	or	r24, r25
    19a6:	71 f0       	breq	.+28     	; 0x19c4 <xTaskCreate+0x54>
    19a8:	88 e2       	ldi	r24, 0x28	; 40
    19aa:	90 e0       	ldi	r25, 0x00	; 0
    19ac:	0e 94 14 08 	call	0x1028	; 0x1028 <pvPortMalloc>
    19b0:	ec 01       	movw	r28, r24
    19b2:	89 2b       	or	r24, r25
    19b4:	19 f0       	breq	.+6      	; 0x19bc <xTaskCreate+0x4c>
    19b6:	d8 8e       	std	Y+24, r13	; 0x18
    19b8:	cf 8a       	std	Y+23, r12	; 0x17
    19ba:	06 c0       	rjmp	.+12     	; 0x19c8 <xTaskCreate+0x58>
    19bc:	c6 01       	movw	r24, r12
    19be:	0e 94 23 08 	call	0x1046	; 0x1046 <vPortFree>
    19c2:	02 c0       	rjmp	.+4      	; 0x19c8 <xTaskCreate+0x58>
    19c4:	c0 e0       	ldi	r28, 0x00	; 0
    19c6:	d0 e0       	ldi	r29, 0x00	; 0
    19c8:	20 97       	sbiw	r28, 0x00	; 0
    19ca:	91 f0       	breq	.+36     	; 0x19f0 <xTaskCreate+0x80>
    19cc:	95 01       	movw	r18, r10
    19ce:	40 e0       	ldi	r20, 0x00	; 0
    19d0:	50 e0       	ldi	r21, 0x00	; 0
    19d2:	81 2c       	mov	r8, r1
    19d4:	91 2c       	mov	r9, r1
    19d6:	5e 01       	movw	r10, r28
    19d8:	67 01       	movw	r12, r14
    19da:	e0 2e       	mov	r14, r16
    19dc:	82 01       	movw	r16, r4
    19de:	b1 01       	movw	r22, r2
    19e0:	c3 01       	movw	r24, r6
    19e2:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <prvInitialiseNewTask>
    19e6:	ce 01       	movw	r24, r28
    19e8:	0e 94 04 0c 	call	0x1808	; 0x1808 <prvAddNewTaskToReadyList>
    19ec:	81 e0       	ldi	r24, 0x01	; 1
    19ee:	01 c0       	rjmp	.+2      	; 0x19f2 <xTaskCreate+0x82>
    19f0:	8f ef       	ldi	r24, 0xFF	; 255
    19f2:	df 91       	pop	r29
    19f4:	cf 91       	pop	r28
    19f6:	1f 91       	pop	r17
    19f8:	0f 91       	pop	r16
    19fa:	ff 90       	pop	r15
    19fc:	ef 90       	pop	r14
    19fe:	df 90       	pop	r13
    1a00:	cf 90       	pop	r12
    1a02:	bf 90       	pop	r11
    1a04:	af 90       	pop	r10
    1a06:	9f 90       	pop	r9
    1a08:	8f 90       	pop	r8
    1a0a:	7f 90       	pop	r7
    1a0c:	6f 90       	pop	r6
    1a0e:	5f 90       	pop	r5
    1a10:	4f 90       	pop	r4
    1a12:	3f 90       	pop	r3
    1a14:	2f 90       	pop	r2
    1a16:	08 95       	ret

00001a18 <vTaskResume>:
    1a18:	0f 93       	push	r16
    1a1a:	1f 93       	push	r17
    1a1c:	cf 93       	push	r28
    1a1e:	df 93       	push	r29
    1a20:	00 97       	sbiw	r24, 0x00	; 0
    1a22:	b9 f1       	breq	.+110    	; 0x1a92 <vTaskResume+0x7a>
    1a24:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <pxCurrentTCB>
    1a28:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    1a2c:	82 17       	cp	r24, r18
    1a2e:	93 07       	cpc	r25, r19
    1a30:	81 f1       	breq	.+96     	; 0x1a92 <vTaskResume+0x7a>
    1a32:	ec 01       	movw	r28, r24
    1a34:	0f b6       	in	r0, 0x3f	; 63
    1a36:	f8 94       	cli
    1a38:	0f 92       	push	r0
    1a3a:	0e 94 28 0b 	call	0x1650	; 0x1650 <prvTaskIsTaskSuspended>
    1a3e:	88 23       	and	r24, r24
    1a40:	31 f1       	breq	.+76     	; 0x1a8e <vTaskResume+0x76>
    1a42:	8e 01       	movw	r16, r28
    1a44:	0e 5f       	subi	r16, 0xFE	; 254
    1a46:	1f 4f       	sbci	r17, 0xFF	; 255
    1a48:	c8 01       	movw	r24, r16
    1a4a:	0e 94 92 06 	call	0xd24	; 0xd24 <uxListRemove>
    1a4e:	8e 89       	ldd	r24, Y+22	; 0x16
    1a50:	90 91 b2 00 	lds	r25, 0x00B2	; 0x8000b2 <uxTopReadyPriority>
    1a54:	98 17       	cp	r25, r24
    1a56:	10 f4       	brcc	.+4      	; 0x1a5c <vTaskResume+0x44>
    1a58:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <uxTopReadyPriority>
    1a5c:	90 e0       	ldi	r25, 0x00	; 0
    1a5e:	9c 01       	movw	r18, r24
    1a60:	22 0f       	add	r18, r18
    1a62:	33 1f       	adc	r19, r19
    1a64:	22 0f       	add	r18, r18
    1a66:	33 1f       	adc	r19, r19
    1a68:	22 0f       	add	r18, r18
    1a6a:	33 1f       	adc	r19, r19
    1a6c:	82 0f       	add	r24, r18
    1a6e:	93 1f       	adc	r25, r19
    1a70:	b8 01       	movw	r22, r16
    1a72:	82 52       	subi	r24, 0x22	; 34
    1a74:	9f 4f       	sbci	r25, 0xFF	; 255
    1a76:	0e 94 40 06 	call	0xc80	; 0xc80 <vListInsertEnd>
    1a7a:	9e 89       	ldd	r25, Y+22	; 0x16
    1a7c:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <pxCurrentTCB>
    1a80:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    1a84:	86 89       	ldd	r24, Z+22	; 0x16
    1a86:	98 17       	cp	r25, r24
    1a88:	10 f0       	brcs	.+4      	; 0x1a8e <vTaskResume+0x76>
    1a8a:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vPortYield>
    1a8e:	0f 90       	pop	r0
    1a90:	0f be       	out	0x3f, r0	; 63
    1a92:	df 91       	pop	r29
    1a94:	cf 91       	pop	r28
    1a96:	1f 91       	pop	r17
    1a98:	0f 91       	pop	r16
    1a9a:	08 95       	ret

00001a9c <vTaskStartScheduler>:
    1a9c:	ef 92       	push	r14
    1a9e:	ff 92       	push	r15
    1aa0:	0f 93       	push	r16
    1aa2:	0f 2e       	mov	r0, r31
    1aa4:	f9 ea       	ldi	r31, 0xA9	; 169
    1aa6:	ef 2e       	mov	r14, r31
    1aa8:	f0 e0       	ldi	r31, 0x00	; 0
    1aaa:	ff 2e       	mov	r15, r31
    1aac:	f0 2d       	mov	r31, r0
    1aae:	00 e0       	ldi	r16, 0x00	; 0
    1ab0:	20 e0       	ldi	r18, 0x00	; 0
    1ab2:	30 e0       	ldi	r19, 0x00	; 0
    1ab4:	45 e5       	ldi	r20, 0x55	; 85
    1ab6:	50 e0       	ldi	r21, 0x00	; 0
    1ab8:	67 e9       	ldi	r22, 0x97	; 151
    1aba:	70 e0       	ldi	r23, 0x00	; 0
    1abc:	8a ec       	ldi	r24, 0xCA	; 202
    1abe:	9b e0       	ldi	r25, 0x0B	; 11
    1ac0:	0e 94 b8 0c 	call	0x1970	; 0x1970 <xTaskCreate>
    1ac4:	81 30       	cpi	r24, 0x01	; 1
    1ac6:	81 f4       	brne	.+32     	; 0x1ae8 <vTaskStartScheduler+0x4c>
    1ac8:	f8 94       	cli
    1aca:	8f ef       	ldi	r24, 0xFF	; 255
    1acc:	9f ef       	ldi	r25, 0xFF	; 255
    1ace:	90 93 ac 00 	sts	0x00AC, r25	; 0x8000ac <xNextTaskUnblockTime+0x1>
    1ad2:	80 93 ab 00 	sts	0x00AB, r24	; 0x8000ab <xNextTaskUnblockTime>
    1ad6:	81 e0       	ldi	r24, 0x01	; 1
    1ad8:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <xSchedulerRunning>
    1adc:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <xTickCount+0x1>
    1ae0:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <xTickCount>
    1ae4:	0e 94 2d 07 	call	0xe5a	; 0xe5a <xPortStartScheduler>
    1ae8:	0f 91       	pop	r16
    1aea:	ff 90       	pop	r15
    1aec:	ef 90       	pop	r14
    1aee:	08 95       	ret

00001af0 <vTaskSuspendAll>:
    1af0:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <uxSchedulerSuspended>
    1af4:	8f 5f       	subi	r24, 0xFF	; 255
    1af6:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <uxSchedulerSuspended>
    1afa:	08 95       	ret

00001afc <xTaskIncrementTick>:
    1afc:	df 92       	push	r13
    1afe:	ef 92       	push	r14
    1b00:	ff 92       	push	r15
    1b02:	0f 93       	push	r16
    1b04:	1f 93       	push	r17
    1b06:	cf 93       	push	r28
    1b08:	df 93       	push	r29
    1b0a:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <uxSchedulerSuspended>
    1b0e:	81 11       	cpse	r24, r1
    1b10:	97 c0       	rjmp	.+302    	; 0x1c40 <xTaskIncrementTick+0x144>
    1b12:	e0 90 b3 00 	lds	r14, 0x00B3	; 0x8000b3 <xTickCount>
    1b16:	f0 90 b4 00 	lds	r15, 0x00B4	; 0x8000b4 <xTickCount+0x1>
    1b1a:	8f ef       	ldi	r24, 0xFF	; 255
    1b1c:	e8 1a       	sub	r14, r24
    1b1e:	f8 0a       	sbc	r15, r24
    1b20:	f0 92 b4 00 	sts	0x00B4, r15	; 0x8000b4 <xTickCount+0x1>
    1b24:	e0 92 b3 00 	sts	0x00B3, r14	; 0x8000b3 <xTickCount>
    1b28:	e1 14       	cp	r14, r1
    1b2a:	f1 04       	cpc	r15, r1
    1b2c:	b9 f4       	brne	.+46     	; 0x1b5c <xTaskIncrementTick+0x60>
    1b2e:	80 91 ca 00 	lds	r24, 0x00CA	; 0x8000ca <pxDelayedTaskList>
    1b32:	90 91 cb 00 	lds	r25, 0x00CB	; 0x8000cb <pxDelayedTaskList+0x1>
    1b36:	20 91 c8 00 	lds	r18, 0x00C8	; 0x8000c8 <pxOverflowDelayedTaskList>
    1b3a:	30 91 c9 00 	lds	r19, 0x00C9	; 0x8000c9 <pxOverflowDelayedTaskList+0x1>
    1b3e:	30 93 cb 00 	sts	0x00CB, r19	; 0x8000cb <pxDelayedTaskList+0x1>
    1b42:	20 93 ca 00 	sts	0x00CA, r18	; 0x8000ca <pxDelayedTaskList>
    1b46:	90 93 c9 00 	sts	0x00C9, r25	; 0x8000c9 <pxOverflowDelayedTaskList+0x1>
    1b4a:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <pxOverflowDelayedTaskList>
    1b4e:	80 91 ae 00 	lds	r24, 0x00AE	; 0x8000ae <xNumOfOverflows>
    1b52:	8f 5f       	subi	r24, 0xFF	; 255
    1b54:	80 93 ae 00 	sts	0x00AE, r24	; 0x8000ae <xNumOfOverflows>
    1b58:	0e 94 3f 0b 	call	0x167e	; 0x167e <prvResetNextTaskUnblockTime>
    1b5c:	80 91 ab 00 	lds	r24, 0x00AB	; 0x8000ab <xNextTaskUnblockTime>
    1b60:	90 91 ac 00 	lds	r25, 0x00AC	; 0x8000ac <xNextTaskUnblockTime+0x1>
    1b64:	e8 16       	cp	r14, r24
    1b66:	f9 06       	cpc	r15, r25
    1b68:	28 f4       	brcc	.+10     	; 0x1b74 <xTaskIncrementTick+0x78>
    1b6a:	d1 2c       	mov	r13, r1
    1b6c:	53 c0       	rjmp	.+166    	; 0x1c14 <xTaskIncrementTick+0x118>
    1b6e:	dd 24       	eor	r13, r13
    1b70:	d3 94       	inc	r13
    1b72:	01 c0       	rjmp	.+2      	; 0x1b76 <xTaskIncrementTick+0x7a>
    1b74:	d1 2c       	mov	r13, r1
    1b76:	e0 91 ca 00 	lds	r30, 0x00CA	; 0x8000ca <pxDelayedTaskList>
    1b7a:	f0 91 cb 00 	lds	r31, 0x00CB	; 0x8000cb <pxDelayedTaskList+0x1>
    1b7e:	80 81       	ld	r24, Z
    1b80:	81 11       	cpse	r24, r1
    1b82:	07 c0       	rjmp	.+14     	; 0x1b92 <xTaskIncrementTick+0x96>
    1b84:	8f ef       	ldi	r24, 0xFF	; 255
    1b86:	9f ef       	ldi	r25, 0xFF	; 255
    1b88:	90 93 ac 00 	sts	0x00AC, r25	; 0x8000ac <xNextTaskUnblockTime+0x1>
    1b8c:	80 93 ab 00 	sts	0x00AB, r24	; 0x8000ab <xNextTaskUnblockTime>
    1b90:	41 c0       	rjmp	.+130    	; 0x1c14 <xTaskIncrementTick+0x118>
    1b92:	e0 91 ca 00 	lds	r30, 0x00CA	; 0x8000ca <pxDelayedTaskList>
    1b96:	f0 91 cb 00 	lds	r31, 0x00CB	; 0x8000cb <pxDelayedTaskList+0x1>
    1b9a:	05 80       	ldd	r0, Z+5	; 0x05
    1b9c:	f6 81       	ldd	r31, Z+6	; 0x06
    1b9e:	e0 2d       	mov	r30, r0
    1ba0:	c6 81       	ldd	r28, Z+6	; 0x06
    1ba2:	d7 81       	ldd	r29, Z+7	; 0x07
    1ba4:	8a 81       	ldd	r24, Y+2	; 0x02
    1ba6:	9b 81       	ldd	r25, Y+3	; 0x03
    1ba8:	e8 16       	cp	r14, r24
    1baa:	f9 06       	cpc	r15, r25
    1bac:	28 f4       	brcc	.+10     	; 0x1bb8 <xTaskIncrementTick+0xbc>
    1bae:	90 93 ac 00 	sts	0x00AC, r25	; 0x8000ac <xNextTaskUnblockTime+0x1>
    1bb2:	80 93 ab 00 	sts	0x00AB, r24	; 0x8000ab <xNextTaskUnblockTime>
    1bb6:	2e c0       	rjmp	.+92     	; 0x1c14 <xTaskIncrementTick+0x118>
    1bb8:	8e 01       	movw	r16, r28
    1bba:	0e 5f       	subi	r16, 0xFE	; 254
    1bbc:	1f 4f       	sbci	r17, 0xFF	; 255
    1bbe:	c8 01       	movw	r24, r16
    1bc0:	0e 94 92 06 	call	0xd24	; 0xd24 <uxListRemove>
    1bc4:	8c 89       	ldd	r24, Y+20	; 0x14
    1bc6:	9d 89       	ldd	r25, Y+21	; 0x15
    1bc8:	89 2b       	or	r24, r25
    1bca:	21 f0       	breq	.+8      	; 0x1bd4 <xTaskIncrementTick+0xd8>
    1bcc:	ce 01       	movw	r24, r28
    1bce:	0c 96       	adiw	r24, 0x0c	; 12
    1bd0:	0e 94 92 06 	call	0xd24	; 0xd24 <uxListRemove>
    1bd4:	8e 89       	ldd	r24, Y+22	; 0x16
    1bd6:	90 91 b2 00 	lds	r25, 0x00B2	; 0x8000b2 <uxTopReadyPriority>
    1bda:	98 17       	cp	r25, r24
    1bdc:	10 f4       	brcc	.+4      	; 0x1be2 <xTaskIncrementTick+0xe6>
    1bde:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <uxTopReadyPriority>
    1be2:	90 e0       	ldi	r25, 0x00	; 0
    1be4:	9c 01       	movw	r18, r24
    1be6:	22 0f       	add	r18, r18
    1be8:	33 1f       	adc	r19, r19
    1bea:	22 0f       	add	r18, r18
    1bec:	33 1f       	adc	r19, r19
    1bee:	22 0f       	add	r18, r18
    1bf0:	33 1f       	adc	r19, r19
    1bf2:	82 0f       	add	r24, r18
    1bf4:	93 1f       	adc	r25, r19
    1bf6:	b8 01       	movw	r22, r16
    1bf8:	82 52       	subi	r24, 0x22	; 34
    1bfa:	9f 4f       	sbci	r25, 0xFF	; 255
    1bfc:	0e 94 40 06 	call	0xc80	; 0xc80 <vListInsertEnd>
    1c00:	9e 89       	ldd	r25, Y+22	; 0x16
    1c02:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <pxCurrentTCB>
    1c06:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    1c0a:	86 89       	ldd	r24, Z+22	; 0x16
    1c0c:	98 17       	cp	r25, r24
    1c0e:	08 f0       	brcs	.+2      	; 0x1c12 <xTaskIncrementTick+0x116>
    1c10:	ae cf       	rjmp	.-164    	; 0x1b6e <xTaskIncrementTick+0x72>
    1c12:	b1 cf       	rjmp	.-158    	; 0x1b76 <xTaskIncrementTick+0x7a>
    1c14:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <pxCurrentTCB>
    1c18:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    1c1c:	86 89       	ldd	r24, Z+22	; 0x16
    1c1e:	90 e0       	ldi	r25, 0x00	; 0
    1c20:	fc 01       	movw	r30, r24
    1c22:	ee 0f       	add	r30, r30
    1c24:	ff 1f       	adc	r31, r31
    1c26:	ee 0f       	add	r30, r30
    1c28:	ff 1f       	adc	r31, r31
    1c2a:	ee 0f       	add	r30, r30
    1c2c:	ff 1f       	adc	r31, r31
    1c2e:	8e 0f       	add	r24, r30
    1c30:	9f 1f       	adc	r25, r31
    1c32:	fc 01       	movw	r30, r24
    1c34:	e2 52       	subi	r30, 0x22	; 34
    1c36:	ff 4f       	sbci	r31, 0xFF	; 255
    1c38:	80 81       	ld	r24, Z
    1c3a:	82 30       	cpi	r24, 0x02	; 2
    1c3c:	40 f4       	brcc	.+16     	; 0x1c4e <xTaskIncrementTick+0x152>
    1c3e:	09 c0       	rjmp	.+18     	; 0x1c52 <xTaskIncrementTick+0x156>
    1c40:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <uxPendedTicks>
    1c44:	8f 5f       	subi	r24, 0xFF	; 255
    1c46:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <uxPendedTicks>
    1c4a:	d1 2c       	mov	r13, r1
    1c4c:	02 c0       	rjmp	.+4      	; 0x1c52 <xTaskIncrementTick+0x156>
    1c4e:	dd 24       	eor	r13, r13
    1c50:	d3 94       	inc	r13
    1c52:	80 91 af 00 	lds	r24, 0x00AF	; 0x8000af <xYieldPending>
    1c56:	88 23       	and	r24, r24
    1c58:	11 f0       	breq	.+4      	; 0x1c5e <xTaskIncrementTick+0x162>
    1c5a:	dd 24       	eor	r13, r13
    1c5c:	d3 94       	inc	r13
    1c5e:	8d 2d       	mov	r24, r13
    1c60:	df 91       	pop	r29
    1c62:	cf 91       	pop	r28
    1c64:	1f 91       	pop	r17
    1c66:	0f 91       	pop	r16
    1c68:	ff 90       	pop	r15
    1c6a:	ef 90       	pop	r14
    1c6c:	df 90       	pop	r13
    1c6e:	08 95       	ret

00001c70 <xTaskResumeAll>:
    1c70:	0f 93       	push	r16
    1c72:	1f 93       	push	r17
    1c74:	cf 93       	push	r28
    1c76:	df 93       	push	r29
    1c78:	0f b6       	in	r0, 0x3f	; 63
    1c7a:	f8 94       	cli
    1c7c:	0f 92       	push	r0
    1c7e:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <uxSchedulerSuspended>
    1c82:	81 50       	subi	r24, 0x01	; 1
    1c84:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <uxSchedulerSuspended>
    1c88:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <uxSchedulerSuspended>
    1c8c:	81 11       	cpse	r24, r1
    1c8e:	58 c0       	rjmp	.+176    	; 0x1d40 <xTaskResumeAll+0xd0>
    1c90:	80 91 b5 00 	lds	r24, 0x00B5	; 0x8000b5 <uxCurrentNumberOfTasks>
    1c94:	81 11       	cpse	r24, r1
    1c96:	33 c0       	rjmp	.+102    	; 0x1cfe <xTaskResumeAll+0x8e>
    1c98:	56 c0       	rjmp	.+172    	; 0x1d46 <xTaskResumeAll+0xd6>
    1c9a:	e0 91 c4 00 	lds	r30, 0x00C4	; 0x8000c4 <xPendingReadyList+0x5>
    1c9e:	f0 91 c5 00 	lds	r31, 0x00C5	; 0x8000c5 <xPendingReadyList+0x6>
    1ca2:	c6 81       	ldd	r28, Z+6	; 0x06
    1ca4:	d7 81       	ldd	r29, Z+7	; 0x07
    1ca6:	ce 01       	movw	r24, r28
    1ca8:	0c 96       	adiw	r24, 0x0c	; 12
    1caa:	0e 94 92 06 	call	0xd24	; 0xd24 <uxListRemove>
    1cae:	8e 01       	movw	r16, r28
    1cb0:	0e 5f       	subi	r16, 0xFE	; 254
    1cb2:	1f 4f       	sbci	r17, 0xFF	; 255
    1cb4:	c8 01       	movw	r24, r16
    1cb6:	0e 94 92 06 	call	0xd24	; 0xd24 <uxListRemove>
    1cba:	8e 89       	ldd	r24, Y+22	; 0x16
    1cbc:	90 91 b2 00 	lds	r25, 0x00B2	; 0x8000b2 <uxTopReadyPriority>
    1cc0:	98 17       	cp	r25, r24
    1cc2:	10 f4       	brcc	.+4      	; 0x1cc8 <xTaskResumeAll+0x58>
    1cc4:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <uxTopReadyPriority>
    1cc8:	90 e0       	ldi	r25, 0x00	; 0
    1cca:	9c 01       	movw	r18, r24
    1ccc:	22 0f       	add	r18, r18
    1cce:	33 1f       	adc	r19, r19
    1cd0:	22 0f       	add	r18, r18
    1cd2:	33 1f       	adc	r19, r19
    1cd4:	22 0f       	add	r18, r18
    1cd6:	33 1f       	adc	r19, r19
    1cd8:	82 0f       	add	r24, r18
    1cda:	93 1f       	adc	r25, r19
    1cdc:	b8 01       	movw	r22, r16
    1cde:	82 52       	subi	r24, 0x22	; 34
    1ce0:	9f 4f       	sbci	r25, 0xFF	; 255
    1ce2:	0e 94 40 06 	call	0xc80	; 0xc80 <vListInsertEnd>
    1ce6:	9e 89       	ldd	r25, Y+22	; 0x16
    1ce8:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <pxCurrentTCB>
    1cec:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    1cf0:	86 89       	ldd	r24, Z+22	; 0x16
    1cf2:	98 17       	cp	r25, r24
    1cf4:	30 f0       	brcs	.+12     	; 0x1d02 <xTaskResumeAll+0x92>
    1cf6:	81 e0       	ldi	r24, 0x01	; 1
    1cf8:	80 93 af 00 	sts	0x00AF, r24	; 0x8000af <xYieldPending>
    1cfc:	02 c0       	rjmp	.+4      	; 0x1d02 <xTaskResumeAll+0x92>
    1cfe:	c0 e0       	ldi	r28, 0x00	; 0
    1d00:	d0 e0       	ldi	r29, 0x00	; 0
    1d02:	80 91 bf 00 	lds	r24, 0x00BF	; 0x8000bf <xPendingReadyList>
    1d06:	81 11       	cpse	r24, r1
    1d08:	c8 cf       	rjmp	.-112    	; 0x1c9a <xTaskResumeAll+0x2a>
    1d0a:	cd 2b       	or	r28, r29
    1d0c:	11 f0       	breq	.+4      	; 0x1d12 <xTaskResumeAll+0xa2>
    1d0e:	0e 94 3f 0b 	call	0x167e	; 0x167e <prvResetNextTaskUnblockTime>
    1d12:	c0 91 b0 00 	lds	r28, 0x00B0	; 0x8000b0 <uxPendedTicks>
    1d16:	cc 23       	and	r28, r28
    1d18:	59 f0       	breq	.+22     	; 0x1d30 <xTaskResumeAll+0xc0>
    1d1a:	0e 94 7e 0d 	call	0x1afc	; 0x1afc <xTaskIncrementTick>
    1d1e:	88 23       	and	r24, r24
    1d20:	19 f0       	breq	.+6      	; 0x1d28 <xTaskResumeAll+0xb8>
    1d22:	81 e0       	ldi	r24, 0x01	; 1
    1d24:	80 93 af 00 	sts	0x00AF, r24	; 0x8000af <xYieldPending>
    1d28:	c1 50       	subi	r28, 0x01	; 1
    1d2a:	b9 f7       	brne	.-18     	; 0x1d1a <xTaskResumeAll+0xaa>
    1d2c:	10 92 b0 00 	sts	0x00B0, r1	; 0x8000b0 <uxPendedTicks>
    1d30:	80 91 af 00 	lds	r24, 0x00AF	; 0x8000af <xYieldPending>
    1d34:	88 23       	and	r24, r24
    1d36:	31 f0       	breq	.+12     	; 0x1d44 <xTaskResumeAll+0xd4>
    1d38:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vPortYield>
    1d3c:	81 e0       	ldi	r24, 0x01	; 1
    1d3e:	03 c0       	rjmp	.+6      	; 0x1d46 <xTaskResumeAll+0xd6>
    1d40:	80 e0       	ldi	r24, 0x00	; 0
    1d42:	01 c0       	rjmp	.+2      	; 0x1d46 <xTaskResumeAll+0xd6>
    1d44:	80 e0       	ldi	r24, 0x00	; 0
    1d46:	0f 90       	pop	r0
    1d48:	0f be       	out	0x3f, r0	; 63
    1d4a:	df 91       	pop	r29
    1d4c:	cf 91       	pop	r28
    1d4e:	1f 91       	pop	r17
    1d50:	0f 91       	pop	r16
    1d52:	08 95       	ret

00001d54 <vTaskDelay>:
    1d54:	cf 93       	push	r28
    1d56:	df 93       	push	r29
    1d58:	ec 01       	movw	r28, r24
    1d5a:	89 2b       	or	r24, r25
    1d5c:	49 f0       	breq	.+18     	; 0x1d70 <vTaskDelay+0x1c>
    1d5e:	0e 94 78 0d 	call	0x1af0	; 0x1af0 <vTaskSuspendAll>
    1d62:	60 e0       	ldi	r22, 0x00	; 0
    1d64:	ce 01       	movw	r24, r28
    1d66:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <prvAddCurrentTaskToDelayedList>
    1d6a:	0e 94 38 0e 	call	0x1c70	; 0x1c70 <xTaskResumeAll>
    1d6e:	01 c0       	rjmp	.+2      	; 0x1d72 <vTaskDelay+0x1e>
    1d70:	80 e0       	ldi	r24, 0x00	; 0
    1d72:	81 11       	cpse	r24, r1
    1d74:	02 c0       	rjmp	.+4      	; 0x1d7a <vTaskDelay+0x26>
    1d76:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vPortYield>
    1d7a:	df 91       	pop	r29
    1d7c:	cf 91       	pop	r28
    1d7e:	08 95       	ret

00001d80 <vTaskSwitchContext>:
    1d80:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <uxSchedulerSuspended>
    1d84:	88 23       	and	r24, r24
    1d86:	21 f0       	breq	.+8      	; 0x1d90 <vTaskSwitchContext+0x10>
    1d88:	81 e0       	ldi	r24, 0x01	; 1
    1d8a:	80 93 af 00 	sts	0x00AF, r24	; 0x8000af <xYieldPending>
    1d8e:	08 95       	ret
    1d90:	10 92 af 00 	sts	0x00AF, r1	; 0x8000af <xYieldPending>
    1d94:	20 91 b2 00 	lds	r18, 0x00B2	; 0x8000b2 <uxTopReadyPriority>
    1d98:	01 c0       	rjmp	.+2      	; 0x1d9c <vTaskSwitchContext+0x1c>
    1d9a:	21 50       	subi	r18, 0x01	; 1
    1d9c:	82 2f       	mov	r24, r18
    1d9e:	90 e0       	ldi	r25, 0x00	; 0
    1da0:	fc 01       	movw	r30, r24
    1da2:	ee 0f       	add	r30, r30
    1da4:	ff 1f       	adc	r31, r31
    1da6:	ee 0f       	add	r30, r30
    1da8:	ff 1f       	adc	r31, r31
    1daa:	ee 0f       	add	r30, r30
    1dac:	ff 1f       	adc	r31, r31
    1dae:	e8 0f       	add	r30, r24
    1db0:	f9 1f       	adc	r31, r25
    1db2:	e2 52       	subi	r30, 0x22	; 34
    1db4:	ff 4f       	sbci	r31, 0xFF	; 255
    1db6:	30 81       	ld	r19, Z
    1db8:	33 23       	and	r19, r19
    1dba:	79 f3       	breq	.-34     	; 0x1d9a <vTaskSwitchContext+0x1a>
    1dbc:	ac 01       	movw	r20, r24
    1dbe:	44 0f       	add	r20, r20
    1dc0:	55 1f       	adc	r21, r21
    1dc2:	44 0f       	add	r20, r20
    1dc4:	55 1f       	adc	r21, r21
    1dc6:	44 0f       	add	r20, r20
    1dc8:	55 1f       	adc	r21, r21
    1dca:	48 0f       	add	r20, r24
    1dcc:	59 1f       	adc	r21, r25
    1dce:	df 01       	movw	r26, r30
    1dd0:	01 80       	ldd	r0, Z+1	; 0x01
    1dd2:	f2 81       	ldd	r31, Z+2	; 0x02
    1dd4:	e0 2d       	mov	r30, r0
    1dd6:	02 80       	ldd	r0, Z+2	; 0x02
    1dd8:	f3 81       	ldd	r31, Z+3	; 0x03
    1dda:	e0 2d       	mov	r30, r0
    1ddc:	12 96       	adiw	r26, 0x02	; 2
    1dde:	fc 93       	st	X, r31
    1de0:	ee 93       	st	-X, r30
    1de2:	11 97       	sbiw	r26, 0x01	; 1
    1de4:	4f 51       	subi	r20, 0x1F	; 31
    1de6:	5f 4f       	sbci	r21, 0xFF	; 255
    1de8:	e4 17       	cp	r30, r20
    1dea:	f5 07       	cpc	r31, r21
    1dec:	29 f4       	brne	.+10     	; 0x1df8 <vTaskSwitchContext+0x78>
    1dee:	42 81       	ldd	r20, Z+2	; 0x02
    1df0:	53 81       	ldd	r21, Z+3	; 0x03
    1df2:	fd 01       	movw	r30, r26
    1df4:	52 83       	std	Z+2, r21	; 0x02
    1df6:	41 83       	std	Z+1, r20	; 0x01
    1df8:	fc 01       	movw	r30, r24
    1dfa:	ee 0f       	add	r30, r30
    1dfc:	ff 1f       	adc	r31, r31
    1dfe:	ee 0f       	add	r30, r30
    1e00:	ff 1f       	adc	r31, r31
    1e02:	ee 0f       	add	r30, r30
    1e04:	ff 1f       	adc	r31, r31
    1e06:	8e 0f       	add	r24, r30
    1e08:	9f 1f       	adc	r25, r31
    1e0a:	fc 01       	movw	r30, r24
    1e0c:	e2 52       	subi	r30, 0x22	; 34
    1e0e:	ff 4f       	sbci	r31, 0xFF	; 255
    1e10:	01 80       	ldd	r0, Z+1	; 0x01
    1e12:	f2 81       	ldd	r31, Z+2	; 0x02
    1e14:	e0 2d       	mov	r30, r0
    1e16:	86 81       	ldd	r24, Z+6	; 0x06
    1e18:	97 81       	ldd	r25, Z+7	; 0x07
    1e1a:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <pxCurrentTCB+0x1>
    1e1e:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <pxCurrentTCB>
    1e22:	20 93 b2 00 	sts	0x00B2, r18	; 0x8000b2 <uxTopReadyPriority>
    1e26:	08 95       	ret

00001e28 <vTaskSuspend>:
    1e28:	0f 93       	push	r16
    1e2a:	1f 93       	push	r17
    1e2c:	cf 93       	push	r28
    1e2e:	df 93       	push	r29
    1e30:	ec 01       	movw	r28, r24
    1e32:	0f b6       	in	r0, 0x3f	; 63
    1e34:	f8 94       	cli
    1e36:	0f 92       	push	r0
    1e38:	89 2b       	or	r24, r25
    1e3a:	21 f4       	brne	.+8      	; 0x1e44 <vTaskSuspend+0x1c>
    1e3c:	c0 91 02 01 	lds	r28, 0x0102	; 0x800102 <pxCurrentTCB>
    1e40:	d0 91 03 01 	lds	r29, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    1e44:	8e 01       	movw	r16, r28
    1e46:	0e 5f       	subi	r16, 0xFE	; 254
    1e48:	1f 4f       	sbci	r17, 0xFF	; 255
    1e4a:	c8 01       	movw	r24, r16
    1e4c:	0e 94 92 06 	call	0xd24	; 0xd24 <uxListRemove>
    1e50:	8c 89       	ldd	r24, Y+20	; 0x14
    1e52:	9d 89       	ldd	r25, Y+21	; 0x15
    1e54:	89 2b       	or	r24, r25
    1e56:	21 f0       	breq	.+8      	; 0x1e60 <vTaskSuspend+0x38>
    1e58:	ce 01       	movw	r24, r28
    1e5a:	0c 96       	adiw	r24, 0x0c	; 12
    1e5c:	0e 94 92 06 	call	0xd24	; 0xd24 <uxListRemove>
    1e60:	b8 01       	movw	r22, r16
    1e62:	86 eb       	ldi	r24, 0xB6	; 182
    1e64:	90 e0       	ldi	r25, 0x00	; 0
    1e66:	0e 94 40 06 	call	0xc80	; 0xc80 <vListInsertEnd>
    1e6a:	0f 90       	pop	r0
    1e6c:	0f be       	out	0x3f, r0	; 63
    1e6e:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <xSchedulerRunning>
    1e72:	88 23       	and	r24, r24
    1e74:	39 f0       	breq	.+14     	; 0x1e84 <vTaskSuspend+0x5c>
    1e76:	0f b6       	in	r0, 0x3f	; 63
    1e78:	f8 94       	cli
    1e7a:	0f 92       	push	r0
    1e7c:	0e 94 3f 0b 	call	0x167e	; 0x167e <prvResetNextTaskUnblockTime>
    1e80:	0f 90       	pop	r0
    1e82:	0f be       	out	0x3f, r0	; 63
    1e84:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <pxCurrentTCB>
    1e88:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    1e8c:	c8 17       	cp	r28, r24
    1e8e:	d9 07       	cpc	r29, r25
    1e90:	a1 f4       	brne	.+40     	; 0x1eba <vTaskSuspend+0x92>
    1e92:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <xSchedulerRunning>
    1e96:	88 23       	and	r24, r24
    1e98:	19 f0       	breq	.+6      	; 0x1ea0 <vTaskSuspend+0x78>
    1e9a:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vPortYield>
    1e9e:	0d c0       	rjmp	.+26     	; 0x1eba <vTaskSuspend+0x92>
    1ea0:	90 91 b6 00 	lds	r25, 0x00B6	; 0x8000b6 <xSuspendedTaskList>
    1ea4:	80 91 b5 00 	lds	r24, 0x00B5	; 0x8000b5 <uxCurrentNumberOfTasks>
    1ea8:	98 13       	cpse	r25, r24
    1eaa:	05 c0       	rjmp	.+10     	; 0x1eb6 <vTaskSuspend+0x8e>
    1eac:	10 92 03 01 	sts	0x0103, r1	; 0x800103 <pxCurrentTCB+0x1>
    1eb0:	10 92 02 01 	sts	0x0102, r1	; 0x800102 <pxCurrentTCB>
    1eb4:	02 c0       	rjmp	.+4      	; 0x1eba <vTaskSuspend+0x92>
    1eb6:	0e 94 c0 0e 	call	0x1d80	; 0x1d80 <vTaskSwitchContext>
    1eba:	df 91       	pop	r29
    1ebc:	cf 91       	pop	r28
    1ebe:	1f 91       	pop	r17
    1ec0:	0f 91       	pop	r16
    1ec2:	08 95       	ret

00001ec4 <vTaskPlaceOnEventList>:
    1ec4:	cf 93       	push	r28
    1ec6:	df 93       	push	r29
    1ec8:	eb 01       	movw	r28, r22
    1eca:	60 91 02 01 	lds	r22, 0x0102	; 0x800102 <pxCurrentTCB>
    1ece:	70 91 03 01 	lds	r23, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    1ed2:	64 5f       	subi	r22, 0xF4	; 244
    1ed4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ed6:	0e 94 61 06 	call	0xcc2	; 0xcc2 <vListInsert>
    1eda:	61 e0       	ldi	r22, 0x01	; 1
    1edc:	ce 01       	movw	r24, r28
    1ede:	0e 94 60 0c 	call	0x18c0	; 0x18c0 <prvAddCurrentTaskToDelayedList>
    1ee2:	df 91       	pop	r29
    1ee4:	cf 91       	pop	r28
    1ee6:	08 95       	ret

00001ee8 <xTaskRemoveFromEventList>:
    1ee8:	0f 93       	push	r16
    1eea:	1f 93       	push	r17
    1eec:	cf 93       	push	r28
    1eee:	df 93       	push	r29
    1ef0:	dc 01       	movw	r26, r24
    1ef2:	15 96       	adiw	r26, 0x05	; 5
    1ef4:	ed 91       	ld	r30, X+
    1ef6:	fc 91       	ld	r31, X
    1ef8:	16 97       	sbiw	r26, 0x06	; 6
    1efa:	c6 81       	ldd	r28, Z+6	; 0x06
    1efc:	d7 81       	ldd	r29, Z+7	; 0x07
    1efe:	8e 01       	movw	r16, r28
    1f00:	04 5f       	subi	r16, 0xF4	; 244
    1f02:	1f 4f       	sbci	r17, 0xFF	; 255
    1f04:	c8 01       	movw	r24, r16
    1f06:	0e 94 92 06 	call	0xd24	; 0xd24 <uxListRemove>
    1f0a:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <uxSchedulerSuspended>
    1f0e:	81 11       	cpse	r24, r1
    1f10:	1c c0       	rjmp	.+56     	; 0x1f4a <xTaskRemoveFromEventList+0x62>
    1f12:	0a 50       	subi	r16, 0x0A	; 10
    1f14:	11 09       	sbc	r17, r1
    1f16:	c8 01       	movw	r24, r16
    1f18:	0e 94 92 06 	call	0xd24	; 0xd24 <uxListRemove>
    1f1c:	8e 89       	ldd	r24, Y+22	; 0x16
    1f1e:	90 91 b2 00 	lds	r25, 0x00B2	; 0x8000b2 <uxTopReadyPriority>
    1f22:	98 17       	cp	r25, r24
    1f24:	10 f4       	brcc	.+4      	; 0x1f2a <xTaskRemoveFromEventList+0x42>
    1f26:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <uxTopReadyPriority>
    1f2a:	90 e0       	ldi	r25, 0x00	; 0
    1f2c:	9c 01       	movw	r18, r24
    1f2e:	22 0f       	add	r18, r18
    1f30:	33 1f       	adc	r19, r19
    1f32:	22 0f       	add	r18, r18
    1f34:	33 1f       	adc	r19, r19
    1f36:	22 0f       	add	r18, r18
    1f38:	33 1f       	adc	r19, r19
    1f3a:	82 0f       	add	r24, r18
    1f3c:	93 1f       	adc	r25, r19
    1f3e:	b8 01       	movw	r22, r16
    1f40:	82 52       	subi	r24, 0x22	; 34
    1f42:	9f 4f       	sbci	r25, 0xFF	; 255
    1f44:	0e 94 40 06 	call	0xc80	; 0xc80 <vListInsertEnd>
    1f48:	05 c0       	rjmp	.+10     	; 0x1f54 <xTaskRemoveFromEventList+0x6c>
    1f4a:	b8 01       	movw	r22, r16
    1f4c:	8f eb       	ldi	r24, 0xBF	; 191
    1f4e:	90 e0       	ldi	r25, 0x00	; 0
    1f50:	0e 94 40 06 	call	0xc80	; 0xc80 <vListInsertEnd>
    1f54:	9e 89       	ldd	r25, Y+22	; 0x16
    1f56:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <pxCurrentTCB>
    1f5a:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    1f5e:	86 89       	ldd	r24, Z+22	; 0x16
    1f60:	89 17       	cp	r24, r25
    1f62:	20 f4       	brcc	.+8      	; 0x1f6c <xTaskRemoveFromEventList+0x84>
    1f64:	81 e0       	ldi	r24, 0x01	; 1
    1f66:	80 93 af 00 	sts	0x00AF, r24	; 0x8000af <xYieldPending>
    1f6a:	01 c0       	rjmp	.+2      	; 0x1f6e <xTaskRemoveFromEventList+0x86>
    1f6c:	80 e0       	ldi	r24, 0x00	; 0
    1f6e:	df 91       	pop	r29
    1f70:	cf 91       	pop	r28
    1f72:	1f 91       	pop	r17
    1f74:	0f 91       	pop	r16
    1f76:	08 95       	ret

00001f78 <vTaskSetTimeOutState>:
    1f78:	20 91 ae 00 	lds	r18, 0x00AE	; 0x8000ae <xNumOfOverflows>
    1f7c:	fc 01       	movw	r30, r24
    1f7e:	20 83       	st	Z, r18
    1f80:	20 91 b3 00 	lds	r18, 0x00B3	; 0x8000b3 <xTickCount>
    1f84:	30 91 b4 00 	lds	r19, 0x00B4	; 0x8000b4 <xTickCount+0x1>
    1f88:	32 83       	std	Z+2, r19	; 0x02
    1f8a:	21 83       	std	Z+1, r18	; 0x01
    1f8c:	08 95       	ret

00001f8e <xTaskCheckForTimeOut>:
    1f8e:	0f b6       	in	r0, 0x3f	; 63
    1f90:	f8 94       	cli
    1f92:	0f 92       	push	r0
    1f94:	40 91 b3 00 	lds	r20, 0x00B3	; 0x8000b3 <xTickCount>
    1f98:	50 91 b4 00 	lds	r21, 0x00B4	; 0x8000b4 <xTickCount+0x1>
    1f9c:	db 01       	movw	r26, r22
    1f9e:	2d 91       	ld	r18, X+
    1fa0:	3c 91       	ld	r19, X
    1fa2:	2f 3f       	cpi	r18, 0xFF	; 255
    1fa4:	bf ef       	ldi	r27, 0xFF	; 255
    1fa6:	3b 07       	cpc	r19, r27
    1fa8:	19 f1       	breq	.+70     	; 0x1ff0 <xTaskCheckForTimeOut+0x62>
    1faa:	dc 01       	movw	r26, r24
    1fac:	fc 91       	ld	r31, X
    1fae:	e0 91 ae 00 	lds	r30, 0x00AE	; 0x8000ae <xNumOfOverflows>
    1fb2:	fe 17       	cp	r31, r30
    1fb4:	39 f0       	breq	.+14     	; 0x1fc4 <xTaskCheckForTimeOut+0x36>
    1fb6:	11 96       	adiw	r26, 0x01	; 1
    1fb8:	ed 91       	ld	r30, X+
    1fba:	fc 91       	ld	r31, X
    1fbc:	12 97       	sbiw	r26, 0x02	; 2
    1fbe:	4e 17       	cp	r20, r30
    1fc0:	5f 07       	cpc	r21, r31
    1fc2:	c0 f4       	brcc	.+48     	; 0x1ff4 <xTaskCheckForTimeOut+0x66>
    1fc4:	dc 01       	movw	r26, r24
    1fc6:	11 96       	adiw	r26, 0x01	; 1
    1fc8:	ed 91       	ld	r30, X+
    1fca:	fc 91       	ld	r31, X
    1fcc:	12 97       	sbiw	r26, 0x02	; 2
    1fce:	da 01       	movw	r26, r20
    1fd0:	ae 1b       	sub	r26, r30
    1fd2:	bf 0b       	sbc	r27, r31
    1fd4:	a2 17       	cp	r26, r18
    1fd6:	b3 07       	cpc	r27, r19
    1fd8:	78 f4       	brcc	.+30     	; 0x1ff8 <xTaskCheckForTimeOut+0x6a>
    1fda:	db 01       	movw	r26, r22
    1fdc:	e4 1b       	sub	r30, r20
    1fde:	f5 0b       	sbc	r31, r21
    1fe0:	2e 0f       	add	r18, r30
    1fe2:	3f 1f       	adc	r19, r31
    1fe4:	2d 93       	st	X+, r18
    1fe6:	3c 93       	st	X, r19
    1fe8:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <vTaskSetTimeOutState>
    1fec:	80 e0       	ldi	r24, 0x00	; 0
    1fee:	05 c0       	rjmp	.+10     	; 0x1ffa <xTaskCheckForTimeOut+0x6c>
    1ff0:	80 e0       	ldi	r24, 0x00	; 0
    1ff2:	03 c0       	rjmp	.+6      	; 0x1ffa <xTaskCheckForTimeOut+0x6c>
    1ff4:	81 e0       	ldi	r24, 0x01	; 1
    1ff6:	01 c0       	rjmp	.+2      	; 0x1ffa <xTaskCheckForTimeOut+0x6c>
    1ff8:	81 e0       	ldi	r24, 0x01	; 1
    1ffa:	0f 90       	pop	r0
    1ffc:	0f be       	out	0x3f, r0	; 63
    1ffe:	08 95       	ret

00002000 <vTaskMissedYield>:
    2000:	81 e0       	ldi	r24, 0x01	; 1
    2002:	80 93 af 00 	sts	0x00AF, r24	; 0x8000af <xYieldPending>
    2006:	08 95       	ret

00002008 <vTaskPriorityInherit>:
    2008:	0f 93       	push	r16
    200a:	1f 93       	push	r17
    200c:	cf 93       	push	r28
    200e:	df 93       	push	r29
    2010:	fc 01       	movw	r30, r24
    2012:	89 2b       	or	r24, r25
    2014:	09 f4       	brne	.+2      	; 0x2018 <vTaskPriorityInherit+0x10>
    2016:	55 c0       	rjmp	.+170    	; 0x20c2 <vTaskPriorityInherit+0xba>
    2018:	26 89       	ldd	r18, Z+22	; 0x16
    201a:	a0 91 02 01 	lds	r26, 0x0102	; 0x800102 <pxCurrentTCB>
    201e:	b0 91 03 01 	lds	r27, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    2022:	56 96       	adiw	r26, 0x16	; 22
    2024:	8c 91       	ld	r24, X
    2026:	28 17       	cp	r18, r24
    2028:	08 f0       	brcs	.+2      	; 0x202c <vTaskPriorityInherit+0x24>
    202a:	4b c0       	rjmp	.+150    	; 0x20c2 <vTaskPriorityInherit+0xba>
    202c:	84 85       	ldd	r24, Z+12	; 0x0c
    202e:	95 85       	ldd	r25, Z+13	; 0x0d
    2030:	99 23       	and	r25, r25
    2032:	64 f0       	brlt	.+24     	; 0x204c <vTaskPriorityInherit+0x44>
    2034:	a0 91 02 01 	lds	r26, 0x0102	; 0x800102 <pxCurrentTCB>
    2038:	b0 91 03 01 	lds	r27, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    203c:	56 96       	adiw	r26, 0x16	; 22
    203e:	3c 91       	ld	r19, X
    2040:	84 e0       	ldi	r24, 0x04	; 4
    2042:	90 e0       	ldi	r25, 0x00	; 0
    2044:	83 1b       	sub	r24, r19
    2046:	91 09       	sbc	r25, r1
    2048:	95 87       	std	Z+13, r25	; 0x0d
    204a:	84 87       	std	Z+12, r24	; 0x0c
    204c:	82 85       	ldd	r24, Z+10	; 0x0a
    204e:	93 85       	ldd	r25, Z+11	; 0x0b
    2050:	30 e0       	ldi	r19, 0x00	; 0
    2052:	a9 01       	movw	r20, r18
    2054:	44 0f       	add	r20, r20
    2056:	55 1f       	adc	r21, r21
    2058:	44 0f       	add	r20, r20
    205a:	55 1f       	adc	r21, r21
    205c:	44 0f       	add	r20, r20
    205e:	55 1f       	adc	r21, r21
    2060:	24 0f       	add	r18, r20
    2062:	35 1f       	adc	r19, r21
    2064:	22 52       	subi	r18, 0x22	; 34
    2066:	3f 4f       	sbci	r19, 0xFF	; 255
    2068:	82 17       	cp	r24, r18
    206a:	93 07       	cpc	r25, r19
    206c:	19 f5       	brne	.+70     	; 0x20b4 <vTaskPriorityInherit+0xac>
    206e:	8f 01       	movw	r16, r30
    2070:	ef 01       	movw	r28, r30
    2072:	22 96       	adiw	r28, 0x02	; 2
    2074:	ce 01       	movw	r24, r28
    2076:	0e 94 92 06 	call	0xd24	; 0xd24 <uxListRemove>
    207a:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <pxCurrentTCB>
    207e:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    2082:	86 89       	ldd	r24, Z+22	; 0x16
    2084:	f8 01       	movw	r30, r16
    2086:	86 8b       	std	Z+22, r24	; 0x16
    2088:	90 91 b2 00 	lds	r25, 0x00B2	; 0x8000b2 <uxTopReadyPriority>
    208c:	98 17       	cp	r25, r24
    208e:	10 f4       	brcc	.+4      	; 0x2094 <vTaskPriorityInherit+0x8c>
    2090:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <uxTopReadyPriority>
    2094:	90 e0       	ldi	r25, 0x00	; 0
    2096:	9c 01       	movw	r18, r24
    2098:	22 0f       	add	r18, r18
    209a:	33 1f       	adc	r19, r19
    209c:	22 0f       	add	r18, r18
    209e:	33 1f       	adc	r19, r19
    20a0:	22 0f       	add	r18, r18
    20a2:	33 1f       	adc	r19, r19
    20a4:	82 0f       	add	r24, r18
    20a6:	93 1f       	adc	r25, r19
    20a8:	be 01       	movw	r22, r28
    20aa:	82 52       	subi	r24, 0x22	; 34
    20ac:	9f 4f       	sbci	r25, 0xFF	; 255
    20ae:	0e 94 40 06 	call	0xc80	; 0xc80 <vListInsertEnd>
    20b2:	07 c0       	rjmp	.+14     	; 0x20c2 <vTaskPriorityInherit+0xba>
    20b4:	a0 91 02 01 	lds	r26, 0x0102	; 0x800102 <pxCurrentTCB>
    20b8:	b0 91 03 01 	lds	r27, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    20bc:	56 96       	adiw	r26, 0x16	; 22
    20be:	8c 91       	ld	r24, X
    20c0:	86 8b       	std	Z+22, r24	; 0x16
    20c2:	df 91       	pop	r29
    20c4:	cf 91       	pop	r28
    20c6:	1f 91       	pop	r17
    20c8:	0f 91       	pop	r16
    20ca:	08 95       	ret

000020cc <xTaskPriorityDisinherit>:
    20cc:	0f 93       	push	r16
    20ce:	1f 93       	push	r17
    20d0:	cf 93       	push	r28
    20d2:	df 93       	push	r29
    20d4:	fc 01       	movw	r30, r24
    20d6:	89 2b       	or	r24, r25
    20d8:	79 f1       	breq	.+94     	; 0x2138 <xTaskPriorityDisinherit+0x6c>
    20da:	82 a1       	ldd	r24, Z+34	; 0x22
    20dc:	81 50       	subi	r24, 0x01	; 1
    20de:	82 a3       	std	Z+34, r24	; 0x22
    20e0:	26 89       	ldd	r18, Z+22	; 0x16
    20e2:	91 a1       	ldd	r25, Z+33	; 0x21
    20e4:	29 17       	cp	r18, r25
    20e6:	51 f1       	breq	.+84     	; 0x213c <xTaskPriorityDisinherit+0x70>
    20e8:	81 11       	cpse	r24, r1
    20ea:	2a c0       	rjmp	.+84     	; 0x2140 <xTaskPriorityDisinherit+0x74>
    20ec:	ef 01       	movw	r28, r30
    20ee:	8f 01       	movw	r16, r30
    20f0:	0e 5f       	subi	r16, 0xFE	; 254
    20f2:	1f 4f       	sbci	r17, 0xFF	; 255
    20f4:	c8 01       	movw	r24, r16
    20f6:	0e 94 92 06 	call	0xd24	; 0xd24 <uxListRemove>
    20fa:	89 a1       	ldd	r24, Y+33	; 0x21
    20fc:	8e 8b       	std	Y+22, r24	; 0x16
    20fe:	24 e0       	ldi	r18, 0x04	; 4
    2100:	30 e0       	ldi	r19, 0x00	; 0
    2102:	28 1b       	sub	r18, r24
    2104:	31 09       	sbc	r19, r1
    2106:	3d 87       	std	Y+13, r19	; 0x0d
    2108:	2c 87       	std	Y+12, r18	; 0x0c
    210a:	90 91 b2 00 	lds	r25, 0x00B2	; 0x8000b2 <uxTopReadyPriority>
    210e:	98 17       	cp	r25, r24
    2110:	10 f4       	brcc	.+4      	; 0x2116 <xTaskPriorityDisinherit+0x4a>
    2112:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <uxTopReadyPriority>
    2116:	90 e0       	ldi	r25, 0x00	; 0
    2118:	9c 01       	movw	r18, r24
    211a:	22 0f       	add	r18, r18
    211c:	33 1f       	adc	r19, r19
    211e:	22 0f       	add	r18, r18
    2120:	33 1f       	adc	r19, r19
    2122:	22 0f       	add	r18, r18
    2124:	33 1f       	adc	r19, r19
    2126:	82 0f       	add	r24, r18
    2128:	93 1f       	adc	r25, r19
    212a:	b8 01       	movw	r22, r16
    212c:	82 52       	subi	r24, 0x22	; 34
    212e:	9f 4f       	sbci	r25, 0xFF	; 255
    2130:	0e 94 40 06 	call	0xc80	; 0xc80 <vListInsertEnd>
    2134:	81 e0       	ldi	r24, 0x01	; 1
    2136:	05 c0       	rjmp	.+10     	; 0x2142 <xTaskPriorityDisinherit+0x76>
    2138:	80 e0       	ldi	r24, 0x00	; 0
    213a:	03 c0       	rjmp	.+6      	; 0x2142 <xTaskPriorityDisinherit+0x76>
    213c:	80 e0       	ldi	r24, 0x00	; 0
    213e:	01 c0       	rjmp	.+2      	; 0x2142 <xTaskPriorityDisinherit+0x76>
    2140:	80 e0       	ldi	r24, 0x00	; 0
    2142:	df 91       	pop	r29
    2144:	cf 91       	pop	r28
    2146:	1f 91       	pop	r17
    2148:	0f 91       	pop	r16
    214a:	08 95       	ret

0000214c <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    214c:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <pxCurrentTCB>
    2150:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    2154:	89 2b       	or	r24, r25
    2156:	39 f0       	breq	.+14     	; 0x2166 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2158:	e0 91 02 01 	lds	r30, 0x0102	; 0x800102 <pxCurrentTCB>
    215c:	f0 91 03 01 	lds	r31, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
    2160:	82 a1       	ldd	r24, Z+34	; 0x22
    2162:	8f 5f       	subi	r24, 0xFF	; 255
    2164:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2166:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <pxCurrentTCB>
    216a:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <pxCurrentTCB+0x1>
	}
    216e:	08 95       	ret

00002170 <__udivmodsi4>:
    2170:	a1 e2       	ldi	r26, 0x21	; 33
    2172:	1a 2e       	mov	r1, r26
    2174:	aa 1b       	sub	r26, r26
    2176:	bb 1b       	sub	r27, r27
    2178:	fd 01       	movw	r30, r26
    217a:	0d c0       	rjmp	.+26     	; 0x2196 <__udivmodsi4_ep>

0000217c <__udivmodsi4_loop>:
    217c:	aa 1f       	adc	r26, r26
    217e:	bb 1f       	adc	r27, r27
    2180:	ee 1f       	adc	r30, r30
    2182:	ff 1f       	adc	r31, r31
    2184:	a2 17       	cp	r26, r18
    2186:	b3 07       	cpc	r27, r19
    2188:	e4 07       	cpc	r30, r20
    218a:	f5 07       	cpc	r31, r21
    218c:	20 f0       	brcs	.+8      	; 0x2196 <__udivmodsi4_ep>
    218e:	a2 1b       	sub	r26, r18
    2190:	b3 0b       	sbc	r27, r19
    2192:	e4 0b       	sbc	r30, r20
    2194:	f5 0b       	sbc	r31, r21

00002196 <__udivmodsi4_ep>:
    2196:	66 1f       	adc	r22, r22
    2198:	77 1f       	adc	r23, r23
    219a:	88 1f       	adc	r24, r24
    219c:	99 1f       	adc	r25, r25
    219e:	1a 94       	dec	r1
    21a0:	69 f7       	brne	.-38     	; 0x217c <__udivmodsi4_loop>
    21a2:	60 95       	com	r22
    21a4:	70 95       	com	r23
    21a6:	80 95       	com	r24
    21a8:	90 95       	com	r25
    21aa:	9b 01       	movw	r18, r22
    21ac:	ac 01       	movw	r20, r24
    21ae:	bd 01       	movw	r22, r26
    21b0:	cf 01       	movw	r24, r30
    21b2:	08 95       	ret

000021b4 <__ashrdi3>:
    21b4:	97 fb       	bst	r25, 7
    21b6:	10 f8       	bld	r1, 0

000021b8 <__lshrdi3>:
    21b8:	16 94       	lsr	r1
    21ba:	00 08       	sbc	r0, r0
    21bc:	0f 93       	push	r16
    21be:	08 30       	cpi	r16, 0x08	; 8
    21c0:	98 f0       	brcs	.+38     	; 0x21e8 <__lshrdi3+0x30>
    21c2:	08 50       	subi	r16, 0x08	; 8
    21c4:	23 2f       	mov	r18, r19
    21c6:	34 2f       	mov	r19, r20
    21c8:	45 2f       	mov	r20, r21
    21ca:	56 2f       	mov	r21, r22
    21cc:	67 2f       	mov	r22, r23
    21ce:	78 2f       	mov	r23, r24
    21d0:	89 2f       	mov	r24, r25
    21d2:	90 2d       	mov	r25, r0
    21d4:	f4 cf       	rjmp	.-24     	; 0x21be <__lshrdi3+0x6>
    21d6:	05 94       	asr	r0
    21d8:	97 95       	ror	r25
    21da:	87 95       	ror	r24
    21dc:	77 95       	ror	r23
    21de:	67 95       	ror	r22
    21e0:	57 95       	ror	r21
    21e2:	47 95       	ror	r20
    21e4:	37 95       	ror	r19
    21e6:	27 95       	ror	r18
    21e8:	0a 95       	dec	r16
    21ea:	aa f7       	brpl	.-22     	; 0x21d6 <__lshrdi3+0x1e>
    21ec:	0f 91       	pop	r16
    21ee:	08 95       	ret

000021f0 <__adddi3_s8>:
    21f0:	00 24       	eor	r0, r0
    21f2:	a7 fd       	sbrc	r26, 7
    21f4:	00 94       	com	r0
    21f6:	2a 0f       	add	r18, r26
    21f8:	30 1d       	adc	r19, r0
    21fa:	40 1d       	adc	r20, r0
    21fc:	50 1d       	adc	r21, r0
    21fe:	60 1d       	adc	r22, r0
    2200:	70 1d       	adc	r23, r0
    2202:	80 1d       	adc	r24, r0
    2204:	90 1d       	adc	r25, r0
    2206:	08 95       	ret

00002208 <malloc>:
    2208:	0f 93       	push	r16
    220a:	1f 93       	push	r17
    220c:	cf 93       	push	r28
    220e:	df 93       	push	r29
    2210:	82 30       	cpi	r24, 0x02	; 2
    2212:	91 05       	cpc	r25, r1
    2214:	10 f4       	brcc	.+4      	; 0x221a <malloc+0x12>
    2216:	82 e0       	ldi	r24, 0x02	; 2
    2218:	90 e0       	ldi	r25, 0x00	; 0
    221a:	e0 91 24 01 	lds	r30, 0x0124	; 0x800124 <__flp>
    221e:	f0 91 25 01 	lds	r31, 0x0125	; 0x800125 <__flp+0x1>
    2222:	20 e0       	ldi	r18, 0x00	; 0
    2224:	30 e0       	ldi	r19, 0x00	; 0
    2226:	a0 e0       	ldi	r26, 0x00	; 0
    2228:	b0 e0       	ldi	r27, 0x00	; 0
    222a:	30 97       	sbiw	r30, 0x00	; 0
    222c:	19 f1       	breq	.+70     	; 0x2274 <malloc+0x6c>
    222e:	40 81       	ld	r20, Z
    2230:	51 81       	ldd	r21, Z+1	; 0x01
    2232:	02 81       	ldd	r16, Z+2	; 0x02
    2234:	13 81       	ldd	r17, Z+3	; 0x03
    2236:	48 17       	cp	r20, r24
    2238:	59 07       	cpc	r21, r25
    223a:	c8 f0       	brcs	.+50     	; 0x226e <malloc+0x66>
    223c:	84 17       	cp	r24, r20
    223e:	95 07       	cpc	r25, r21
    2240:	69 f4       	brne	.+26     	; 0x225c <malloc+0x54>
    2242:	10 97       	sbiw	r26, 0x00	; 0
    2244:	31 f0       	breq	.+12     	; 0x2252 <malloc+0x4a>
    2246:	12 96       	adiw	r26, 0x02	; 2
    2248:	0c 93       	st	X, r16
    224a:	12 97       	sbiw	r26, 0x02	; 2
    224c:	13 96       	adiw	r26, 0x03	; 3
    224e:	1c 93       	st	X, r17
    2250:	27 c0       	rjmp	.+78     	; 0x22a0 <malloc+0x98>
    2252:	00 93 24 01 	sts	0x0124, r16	; 0x800124 <__flp>
    2256:	10 93 25 01 	sts	0x0125, r17	; 0x800125 <__flp+0x1>
    225a:	22 c0       	rjmp	.+68     	; 0x22a0 <malloc+0x98>
    225c:	21 15       	cp	r18, r1
    225e:	31 05       	cpc	r19, r1
    2260:	19 f0       	breq	.+6      	; 0x2268 <malloc+0x60>
    2262:	42 17       	cp	r20, r18
    2264:	53 07       	cpc	r21, r19
    2266:	18 f4       	brcc	.+6      	; 0x226e <malloc+0x66>
    2268:	9a 01       	movw	r18, r20
    226a:	bd 01       	movw	r22, r26
    226c:	ef 01       	movw	r28, r30
    226e:	df 01       	movw	r26, r30
    2270:	f8 01       	movw	r30, r16
    2272:	db cf       	rjmp	.-74     	; 0x222a <malloc+0x22>
    2274:	21 15       	cp	r18, r1
    2276:	31 05       	cpc	r19, r1
    2278:	f9 f0       	breq	.+62     	; 0x22b8 <malloc+0xb0>
    227a:	28 1b       	sub	r18, r24
    227c:	39 0b       	sbc	r19, r25
    227e:	24 30       	cpi	r18, 0x04	; 4
    2280:	31 05       	cpc	r19, r1
    2282:	80 f4       	brcc	.+32     	; 0x22a4 <malloc+0x9c>
    2284:	8a 81       	ldd	r24, Y+2	; 0x02
    2286:	9b 81       	ldd	r25, Y+3	; 0x03
    2288:	61 15       	cp	r22, r1
    228a:	71 05       	cpc	r23, r1
    228c:	21 f0       	breq	.+8      	; 0x2296 <malloc+0x8e>
    228e:	fb 01       	movw	r30, r22
    2290:	93 83       	std	Z+3, r25	; 0x03
    2292:	82 83       	std	Z+2, r24	; 0x02
    2294:	04 c0       	rjmp	.+8      	; 0x229e <malloc+0x96>
    2296:	90 93 25 01 	sts	0x0125, r25	; 0x800125 <__flp+0x1>
    229a:	80 93 24 01 	sts	0x0124, r24	; 0x800124 <__flp>
    229e:	fe 01       	movw	r30, r28
    22a0:	32 96       	adiw	r30, 0x02	; 2
    22a2:	44 c0       	rjmp	.+136    	; 0x232c <malloc+0x124>
    22a4:	fe 01       	movw	r30, r28
    22a6:	e2 0f       	add	r30, r18
    22a8:	f3 1f       	adc	r31, r19
    22aa:	81 93       	st	Z+, r24
    22ac:	91 93       	st	Z+, r25
    22ae:	22 50       	subi	r18, 0x02	; 2
    22b0:	31 09       	sbc	r19, r1
    22b2:	39 83       	std	Y+1, r19	; 0x01
    22b4:	28 83       	st	Y, r18
    22b6:	3a c0       	rjmp	.+116    	; 0x232c <malloc+0x124>
    22b8:	20 91 22 01 	lds	r18, 0x0122	; 0x800122 <__brkval>
    22bc:	30 91 23 01 	lds	r19, 0x0123	; 0x800123 <__brkval+0x1>
    22c0:	23 2b       	or	r18, r19
    22c2:	41 f4       	brne	.+16     	; 0x22d4 <malloc+0xcc>
    22c4:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__malloc_heap_start>
    22c8:	30 91 63 00 	lds	r19, 0x0063	; 0x800063 <__malloc_heap_start+0x1>
    22cc:	30 93 23 01 	sts	0x0123, r19	; 0x800123 <__brkval+0x1>
    22d0:	20 93 22 01 	sts	0x0122, r18	; 0x800122 <__brkval>
    22d4:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    22d8:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    22dc:	21 15       	cp	r18, r1
    22de:	31 05       	cpc	r19, r1
    22e0:	41 f4       	brne	.+16     	; 0x22f2 <malloc+0xea>
    22e2:	2d b7       	in	r18, 0x3d	; 61
    22e4:	3e b7       	in	r19, 0x3e	; 62
    22e6:	40 91 64 00 	lds	r20, 0x0064	; 0x800064 <__malloc_margin>
    22ea:	50 91 65 00 	lds	r21, 0x0065	; 0x800065 <__malloc_margin+0x1>
    22ee:	24 1b       	sub	r18, r20
    22f0:	35 0b       	sbc	r19, r21
    22f2:	e0 91 22 01 	lds	r30, 0x0122	; 0x800122 <__brkval>
    22f6:	f0 91 23 01 	lds	r31, 0x0123	; 0x800123 <__brkval+0x1>
    22fa:	e2 17       	cp	r30, r18
    22fc:	f3 07       	cpc	r31, r19
    22fe:	a0 f4       	brcc	.+40     	; 0x2328 <malloc+0x120>
    2300:	2e 1b       	sub	r18, r30
    2302:	3f 0b       	sbc	r19, r31
    2304:	28 17       	cp	r18, r24
    2306:	39 07       	cpc	r19, r25
    2308:	78 f0       	brcs	.+30     	; 0x2328 <malloc+0x120>
    230a:	ac 01       	movw	r20, r24
    230c:	4e 5f       	subi	r20, 0xFE	; 254
    230e:	5f 4f       	sbci	r21, 0xFF	; 255
    2310:	24 17       	cp	r18, r20
    2312:	35 07       	cpc	r19, r21
    2314:	48 f0       	brcs	.+18     	; 0x2328 <malloc+0x120>
    2316:	4e 0f       	add	r20, r30
    2318:	5f 1f       	adc	r21, r31
    231a:	50 93 23 01 	sts	0x0123, r21	; 0x800123 <__brkval+0x1>
    231e:	40 93 22 01 	sts	0x0122, r20	; 0x800122 <__brkval>
    2322:	81 93       	st	Z+, r24
    2324:	91 93       	st	Z+, r25
    2326:	02 c0       	rjmp	.+4      	; 0x232c <malloc+0x124>
    2328:	e0 e0       	ldi	r30, 0x00	; 0
    232a:	f0 e0       	ldi	r31, 0x00	; 0
    232c:	cf 01       	movw	r24, r30
    232e:	df 91       	pop	r29
    2330:	cf 91       	pop	r28
    2332:	1f 91       	pop	r17
    2334:	0f 91       	pop	r16
    2336:	08 95       	ret

00002338 <free>:
    2338:	cf 93       	push	r28
    233a:	df 93       	push	r29
    233c:	00 97       	sbiw	r24, 0x00	; 0
    233e:	09 f4       	brne	.+2      	; 0x2342 <free+0xa>
    2340:	81 c0       	rjmp	.+258    	; 0x2444 <free+0x10c>
    2342:	fc 01       	movw	r30, r24
    2344:	32 97       	sbiw	r30, 0x02	; 2
    2346:	13 82       	std	Z+3, r1	; 0x03
    2348:	12 82       	std	Z+2, r1	; 0x02
    234a:	a0 91 24 01 	lds	r26, 0x0124	; 0x800124 <__flp>
    234e:	b0 91 25 01 	lds	r27, 0x0125	; 0x800125 <__flp+0x1>
    2352:	10 97       	sbiw	r26, 0x00	; 0
    2354:	81 f4       	brne	.+32     	; 0x2376 <free+0x3e>
    2356:	20 81       	ld	r18, Z
    2358:	31 81       	ldd	r19, Z+1	; 0x01
    235a:	82 0f       	add	r24, r18
    235c:	93 1f       	adc	r25, r19
    235e:	20 91 22 01 	lds	r18, 0x0122	; 0x800122 <__brkval>
    2362:	30 91 23 01 	lds	r19, 0x0123	; 0x800123 <__brkval+0x1>
    2366:	28 17       	cp	r18, r24
    2368:	39 07       	cpc	r19, r25
    236a:	51 f5       	brne	.+84     	; 0x23c0 <free+0x88>
    236c:	f0 93 23 01 	sts	0x0123, r31	; 0x800123 <__brkval+0x1>
    2370:	e0 93 22 01 	sts	0x0122, r30	; 0x800122 <__brkval>
    2374:	67 c0       	rjmp	.+206    	; 0x2444 <free+0x10c>
    2376:	ed 01       	movw	r28, r26
    2378:	20 e0       	ldi	r18, 0x00	; 0
    237a:	30 e0       	ldi	r19, 0x00	; 0
    237c:	ce 17       	cp	r28, r30
    237e:	df 07       	cpc	r29, r31
    2380:	40 f4       	brcc	.+16     	; 0x2392 <free+0x5a>
    2382:	4a 81       	ldd	r20, Y+2	; 0x02
    2384:	5b 81       	ldd	r21, Y+3	; 0x03
    2386:	9e 01       	movw	r18, r28
    2388:	41 15       	cp	r20, r1
    238a:	51 05       	cpc	r21, r1
    238c:	f1 f0       	breq	.+60     	; 0x23ca <free+0x92>
    238e:	ea 01       	movw	r28, r20
    2390:	f5 cf       	rjmp	.-22     	; 0x237c <free+0x44>
    2392:	d3 83       	std	Z+3, r29	; 0x03
    2394:	c2 83       	std	Z+2, r28	; 0x02
    2396:	40 81       	ld	r20, Z
    2398:	51 81       	ldd	r21, Z+1	; 0x01
    239a:	84 0f       	add	r24, r20
    239c:	95 1f       	adc	r25, r21
    239e:	c8 17       	cp	r28, r24
    23a0:	d9 07       	cpc	r29, r25
    23a2:	59 f4       	brne	.+22     	; 0x23ba <free+0x82>
    23a4:	88 81       	ld	r24, Y
    23a6:	99 81       	ldd	r25, Y+1	; 0x01
    23a8:	84 0f       	add	r24, r20
    23aa:	95 1f       	adc	r25, r21
    23ac:	02 96       	adiw	r24, 0x02	; 2
    23ae:	91 83       	std	Z+1, r25	; 0x01
    23b0:	80 83       	st	Z, r24
    23b2:	8a 81       	ldd	r24, Y+2	; 0x02
    23b4:	9b 81       	ldd	r25, Y+3	; 0x03
    23b6:	93 83       	std	Z+3, r25	; 0x03
    23b8:	82 83       	std	Z+2, r24	; 0x02
    23ba:	21 15       	cp	r18, r1
    23bc:	31 05       	cpc	r19, r1
    23be:	29 f4       	brne	.+10     	; 0x23ca <free+0x92>
    23c0:	f0 93 25 01 	sts	0x0125, r31	; 0x800125 <__flp+0x1>
    23c4:	e0 93 24 01 	sts	0x0124, r30	; 0x800124 <__flp>
    23c8:	3d c0       	rjmp	.+122    	; 0x2444 <free+0x10c>
    23ca:	e9 01       	movw	r28, r18
    23cc:	fb 83       	std	Y+3, r31	; 0x03
    23ce:	ea 83       	std	Y+2, r30	; 0x02
    23d0:	49 91       	ld	r20, Y+
    23d2:	59 91       	ld	r21, Y+
    23d4:	c4 0f       	add	r28, r20
    23d6:	d5 1f       	adc	r29, r21
    23d8:	ec 17       	cp	r30, r28
    23da:	fd 07       	cpc	r31, r29
    23dc:	61 f4       	brne	.+24     	; 0x23f6 <free+0xbe>
    23de:	80 81       	ld	r24, Z
    23e0:	91 81       	ldd	r25, Z+1	; 0x01
    23e2:	84 0f       	add	r24, r20
    23e4:	95 1f       	adc	r25, r21
    23e6:	02 96       	adiw	r24, 0x02	; 2
    23e8:	e9 01       	movw	r28, r18
    23ea:	99 83       	std	Y+1, r25	; 0x01
    23ec:	88 83       	st	Y, r24
    23ee:	82 81       	ldd	r24, Z+2	; 0x02
    23f0:	93 81       	ldd	r25, Z+3	; 0x03
    23f2:	9b 83       	std	Y+3, r25	; 0x03
    23f4:	8a 83       	std	Y+2, r24	; 0x02
    23f6:	e0 e0       	ldi	r30, 0x00	; 0
    23f8:	f0 e0       	ldi	r31, 0x00	; 0
    23fa:	12 96       	adiw	r26, 0x02	; 2
    23fc:	8d 91       	ld	r24, X+
    23fe:	9c 91       	ld	r25, X
    2400:	13 97       	sbiw	r26, 0x03	; 3
    2402:	00 97       	sbiw	r24, 0x00	; 0
    2404:	19 f0       	breq	.+6      	; 0x240c <free+0xd4>
    2406:	fd 01       	movw	r30, r26
    2408:	dc 01       	movw	r26, r24
    240a:	f7 cf       	rjmp	.-18     	; 0x23fa <free+0xc2>
    240c:	8d 91       	ld	r24, X+
    240e:	9c 91       	ld	r25, X
    2410:	11 97       	sbiw	r26, 0x01	; 1
    2412:	9d 01       	movw	r18, r26
    2414:	2e 5f       	subi	r18, 0xFE	; 254
    2416:	3f 4f       	sbci	r19, 0xFF	; 255
    2418:	82 0f       	add	r24, r18
    241a:	93 1f       	adc	r25, r19
    241c:	20 91 22 01 	lds	r18, 0x0122	; 0x800122 <__brkval>
    2420:	30 91 23 01 	lds	r19, 0x0123	; 0x800123 <__brkval+0x1>
    2424:	28 17       	cp	r18, r24
    2426:	39 07       	cpc	r19, r25
    2428:	69 f4       	brne	.+26     	; 0x2444 <free+0x10c>
    242a:	30 97       	sbiw	r30, 0x00	; 0
    242c:	29 f4       	brne	.+10     	; 0x2438 <free+0x100>
    242e:	10 92 25 01 	sts	0x0125, r1	; 0x800125 <__flp+0x1>
    2432:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <__flp>
    2436:	02 c0       	rjmp	.+4      	; 0x243c <free+0x104>
    2438:	13 82       	std	Z+3, r1	; 0x03
    243a:	12 82       	std	Z+2, r1	; 0x02
    243c:	b0 93 23 01 	sts	0x0123, r27	; 0x800123 <__brkval+0x1>
    2440:	a0 93 22 01 	sts	0x0122, r26	; 0x800122 <__brkval>
    2444:	df 91       	pop	r29
    2446:	cf 91       	pop	r28
    2448:	08 95       	ret

0000244a <memcpy>:
    244a:	fb 01       	movw	r30, r22
    244c:	dc 01       	movw	r26, r24
    244e:	02 c0       	rjmp	.+4      	; 0x2454 <memcpy+0xa>
    2450:	01 90       	ld	r0, Z+
    2452:	0d 92       	st	X+, r0
    2454:	41 50       	subi	r20, 0x01	; 1
    2456:	50 40       	sbci	r21, 0x00	; 0
    2458:	d8 f7       	brcc	.-10     	; 0x2450 <memcpy+0x6>
    245a:	08 95       	ret

0000245c <_exit>:
    245c:	f8 94       	cli

0000245e <__stop_program>:
    245e:	ff cf       	rjmp	.-2      	; 0x245e <__stop_program>
