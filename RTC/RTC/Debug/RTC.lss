
RTC.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002338  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000003c  00800060  00002338  000023cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000079  0080009c  0080009c  00002408  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002408  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002438  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000538  00000000  00000000  00002474  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00005a17  00000000  00000000  000029ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001642  00000000  00000000  000083c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00003352  00000000  00000000  00009a05  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000f40  00000000  00000000  0000cd58  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000019f9  00000000  00000000  0000dc98  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004744  00000000  00000000  0000f691  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000004b8  00000000  00000000  00013dd5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 86 00 	jmp	0x10c	; 0x10c <__vector_1>
       8:	0c 94 ad 00 	jmp	0x15a	; 0x15a <__vector_2>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__vector_3>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 7d 07 	jmp	0xefa	; 0xefa <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e3       	ldi	r30, 0x38	; 56
      68:	f3 e2       	ldi	r31, 0x23	; 35
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ac 39       	cpi	r26, 0x9C	; 156
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	21 e0       	ldi	r18, 0x01	; 1
      78:	ac e9       	ldi	r26, 0x9C	; 156
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 31       	cpi	r26, 0x15	; 21
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 7d 04 	call	0x8fa	; 0x8fa <main>
      8a:	0c 94 9a 11 	jmp	0x2334	; 0x2334 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <EXTI_Init>:
 * param : Handler is a pointer to struct that hold all information a bout the INIT 
 * return : void 
*/  
void EXIT_DISABLE(EXIT_Handler_t * Handler)
{
	GICR &=~(1<<(5+Handler->EXTI_NUM));  /* disable the required INIT */
      92:	fc 01       	movw	r30, r24
      94:	80 81       	ld	r24, Z
      96:	81 11       	cpse	r24, r1
      98:	0b c0       	rjmp	.+22     	; 0xb0 <EXTI_Init+0x1e>
      9a:	81 81       	ldd	r24, Z+1	; 0x01
      9c:	82 30       	cpi	r24, 0x02	; 2
      9e:	21 f4       	brne	.+8      	; 0xa8 <EXTI_Init+0x16>
      a0:	84 b7       	in	r24, 0x34	; 52
      a2:	8f 7b       	andi	r24, 0xBF	; 191
      a4:	84 bf       	out	0x34, r24	; 52
      a6:	1d c0       	rjmp	.+58     	; 0xe2 <EXTI_Init+0x50>
      a8:	84 b7       	in	r24, 0x34	; 52
      aa:	80 64       	ori	r24, 0x40	; 64
      ac:	84 bf       	out	0x34, r24	; 52
      ae:	19 c0       	rjmp	.+50     	; 0xe2 <EXTI_Init+0x50>
      b0:	85 b7       	in	r24, 0x35	; 53
      b2:	80 7f       	andi	r24, 0xF0	; 240
      b4:	85 bf       	out	0x35, r24	; 53
      b6:	20 81       	ld	r18, Z
      b8:	21 30       	cpi	r18, 0x01	; 1
      ba:	29 f4       	brne	.+10     	; 0xc6 <EXTI_Init+0x34>
      bc:	95 b7       	in	r25, 0x35	; 53
      be:	81 81       	ldd	r24, Z+1	; 0x01
      c0:	89 2b       	or	r24, r25
      c2:	85 bf       	out	0x35, r24	; 53
      c4:	0e c0       	rjmp	.+28     	; 0xe2 <EXTI_Init+0x50>
      c6:	45 b7       	in	r20, 0x35	; 53
      c8:	91 81       	ldd	r25, Z+1	; 0x01
      ca:	30 e0       	ldi	r19, 0x00	; 0
      cc:	22 0f       	add	r18, r18
      ce:	33 1f       	adc	r19, r19
      d0:	89 2f       	mov	r24, r25
      d2:	90 e0       	ldi	r25, 0x00	; 0
      d4:	02 c0       	rjmp	.+4      	; 0xda <EXTI_Init+0x48>
      d6:	88 0f       	add	r24, r24
      d8:	99 1f       	adc	r25, r25
      da:	2a 95       	dec	r18
      dc:	e2 f7       	brpl	.-8      	; 0xd6 <EXTI_Init+0x44>
      de:	84 2b       	or	r24, r20
      e0:	85 bf       	out	0x35, r24	; 53
      e2:	4b b7       	in	r20, 0x3b	; 59
      e4:	20 81       	ld	r18, Z
      e6:	30 e0       	ldi	r19, 0x00	; 0
      e8:	2b 5f       	subi	r18, 0xFB	; 251
      ea:	3f 4f       	sbci	r19, 0xFF	; 255
      ec:	81 e0       	ldi	r24, 0x01	; 1
      ee:	90 e0       	ldi	r25, 0x00	; 0
      f0:	02 c0       	rjmp	.+4      	; 0xf6 <EXTI_Init+0x64>
      f2:	88 0f       	add	r24, r24
      f4:	99 1f       	adc	r25, r25
      f6:	2a 95       	dec	r18
      f8:	e2 f7       	brpl	.-8      	; 0xf2 <EXTI_Init+0x60>
      fa:	84 2b       	or	r24, r20
      fc:	8b bf       	out	0x3b, r24	; 59
      fe:	78 94       	sei
     100:	08 95       	ret

00000102 <EXIT_INT0_CallBack>:
     102:	90 93 9d 00 	sts	0x009D, r25	; 0x80009d <__data_end+0x1>
     106:	80 93 9c 00 	sts	0x009C, r24	; 0x80009c <__data_end>
     10a:	08 95       	ret

0000010c <__vector_1>:
}


/* INIT0 Function */
ISR(INT0_vect)
{
     10c:	1f 92       	push	r1
     10e:	0f 92       	push	r0
     110:	0f b6       	in	r0, 0x3f	; 63
     112:	0f 92       	push	r0
     114:	11 24       	eor	r1, r1
     116:	2f 93       	push	r18
     118:	3f 93       	push	r19
     11a:	4f 93       	push	r20
     11c:	5f 93       	push	r21
     11e:	6f 93       	push	r22
     120:	7f 93       	push	r23
     122:	8f 93       	push	r24
     124:	9f 93       	push	r25
     126:	af 93       	push	r26
     128:	bf 93       	push	r27
     12a:	ef 93       	push	r30
     12c:	ff 93       	push	r31
	ptr();
     12e:	e0 91 9c 00 	lds	r30, 0x009C	; 0x80009c <__data_end>
     132:	f0 91 9d 00 	lds	r31, 0x009D	; 0x80009d <__data_end+0x1>
     136:	09 95       	icall
}
     138:	ff 91       	pop	r31
     13a:	ef 91       	pop	r30
     13c:	bf 91       	pop	r27
     13e:	af 91       	pop	r26
     140:	9f 91       	pop	r25
     142:	8f 91       	pop	r24
     144:	7f 91       	pop	r23
     146:	6f 91       	pop	r22
     148:	5f 91       	pop	r21
     14a:	4f 91       	pop	r20
     14c:	3f 91       	pop	r19
     14e:	2f 91       	pop	r18
     150:	0f 90       	pop	r0
     152:	0f be       	out	0x3f, r0	; 63
     154:	0f 90       	pop	r0
     156:	1f 90       	pop	r1
     158:	18 95       	reti

0000015a <__vector_2>:
/* INIT0 Function */
ISR(INT1_vect)
{
     15a:	1f 92       	push	r1
     15c:	0f 92       	push	r0
     15e:	0f b6       	in	r0, 0x3f	; 63
     160:	0f 92       	push	r0
     162:	11 24       	eor	r1, r1
     164:	2f 93       	push	r18
     166:	3f 93       	push	r19
     168:	4f 93       	push	r20
     16a:	5f 93       	push	r21
     16c:	6f 93       	push	r22
     16e:	7f 93       	push	r23
     170:	8f 93       	push	r24
     172:	9f 93       	push	r25
     174:	af 93       	push	r26
     176:	bf 93       	push	r27
     178:	ef 93       	push	r30
     17a:	ff 93       	push	r31
	ptr();
     17c:	e0 91 9c 00 	lds	r30, 0x009C	; 0x80009c <__data_end>
     180:	f0 91 9d 00 	lds	r31, 0x009D	; 0x80009d <__data_end+0x1>
     184:	09 95       	icall
}
     186:	ff 91       	pop	r31
     188:	ef 91       	pop	r30
     18a:	bf 91       	pop	r27
     18c:	af 91       	pop	r26
     18e:	9f 91       	pop	r25
     190:	8f 91       	pop	r24
     192:	7f 91       	pop	r23
     194:	6f 91       	pop	r22
     196:	5f 91       	pop	r21
     198:	4f 91       	pop	r20
     19a:	3f 91       	pop	r19
     19c:	2f 91       	pop	r18
     19e:	0f 90       	pop	r0
     1a0:	0f be       	out	0x3f, r0	; 63
     1a2:	0f 90       	pop	r0
     1a4:	1f 90       	pop	r1
     1a6:	18 95       	reti

000001a8 <__vector_3>:
/* INIT0 Function */
ISR(INT2_vect)
{
     1a8:	1f 92       	push	r1
     1aa:	0f 92       	push	r0
     1ac:	0f b6       	in	r0, 0x3f	; 63
     1ae:	0f 92       	push	r0
     1b0:	11 24       	eor	r1, r1
     1b2:	2f 93       	push	r18
     1b4:	3f 93       	push	r19
     1b6:	4f 93       	push	r20
     1b8:	5f 93       	push	r21
     1ba:	6f 93       	push	r22
     1bc:	7f 93       	push	r23
     1be:	8f 93       	push	r24
     1c0:	9f 93       	push	r25
     1c2:	af 93       	push	r26
     1c4:	bf 93       	push	r27
     1c6:	ef 93       	push	r30
     1c8:	ff 93       	push	r31
	ptr();
     1ca:	e0 91 9c 00 	lds	r30, 0x009C	; 0x80009c <__data_end>
     1ce:	f0 91 9d 00 	lds	r31, 0x009D	; 0x80009d <__data_end+0x1>
     1d2:	09 95       	icall
     1d4:	ff 91       	pop	r31
     1d6:	ef 91       	pop	r30
     1d8:	bf 91       	pop	r27
     1da:	af 91       	pop	r26
     1dc:	9f 91       	pop	r25
     1de:	8f 91       	pop	r24
     1e0:	7f 91       	pop	r23
     1e2:	6f 91       	pop	r22
     1e4:	5f 91       	pop	r21
     1e6:	4f 91       	pop	r20
     1e8:	3f 91       	pop	r19
     1ea:	2f 91       	pop	r18
     1ec:	0f 90       	pop	r0
     1ee:	0f be       	out	0x3f, r0	; 63
     1f0:	0f 90       	pop	r0
     1f2:	1f 90       	pop	r1
     1f4:	18 95       	reti

000001f6 <HAL_GPIO_INIT_PIN>:
	}
	else              /* if read pin is zero */
	{
		return GPIO_PIN_RESET ;
	}
}/* END_FUN HAL_GPIO_READPIN()*/
     1f6:	dc 01       	movw	r26, r24
     1f8:	fb 01       	movw	r30, r22
     1fa:	81 81       	ldd	r24, Z+1	; 0x01
     1fc:	81 30       	cpi	r24, 0x01	; 1
     1fe:	99 f4       	brne	.+38     	; 0x226 <HAL_GPIO_INIT_PIN+0x30>
     200:	80 81       	ld	r24, Z
     202:	11 96       	adiw	r26, 0x01	; 1
     204:	9c 91       	ld	r25, X
     206:	11 97       	sbiw	r26, 0x01	; 1
     208:	89 2b       	or	r24, r25
     20a:	11 96       	adiw	r26, 0x01	; 1
     20c:	8c 93       	st	X, r24
     20e:	11 97       	sbiw	r26, 0x01	; 1
     210:	82 81       	ldd	r24, Z+2	; 0x02
     212:	81 30       	cpi	r24, 0x01	; 1
     214:	81 f4       	brne	.+32     	; 0x236 <HAL_GPIO_INIT_PIN+0x40>
     216:	80 81       	ld	r24, Z
     218:	12 96       	adiw	r26, 0x02	; 2
     21a:	9c 91       	ld	r25, X
     21c:	12 97       	sbiw	r26, 0x02	; 2
     21e:	89 2b       	or	r24, r25
     220:	12 96       	adiw	r26, 0x02	; 2
     222:	8c 93       	st	X, r24
     224:	08 95       	ret
     226:	90 81       	ld	r25, Z
     228:	90 95       	com	r25
     22a:	11 96       	adiw	r26, 0x01	; 1
     22c:	8c 91       	ld	r24, X
     22e:	11 97       	sbiw	r26, 0x01	; 1
     230:	98 23       	and	r25, r24
     232:	11 96       	adiw	r26, 0x01	; 1
     234:	9c 93       	st	X, r25
     236:	08 95       	ret

00000238 <HAL_GPIO_WRITEPIN>:
 * param. : PIN_NUM the pin number must be one of GPIO_PIN_RESET or GPIO_PIN_SET
 * return : void  
 */
void HAL_GPIO_WRITEPIN(GPIO_TypeDef * PORT,uint8_t PIN_NUM,GPIO_PinState PIN_STATE)
{
	if(PIN_STATE != GPIO_PIN_RESET)
     238:	44 23       	and	r20, r20
     23a:	29 f0       	breq	.+10     	; 0x246 <HAL_GPIO_WRITEPIN+0xe>
	{
		PORT->PORT_REG |= PIN_NUM ;
     23c:	fc 01       	movw	r30, r24
     23e:	22 81       	ldd	r18, Z+2	; 0x02
     240:	62 2b       	or	r22, r18
     242:	62 83       	std	Z+2, r22	; 0x02
     244:	08 95       	ret
	}
	else
	{
		PORT->PORT_REG &= ~(PIN_NUM);
     246:	60 95       	com	r22
     248:	fc 01       	movw	r30, r24
     24a:	22 81       	ldd	r18, Z+2	; 0x02
     24c:	62 23       	and	r22, r18
     24e:	62 83       	std	Z+2, r22	; 0x02
     250:	08 95       	ret

00000252 <I2C_INIT_FUN>:
I2C_STATUS HAL_I2C_Slave_Receive_IT(I2C_Handler_t * Handler  ,uint8_t * pRxData ,uint8_t DataSize )
{
	
	
		return I2C_NORMAL;
}
     252:	8f 92       	push	r8
     254:	9f 92       	push	r9
     256:	af 92       	push	r10
     258:	bf 92       	push	r11
     25a:	cf 92       	push	r12
     25c:	df 92       	push	r13
     25e:	ef 92       	push	r14
     260:	ff 92       	push	r15
     262:	0f 93       	push	r16
     264:	cf 93       	push	r28
     266:	df 93       	push	r29
     268:	ec 01       	movw	r28, r24
     26a:	28 81       	ld	r18, Y
     26c:	39 81       	ldd	r19, Y+1	; 0x01
     26e:	4a 81       	ldd	r20, Y+2	; 0x02
     270:	5b 81       	ldd	r21, Y+3	; 0x03
     272:	60 e0       	ldi	r22, 0x00	; 0
     274:	74 e2       	ldi	r23, 0x24	; 36
     276:	84 ef       	ldi	r24, 0xF4	; 244
     278:	90 e0       	ldi	r25, 0x00	; 0
     27a:	0e 94 24 10 	call	0x2048	; 0x2048 <__udivmodsi4>
     27e:	49 01       	movw	r8, r18
     280:	5a 01       	movw	r10, r20
     282:	39 2d       	mov	r19, r9
     284:	4a 2d       	mov	r20, r10
     286:	5b 2d       	mov	r21, r11
     288:	60 e0       	ldi	r22, 0x00	; 0
     28a:	70 e0       	ldi	r23, 0x00	; 0
     28c:	80 e0       	ldi	r24, 0x00	; 0
     28e:	90 e0       	ldi	r25, 0x00	; 0
     290:	a0 ef       	ldi	r26, 0xF0	; 240
     292:	0e 94 64 10 	call	0x20c8	; 0x20c8 <__adddi3_s8>
     296:	01 e0       	ldi	r16, 0x01	; 1
     298:	0e 94 48 10 	call	0x2090	; 0x2090 <__lshrdi3>
     29c:	20 b9       	out	0x00, r18	; 0
     29e:	8c 81       	ldd	r24, Y+4	; 0x04
     2a0:	82 b9       	out	0x02, r24	; 2
     2a2:	16 be       	out	0x36, r1	; 54
     2a4:	11 b8       	out	0x01, r1	; 1
     2a6:	8d 81       	ldd	r24, Y+5	; 0x05
     2a8:	81 30       	cpi	r24, 0x01	; 1
     2aa:	29 f4       	brne	.+10     	; 0x2b6 <I2C_INIT_FUN+0x64>
     2ac:	78 94       	sei
     2ae:	86 b7       	in	r24, 0x36	; 54
     2b0:	81 60       	ori	r24, 0x01	; 1
     2b2:	86 bf       	out	0x36, r24	; 54
     2b4:	03 c0       	rjmp	.+6      	; 0x2bc <I2C_INIT_FUN+0x6a>
     2b6:	86 b7       	in	r24, 0x36	; 54
     2b8:	8e 7f       	andi	r24, 0xFE	; 254
     2ba:	86 bf       	out	0x36, r24	; 54
     2bc:	df 91       	pop	r29
     2be:	cf 91       	pop	r28
     2c0:	0f 91       	pop	r16
     2c2:	ff 90       	pop	r15
     2c4:	ef 90       	pop	r14
     2c6:	df 90       	pop	r13
     2c8:	cf 90       	pop	r12
     2ca:	bf 90       	pop	r11
     2cc:	af 90       	pop	r10
     2ce:	9f 90       	pop	r9
     2d0:	8f 90       	pop	r8
     2d2:	08 95       	ret

000002d4 <HAL_I2C_Mem_Write>:
 * param. @ : memAdd this is the internal memory address that you need to write data to 
 * param. @ : pRxData this is pointer to the buffer that hold the writing data 
 * param. @ : DataSize number of bytes that you need to write 
*/ 
I2C_STATUS HAL_I2C_Mem_Write(I2C_Handler_t * Handler ,uint8_t DevAdd,uint8_t MemAdd ,uint8_t * pTxData ,uint8_t DataSize )
{
     2d4:	0f 93       	push	r16
     2d6:	fc 01       	movw	r30, r24
	Handler->buffer = pTxData ;
     2d8:	37 83       	std	Z+7, r19	; 0x07
     2da:	26 83       	std	Z+6, r18	; 0x06
	Handler->Size   = DataSize;
     2dc:	00 87       	std	Z+8, r16	; 0x08
	
	
	I2C_EN_START();
     2de:	84 ea       	ldi	r24, 0xA4	; 164
     2e0:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     2e2:	06 b6       	in	r0, 0x36	; 54
     2e4:	07 fe       	sbrs	r0, 7
     2e6:	fd cf       	rjmp	.-6      	; 0x2e2 <HAL_I2C_Mem_Write+0xe>
	
	
	I2C->I2C_TWDR = DevAdd ;
     2e8:	63 b9       	out	0x03, r22	; 3
	I2C_EN();
     2ea:	84 e8       	ldi	r24, 0x84	; 132
     2ec:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     2ee:	06 b6       	in	r0, 0x36	; 54
     2f0:	07 fe       	sbrs	r0, 7
     2f2:	fd cf       	rjmp	.-6      	; 0x2ee <HAL_I2C_Mem_Write+0x1a>

	I2C->I2C_TWDR = MemAdd;
     2f4:	43 b9       	out	0x03, r20	; 3
	I2C_EN();
     2f6:	84 e8       	ldi	r24, 0x84	; 132
     2f8:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     2fa:	06 b6       	in	r0, 0x36	; 54
     2fc:	07 fe       	sbrs	r0, 7
     2fe:	fd cf       	rjmp	.-6      	; 0x2fa <HAL_I2C_Mem_Write+0x26>
     300:	0d c0       	rjmp	.+26     	; 0x31c <HAL_I2C_Mem_Write+0x48>
	

	while(Handler->Size-- > 0)
	{
		I2C->I2C_TWDR = *(Handler->buffer++) ;
     302:	a6 81       	ldd	r26, Z+6	; 0x06
     304:	b7 81       	ldd	r27, Z+7	; 0x07
     306:	cd 01       	movw	r24, r26
     308:	01 96       	adiw	r24, 0x01	; 1
     30a:	97 83       	std	Z+7, r25	; 0x07
     30c:	86 83       	std	Z+6, r24	; 0x06
     30e:	8c 91       	ld	r24, X
     310:	83 b9       	out	0x03, r24	; 3
		I2C_EN();
     312:	84 e8       	ldi	r24, 0x84	; 132
     314:	86 bf       	out	0x36, r24	; 54
		while(!(I2C->I2C_TWCR & 0x80));
     316:	06 b6       	in	r0, 0x36	; 54
     318:	07 fe       	sbrs	r0, 7
     31a:	fd cf       	rjmp	.-6      	; 0x316 <HAL_I2C_Mem_Write+0x42>
	I2C->I2C_TWDR = MemAdd;
	I2C_EN();
	while(!(I2C->I2C_TWCR & 0x80));
	

	while(Handler->Size-- > 0)
     31c:	80 85       	ldd	r24, Z+8	; 0x08
     31e:	9f ef       	ldi	r25, 0xFF	; 255
     320:	98 0f       	add	r25, r24
     322:	90 87       	std	Z+8, r25	; 0x08
     324:	81 11       	cpse	r24, r1
     326:	ed cf       	rjmp	.-38     	; 0x302 <HAL_I2C_Mem_Write+0x2e>
	{
		I2C->I2C_TWDR = *(Handler->buffer++) ;
		I2C_EN();
		while(!(I2C->I2C_TWCR & 0x80));
	}
	I2C_EN_STOP();
     328:	84 e9       	ldi	r24, 0x94	; 148
     32a:	86 bf       	out	0x36, r24	; 54
	
	return I2C_NORMAL;	
}
     32c:	81 e0       	ldi	r24, 0x01	; 1
     32e:	0f 91       	pop	r16
     330:	08 95       	ret

00000332 <HAL_I2C_Mem_Read>:
 * param. @ : memAdd this is the internal memory address that you need to read data from it 
 * param. @ : pRxData this is pointer to the buffer that will hold the reading data 
 * param. @ : DataSize number of bytes that you need to read 
*/ 
I2C_STATUS HAL_I2C_Mem_Read(I2C_Handler_t * Handler ,uint8_t DevAdd,uint8_t MemAdd ,uint8_t * pRxData ,uint8_t DataSize )
{
     332:	0f 93       	push	r16
     334:	fc 01       	movw	r30, r24
	Handler->buffer = pRxData ;
     336:	37 83       	std	Z+7, r19	; 0x07
     338:	26 83       	std	Z+6, r18	; 0x06
	Handler->Size   = DataSize;
     33a:	00 87       	std	Z+8, r16	; 0x08
	
	I2C_EN_START();
     33c:	84 ea       	ldi	r24, 0xA4	; 164
     33e:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     340:	06 b6       	in	r0, 0x36	; 54
     342:	07 fe       	sbrs	r0, 7
     344:	fd cf       	rjmp	.-6      	; 0x340 <HAL_I2C_Mem_Read+0xe>
	
	
	I2C->I2C_TWDR = DevAdd ;
     346:	63 b9       	out	0x03, r22	; 3
	I2C_EN();
     348:	84 e8       	ldi	r24, 0x84	; 132
     34a:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     34c:	06 b6       	in	r0, 0x36	; 54
     34e:	07 fe       	sbrs	r0, 7
     350:	fd cf       	rjmp	.-6      	; 0x34c <HAL_I2C_Mem_Read+0x1a>

	I2C->I2C_TWDR = MemAdd;
     352:	43 b9       	out	0x03, r20	; 3
	I2C_EN();
     354:	84 e8       	ldi	r24, 0x84	; 132
     356:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     358:	06 b6       	in	r0, 0x36	; 54
     35a:	07 fe       	sbrs	r0, 7
     35c:	fd cf       	rjmp	.-6      	; 0x358 <HAL_I2C_Mem_Read+0x26>
	
	
	I2C_EN_START();
     35e:	84 ea       	ldi	r24, 0xA4	; 164
     360:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));	
     362:	06 b6       	in	r0, 0x36	; 54
     364:	07 fe       	sbrs	r0, 7
     366:	fd cf       	rjmp	.-6      	; 0x362 <HAL_I2C_Mem_Read+0x30>

	I2C->I2C_TWDR = DevAdd | 1 ;
     368:	61 60       	ori	r22, 0x01	; 1
     36a:	63 b9       	out	0x03, r22	; 3
	I2C_EN();
     36c:	84 e8       	ldi	r24, 0x84	; 132
     36e:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));
     370:	06 b6       	in	r0, 0x36	; 54
     372:	07 fe       	sbrs	r0, 7
     374:	fd cf       	rjmp	.-6      	; 0x370 <HAL_I2C_Mem_Read+0x3e>
     376:	0d c0       	rjmp	.+26     	; 0x392 <HAL_I2C_Mem_Read+0x60>
	
		
	while(Handler->Size-- > 0)
	{
		I2C_EN_ACK();
     378:	84 ec       	ldi	r24, 0xC4	; 196
     37a:	86 bf       	out	0x36, r24	; 54
		while(!(I2C->I2C_TWCR & 0x80));
     37c:	06 b6       	in	r0, 0x36	; 54
     37e:	07 fe       	sbrs	r0, 7
     380:	fd cf       	rjmp	.-6      	; 0x37c <HAL_I2C_Mem_Read+0x4a>
		*(Handler->buffer++) = I2C->I2C_TWDR ;
     382:	a6 81       	ldd	r26, Z+6	; 0x06
     384:	b7 81       	ldd	r27, Z+7	; 0x07
     386:	cd 01       	movw	r24, r26
     388:	01 96       	adiw	r24, 0x01	; 1
     38a:	97 83       	std	Z+7, r25	; 0x07
     38c:	86 83       	std	Z+6, r24	; 0x06
     38e:	83 b1       	in	r24, 0x03	; 3
     390:	8c 93       	st	X, r24
	I2C->I2C_TWDR = DevAdd | 1 ;
	I2C_EN();
	while(!(I2C->I2C_TWCR & 0x80));
	
		
	while(Handler->Size-- > 0)
     392:	80 85       	ldd	r24, Z+8	; 0x08
     394:	9f ef       	ldi	r25, 0xFF	; 255
     396:	98 0f       	add	r25, r24
     398:	90 87       	std	Z+8, r25	; 0x08
     39a:	81 11       	cpse	r24, r1
     39c:	ed cf       	rjmp	.-38     	; 0x378 <HAL_I2C_Mem_Read+0x46>
	{
		I2C_EN_ACK();
		while(!(I2C->I2C_TWCR & 0x80));
		*(Handler->buffer++) = I2C->I2C_TWDR ;
	}
	I2C_EN_NACK();
     39e:	84 e8       	ldi	r24, 0x84	; 132
     3a0:	86 bf       	out	0x36, r24	; 54
	while(!(I2C->I2C_TWCR & 0x80));	
     3a2:	06 b6       	in	r0, 0x36	; 54
     3a4:	07 fe       	sbrs	r0, 7
     3a6:	fd cf       	rjmp	.-6      	; 0x3a2 <HAL_I2C_Mem_Read+0x70>
	I2C_EN_STOP();
     3a8:	84 e9       	ldi	r24, 0x94	; 148
     3aa:	86 bf       	out	0x36, r24	; 54
	return I2C_NORMAL;		
}
     3ac:	81 e0       	ldi	r24, 0x01	; 1
     3ae:	0f 91       	pop	r16
     3b0:	08 95       	ret

000003b2 <DS1305_Init>:
				Alarm->Hours =   TempAlarm.Hours;
				
			}
			Alarm->Day   =TempAlarm.Day ;
	
}
     3b2:	86 e6       	ldi	r24, 0x66	; 102
     3b4:	90 e0       	ldi	r25, 0x00	; 0
     3b6:	0e 94 29 01 	call	0x252	; 0x252 <I2C_INIT_FUN>
     3ba:	08 95       	ret

000003bc <Convert_BCD_To_BIN>:
     3bc:	38 2f       	mov	r19, r24
     3be:	3f 70       	andi	r19, 0x0F	; 15
     3c0:	98 2f       	mov	r25, r24
     3c2:	92 95       	swap	r25
     3c4:	9f 70       	andi	r25, 0x0F	; 15
     3c6:	99 0f       	add	r25, r25
     3c8:	29 2f       	mov	r18, r25
     3ca:	22 0f       	add	r18, r18
     3cc:	22 0f       	add	r18, r18
     3ce:	89 2f       	mov	r24, r25
     3d0:	82 0f       	add	r24, r18
     3d2:	83 0f       	add	r24, r19
     3d4:	08 95       	ret

000003d6 <RTC_Get_Time>:
     3d6:	ef 92       	push	r14
     3d8:	ff 92       	push	r15
     3da:	0f 93       	push	r16
     3dc:	1f 93       	push	r17
     3de:	cf 93       	push	r28
     3e0:	df 93       	push	r29
     3e2:	00 d0       	rcall	.+0      	; 0x3e4 <RTC_Get_Time+0xe>
     3e4:	00 d0       	rcall	.+0      	; 0x3e6 <RTC_Get_Time+0x10>
     3e6:	1f 92       	push	r1
     3e8:	cd b7       	in	r28, 0x3d	; 61
     3ea:	de b7       	in	r29, 0x3e	; 62
     3ec:	7c 01       	movw	r14, r24
     3ee:	03 e0       	ldi	r16, 0x03	; 3
     3f0:	9e 01       	movw	r18, r28
     3f2:	2f 5f       	subi	r18, 0xFF	; 255
     3f4:	3f 4f       	sbci	r19, 0xFF	; 255
     3f6:	40 e0       	ldi	r20, 0x00	; 0
     3f8:	60 ed       	ldi	r22, 0xD0	; 208
     3fa:	86 e6       	ldi	r24, 0x66	; 102
     3fc:	90 e0       	ldi	r25, 0x00	; 0
     3fe:	0e 94 99 01 	call	0x332	; 0x332 <HAL_I2C_Mem_Read>
     402:	8b 81       	ldd	r24, Y+3	; 0x03
     404:	98 2f       	mov	r25, r24
     406:	90 74       	andi	r25, 0x40	; 64
     408:	86 fd       	sbrc	r24, 6
     40a:	05 c0       	rjmp	.+10     	; 0x416 <__EEPROM_REGION_LENGTH__+0x16>
     40c:	f7 01       	movw	r30, r14
     40e:	82 81       	ldd	r24, Z+2	; 0x02
     410:	8f 77       	andi	r24, 0x7F	; 127
     412:	82 83       	std	Z+2, r24	; 0x02
     414:	0b c0       	rjmp	.+22     	; 0x42c <__EEPROM_REGION_LENGTH__+0x2c>
     416:	91 11       	cpse	r25, r1
     418:	04 c0       	rjmp	.+8      	; 0x422 <__EEPROM_REGION_LENGTH__+0x22>
     41a:	91 e0       	ldi	r25, 0x01	; 1
     41c:	f7 01       	movw	r30, r14
     41e:	94 83       	std	Z+4, r25	; 0x04
     420:	03 c0       	rjmp	.+6      	; 0x428 <__EEPROM_REGION_LENGTH__+0x28>
     422:	92 e0       	ldi	r25, 0x02	; 2
     424:	f7 01       	movw	r30, r14
     426:	94 83       	std	Z+4, r25	; 0x04
     428:	8f 71       	andi	r24, 0x1F	; 31
     42a:	8b 83       	std	Y+3, r24	; 0x03
     42c:	8a 81       	ldd	r24, Y+2	; 0x02
     42e:	08 2f       	mov	r16, r24
     430:	0f 77       	andi	r16, 0x7F	; 127
     432:	89 81       	ldd	r24, Y+1	; 0x01
     434:	18 2f       	mov	r17, r24
     436:	1f 77       	andi	r17, 0x7F	; 127
     438:	f7 01       	movw	r30, r14
     43a:	83 81       	ldd	r24, Z+3	; 0x03
     43c:	82 30       	cpi	r24, 0x02	; 2
     43e:	81 f4       	brne	.+32     	; 0x460 <__EEPROM_REGION_LENGTH__+0x60>
     440:	8b 81       	ldd	r24, Y+3	; 0x03
     442:	0e 94 de 01 	call	0x3bc	; 0x3bc <Convert_BCD_To_BIN>
     446:	f7 01       	movw	r30, r14
     448:	82 83       	std	Z+2, r24	; 0x02
     44a:	80 2f       	mov	r24, r16
     44c:	0e 94 de 01 	call	0x3bc	; 0x3bc <Convert_BCD_To_BIN>
     450:	f7 01       	movw	r30, r14
     452:	81 83       	std	Z+1, r24	; 0x01
     454:	81 2f       	mov	r24, r17
     456:	0e 94 de 01 	call	0x3bc	; 0x3bc <Convert_BCD_To_BIN>
     45a:	f7 01       	movw	r30, r14
     45c:	80 83       	st	Z, r24
     45e:	05 c0       	rjmp	.+10     	; 0x46a <__EEPROM_REGION_LENGTH__+0x6a>
     460:	8b 81       	ldd	r24, Y+3	; 0x03
     462:	f7 01       	movw	r30, r14
     464:	82 83       	std	Z+2, r24	; 0x02
     466:	01 83       	std	Z+1, r16	; 0x01
     468:	10 83       	st	Z, r17
     46a:	0f 90       	pop	r0
     46c:	0f 90       	pop	r0
     46e:	0f 90       	pop	r0
     470:	0f 90       	pop	r0
     472:	0f 90       	pop	r0
     474:	df 91       	pop	r29
     476:	cf 91       	pop	r28
     478:	1f 91       	pop	r17
     47a:	0f 91       	pop	r16
     47c:	ff 90       	pop	r15
     47e:	ef 90       	pop	r14
     480:	08 95       	ret

00000482 <RTC_Get_Date>:
     482:	ef 92       	push	r14
     484:	ff 92       	push	r15
     486:	0f 93       	push	r16
     488:	cf 93       	push	r28
     48a:	df 93       	push	r29
     48c:	00 d0       	rcall	.+0      	; 0x48e <RTC_Get_Date+0xc>
     48e:	00 d0       	rcall	.+0      	; 0x490 <RTC_Get_Date+0xe>
     490:	1f 92       	push	r1
     492:	cd b7       	in	r28, 0x3d	; 61
     494:	de b7       	in	r29, 0x3e	; 62
     496:	7c 01       	movw	r14, r24
     498:	04 e0       	ldi	r16, 0x04	; 4
     49a:	9e 01       	movw	r18, r28
     49c:	2f 5f       	subi	r18, 0xFF	; 255
     49e:	3f 4f       	sbci	r19, 0xFF	; 255
     4a0:	43 e0       	ldi	r20, 0x03	; 3
     4a2:	60 ed       	ldi	r22, 0xD0	; 208
     4a4:	86 e6       	ldi	r24, 0x66	; 102
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	0e 94 99 01 	call	0x332	; 0x332 <HAL_I2C_Mem_Read>
     4ac:	f7 01       	movw	r30, r14
     4ae:	84 81       	ldd	r24, Z+4	; 0x04
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	81 f4       	brne	.+32     	; 0x4d4 <RTC_Get_Date+0x52>
     4b4:	8a 81       	ldd	r24, Y+2	; 0x02
     4b6:	0e 94 de 01 	call	0x3bc	; 0x3bc <Convert_BCD_To_BIN>
     4ba:	f7 01       	movw	r30, r14
     4bc:	81 83       	std	Z+1, r24	; 0x01
     4be:	8b 81       	ldd	r24, Y+3	; 0x03
     4c0:	0e 94 de 01 	call	0x3bc	; 0x3bc <Convert_BCD_To_BIN>
     4c4:	f7 01       	movw	r30, r14
     4c6:	82 83       	std	Z+2, r24	; 0x02
     4c8:	8c 81       	ldd	r24, Y+4	; 0x04
     4ca:	0e 94 de 01 	call	0x3bc	; 0x3bc <Convert_BCD_To_BIN>
     4ce:	f7 01       	movw	r30, r14
     4d0:	83 83       	std	Z+3, r24	; 0x03
     4d2:	07 c0       	rjmp	.+14     	; 0x4e2 <RTC_Get_Date+0x60>
     4d4:	8a 81       	ldd	r24, Y+2	; 0x02
     4d6:	f7 01       	movw	r30, r14
     4d8:	81 83       	std	Z+1, r24	; 0x01
     4da:	8b 81       	ldd	r24, Y+3	; 0x03
     4dc:	82 83       	std	Z+2, r24	; 0x02
     4de:	8c 81       	ldd	r24, Y+4	; 0x04
     4e0:	83 83       	std	Z+3, r24	; 0x03
     4e2:	89 81       	ldd	r24, Y+1	; 0x01
     4e4:	f7 01       	movw	r30, r14
     4e6:	80 83       	st	Z, r24
     4e8:	0f 90       	pop	r0
     4ea:	0f 90       	pop	r0
     4ec:	0f 90       	pop	r0
     4ee:	0f 90       	pop	r0
     4f0:	0f 90       	pop	r0
     4f2:	df 91       	pop	r29
     4f4:	cf 91       	pop	r28
     4f6:	0f 91       	pop	r16
     4f8:	ff 90       	pop	r15
     4fa:	ef 90       	pop	r14
     4fc:	08 95       	ret

000004fe <Convert_BIN_To_BCD>:
{
	
	uint8_t BCD_Low =0;
	
	
	if(BIN_Num > 99u) // check if the wrong data send from the Application
     4fe:	84 36       	cpi	r24, 0x64	; 100
     500:	d8 f4       	brcc	.+54     	; 0x538 <Convert_BIN_To_BCD+0x3a>
	return 0x99u;
	if(BIN_Num == 0)
     502:	88 23       	and	r24, r24
     504:	d9 f0       	breq	.+54     	; 0x53c <Convert_BIN_To_BCD+0x3e>
	return 0;
	
	BCD_Low = BIN_Num % 10u ;
     506:	9d ec       	ldi	r25, 0xCD	; 205
     508:	89 9f       	mul	r24, r25
     50a:	91 2d       	mov	r25, r1
     50c:	11 24       	eor	r1, r1
     50e:	49 2f       	mov	r20, r25
     510:	46 95       	lsr	r20
     512:	46 95       	lsr	r20
     514:	46 95       	lsr	r20
     516:	44 0f       	add	r20, r20
     518:	24 2f       	mov	r18, r20
     51a:	22 0f       	add	r18, r18
     51c:	22 0f       	add	r18, r18
     51e:	42 0f       	add	r20, r18
     520:	84 1b       	sub	r24, r20
     522:	48 2f       	mov	r20, r24
	BIN_Num /= 10u ;
     524:	96 95       	lsr	r25
     526:	96 95       	lsr	r25
     528:	96 95       	lsr	r25
	return (BIN_Num <<4u | BCD_Low );
     52a:	80 e1       	ldi	r24, 0x10	; 16
     52c:	98 9f       	mul	r25, r24
     52e:	90 01       	movw	r18, r0
     530:	11 24       	eor	r1, r1
     532:	84 2f       	mov	r24, r20
     534:	82 2b       	or	r24, r18
     536:	08 95       	ret
	
	uint8_t BCD_Low =0;
	
	
	if(BIN_Num > 99u) // check if the wrong data send from the Application
	return 0x99u;
     538:	89 e9       	ldi	r24, 0x99	; 153
     53a:	08 95       	ret
	if(BIN_Num == 0)
	return 0;
     53c:	80 e0       	ldi	r24, 0x00	; 0
	BIN_Num /= 10u ;
	return (BIN_Num <<4u | BCD_Low );
	
	
	
}
     53e:	08 95       	ret

00000540 <RTC_Set_Time>:
/* brief : this function used to set DS1305 Time 
 * param : Time_Typedef handler struct pointer hold all Time informations 
 * return : void 
 */
void RTC_Set_Time(Time_Typedef * Time)
{
     540:	0f 93       	push	r16
     542:	1f 93       	push	r17
     544:	cf 93       	push	r28
     546:	df 93       	push	r29
     548:	00 d0       	rcall	.+0      	; 0x54a <RTC_Set_Time+0xa>
     54a:	00 d0       	rcall	.+0      	; 0x54c <RTC_Set_Time+0xc>
     54c:	1f 92       	push	r1
     54e:	cd b7       	in	r28, 0x3d	; 61
     550:	de b7       	in	r29, 0x3e	; 62
     552:	8c 01       	movw	r16, r24
	/* temp handler to hold all actual timing info that will send to DS1305 */
	Time_Typedef TempTime ;
	
	/* check if any need to convert to BCD formate */
	if(Time->RTC_Time_Format == RTC_Format_BIN)
     554:	fc 01       	movw	r30, r24
     556:	83 81       	ldd	r24, Z+3	; 0x03
     558:	82 30       	cpi	r24, 0x02	; 2
     55a:	79 f4       	brne	.+30     	; 0x57a <RTC_Set_Time+0x3a>
	{
		TempTime.Hours   = Convert_BIN_To_BCD(Time->Hours);
     55c:	82 81       	ldd	r24, Z+2	; 0x02
     55e:	0e 94 7f 02 	call	0x4fe	; 0x4fe <Convert_BIN_To_BCD>
     562:	8b 83       	std	Y+3, r24	; 0x03
		TempTime.Minutes = Convert_BIN_To_BCD(Time->Minutes);
     564:	f8 01       	movw	r30, r16
     566:	81 81       	ldd	r24, Z+1	; 0x01
     568:	0e 94 7f 02 	call	0x4fe	; 0x4fe <Convert_BIN_To_BCD>
     56c:	8a 83       	std	Y+2, r24	; 0x02
		TempTime.Seconds = Convert_BIN_To_BCD(Time->Seconds);							
     56e:	f8 01       	movw	r30, r16
     570:	80 81       	ld	r24, Z
     572:	0e 94 7f 02 	call	0x4fe	; 0x4fe <Convert_BIN_To_BCD>
     576:	89 83       	std	Y+1, r24	; 0x01
     578:	0a c0       	rjmp	.+20     	; 0x58e <RTC_Set_Time+0x4e>
	}else{
		TempTime.Hours   = Time->Hours	  & 0x7f ;
     57a:	f8 01       	movw	r30, r16
     57c:	82 81       	ldd	r24, Z+2	; 0x02
     57e:	8f 77       	andi	r24, 0x7F	; 127
     580:	8b 83       	std	Y+3, r24	; 0x03
		TempTime.Minutes = Time->Minutes & 0x7f ;
     582:	81 81       	ldd	r24, Z+1	; 0x01
     584:	8f 77       	andi	r24, 0x7F	; 127
     586:	8a 83       	std	Y+2, r24	; 0x02
		TempTime.Seconds = Time->Seconds & 0x7f ;
     588:	80 81       	ld	r24, Z
     58a:	8f 77       	andi	r24, 0x7F	; 127
     58c:	89 83       	std	Y+1, r24	; 0x01
	}

if(Time->RTC_AM_PM != 0u)
     58e:	f8 01       	movw	r30, r16
     590:	84 81       	ldd	r24, Z+4	; 0x04
     592:	88 23       	and	r24, r24
     594:	49 f0       	breq	.+18     	; 0x5a8 <RTC_Set_Time+0x68>
{
	
	if(Time->RTC_AM_PM == RTC_Time_PM )	// PM logic high & AM logic low
     596:	82 30       	cpi	r24, 0x02	; 2
     598:	21 f4       	brne	.+8      	; 0x5a2 <RTC_Set_Time+0x62>
	TempTime.Hours |= 0x40u ;
     59a:	8b 81       	ldd	r24, Y+3	; 0x03
     59c:	80 64       	ori	r24, 0x40	; 64
     59e:	8b 83       	std	Y+3, r24	; 0x03
     5a0:	03 c0       	rjmp	.+6      	; 0x5a8 <RTC_Set_Time+0x68>
	else
	TempTime.Hours |= 0x60u ;
     5a2:	8b 81       	ldd	r24, Y+3	; 0x03
     5a4:	80 66       	ori	r24, 0x60	; 96
     5a6:	8b 83       	std	Y+3, r24	; 0x03
}


/*here we'll send all Time information to DS1305 Module */
HAL_I2C_Mem_Write(&I2cHandler,0xd0,0x00,&TempTime.Seconds,3);
     5a8:	03 e0       	ldi	r16, 0x03	; 3
     5aa:	9e 01       	movw	r18, r28
     5ac:	2f 5f       	subi	r18, 0xFF	; 255
     5ae:	3f 4f       	sbci	r19, 0xFF	; 255
     5b0:	40 e0       	ldi	r20, 0x00	; 0
     5b2:	60 ed       	ldi	r22, 0xD0	; 208
     5b4:	86 e6       	ldi	r24, 0x66	; 102
     5b6:	90 e0       	ldi	r25, 0x00	; 0
     5b8:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <HAL_I2C_Mem_Write>
	
	
	
}/* End_Of RTC_Set_Time() */
     5bc:	0f 90       	pop	r0
     5be:	0f 90       	pop	r0
     5c0:	0f 90       	pop	r0
     5c2:	0f 90       	pop	r0
     5c4:	0f 90       	pop	r0
     5c6:	df 91       	pop	r29
     5c8:	cf 91       	pop	r28
     5ca:	1f 91       	pop	r17
     5cc:	0f 91       	pop	r16
     5ce:	08 95       	ret

000005d0 <RTC_Set_Date>:
/* brief : this function used to Set DS1305 Current Date 
 * param : Date_Typedef handler struct pointer hold all Date informations that will send from DS1305 
 * return : void 
 */
void RTC_Set_Date(Date_Typedef * Date)
{
     5d0:	0f 93       	push	r16
     5d2:	1f 93       	push	r17
     5d4:	cf 93       	push	r28
     5d6:	df 93       	push	r29
     5d8:	00 d0       	rcall	.+0      	; 0x5da <RTC_Set_Date+0xa>
     5da:	00 d0       	rcall	.+0      	; 0x5dc <RTC_Set_Date+0xc>
     5dc:	1f 92       	push	r1
     5de:	cd b7       	in	r28, 0x3d	; 61
     5e0:	de b7       	in	r29, 0x3e	; 62
     5e2:	8c 01       	movw	r16, r24
	Date_Typedef TempDate ;
	
	/* check the format of the data that send by the user in Date_Typedef Var */
	if(Date->RTC_Time_Format == RTC_Format_BIN)
     5e4:	fc 01       	movw	r30, r24
     5e6:	84 81       	ldd	r24, Z+4	; 0x04
     5e8:	82 30       	cpi	r24, 0x02	; 2
     5ea:	79 f4       	brne	.+30     	; 0x60a <RTC_Set_Date+0x3a>
	{
		
		TempDate.DayDate   = Convert_BIN_To_BCD(Date->DayDate);
     5ec:	81 81       	ldd	r24, Z+1	; 0x01
     5ee:	0e 94 7f 02 	call	0x4fe	; 0x4fe <Convert_BIN_To_BCD>
     5f2:	8a 83       	std	Y+2, r24	; 0x02
		TempDate.Year = Convert_BIN_To_BCD(Date->Year);
     5f4:	f8 01       	movw	r30, r16
     5f6:	83 81       	ldd	r24, Z+3	; 0x03
     5f8:	0e 94 7f 02 	call	0x4fe	; 0x4fe <Convert_BIN_To_BCD>
     5fc:	8c 83       	std	Y+4, r24	; 0x04
		TempDate.month = Convert_BIN_To_BCD(Date->month);
     5fe:	f8 01       	movw	r30, r16
     600:	82 81       	ldd	r24, Z+2	; 0x02
     602:	0e 94 7f 02 	call	0x4fe	; 0x4fe <Convert_BIN_To_BCD>
     606:	8b 83       	std	Y+3, r24	; 0x03
     608:	09 c0       	rjmp	.+18     	; 0x61c <RTC_Set_Date+0x4c>
		
		}else{
		TempDate.DayDate   = Date->DayDate   & 0x3f ;
     60a:	f8 01       	movw	r30, r16
     60c:	81 81       	ldd	r24, Z+1	; 0x01
     60e:	8f 73       	andi	r24, 0x3F	; 63
     610:	8a 83       	std	Y+2, r24	; 0x02
		TempDate.Year  = Date->Year  ;
     612:	83 81       	ldd	r24, Z+3	; 0x03
     614:	8c 83       	std	Y+4, r24	; 0x04
		TempDate.month = Date->month & 0x3f ;
     616:	82 81       	ldd	r24, Z+2	; 0x02
     618:	8f 73       	andi	r24, 0x3F	; 63
     61a:	8b 83       	std	Y+3, r24	; 0x03
		}
	TempDate.Day = Date->Day;
     61c:	f8 01       	movw	r30, r16
     61e:	80 81       	ld	r24, Z
     620:	89 83       	std	Y+1, r24	; 0x01
	
	/* here we'll set up the data For Ds1305 Module */
	HAL_I2C_Mem_Write(&I2cHandler,0xd0,0x03,&TempDate.Day,4);
     622:	04 e0       	ldi	r16, 0x04	; 4
     624:	9e 01       	movw	r18, r28
     626:	2f 5f       	subi	r18, 0xFF	; 255
     628:	3f 4f       	sbci	r19, 0xFF	; 255
     62a:	43 e0       	ldi	r20, 0x03	; 3
     62c:	60 ed       	ldi	r22, 0xD0	; 208
     62e:	86 e6       	ldi	r24, 0x66	; 102
     630:	90 e0       	ldi	r25, 0x00	; 0
     632:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <HAL_I2C_Mem_Write>

	
}/* End_Of RTC_Set_Time() */
     636:	0f 90       	pop	r0
     638:	0f 90       	pop	r0
     63a:	0f 90       	pop	r0
     63c:	0f 90       	pop	r0
     63e:	0f 90       	pop	r0
     640:	df 91       	pop	r29
     642:	cf 91       	pop	r28
     644:	1f 91       	pop	r17
     646:	0f 91       	pop	r16
     648:	08 95       	ret

0000064a <S7egment_Init>:



	
void S7egment_Init(Seg7_Handler *  Segment_Handler)
{
     64a:	ef 92       	push	r14
     64c:	ff 92       	push	r15
     64e:	0f 93       	push	r16
     650:	1f 93       	push	r17
     652:	cf 93       	push	r28
     654:	df 93       	push	r29
     656:	00 d0       	rcall	.+0      	; 0x658 <S7egment_Init+0xe>
     658:	1f 92       	push	r1
     65a:	cd b7       	in	r28, 0x3d	; 61
     65c:	de b7       	in	r29, 0x3e	; 62
     65e:	7c 01       	movw	r14, r24
		GPIO_InitTypeDef  S7eg_PIN_CONFIG ;

	
	S7eg_PIN_CONFIG.mode = GPIO_MODE_OUTPUT ;
     660:	81 e0       	ldi	r24, 0x01	; 1
     662:	8a 83       	std	Y+2, r24	; 0x02
	S7eg_PIN_CONFIG.pull = GPIO_NOPULL ;
     664:	1b 82       	std	Y+3, r1	; 0x03
	/*initialize all control bits  */
	for (int i=0 ; i < 6 ;i++ )
     666:	00 e0       	ldi	r16, 0x00	; 0
     668:	10 e0       	ldi	r17, 0x00	; 0
     66a:	12 c0       	rjmp	.+36     	; 0x690 <S7egment_Init+0x46>
	{
		S7eg_PIN_CONFIG.pinS = Segment_Handler->S7eg_Control[i].Pin_Num ;	
     66c:	f8 01       	movw	r30, r16
     66e:	ee 0f       	add	r30, r30
     670:	ff 1f       	adc	r31, r31
     672:	e0 0f       	add	r30, r16
     674:	f1 1f       	adc	r31, r17
     676:	ee 0d       	add	r30, r14
     678:	ff 1d       	adc	r31, r15
     67a:	82 81       	ldd	r24, Z+2	; 0x02
     67c:	89 83       	std	Y+1, r24	; 0x01
		HAL_GPIO_INIT_PIN(Segment_Handler->S7eg_Control[i].Port,&S7eg_PIN_CONFIG);	
     67e:	be 01       	movw	r22, r28
     680:	6f 5f       	subi	r22, 0xFF	; 255
     682:	7f 4f       	sbci	r23, 0xFF	; 255
     684:	80 81       	ld	r24, Z
     686:	91 81       	ldd	r25, Z+1	; 0x01
     688:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <HAL_GPIO_INIT_PIN>

	
	S7eg_PIN_CONFIG.mode = GPIO_MODE_OUTPUT ;
	S7eg_PIN_CONFIG.pull = GPIO_NOPULL ;
	/*initialize all control bits  */
	for (int i=0 ; i < 6 ;i++ )
     68c:	0f 5f       	subi	r16, 0xFF	; 255
     68e:	1f 4f       	sbci	r17, 0xFF	; 255
     690:	06 30       	cpi	r16, 0x06	; 6
     692:	11 05       	cpc	r17, r1
     694:	5c f3       	brlt	.-42     	; 0x66c <S7egment_Init+0x22>
     696:	00 e0       	ldi	r16, 0x00	; 0
     698:	10 e0       	ldi	r17, 0x00	; 0
     69a:	12 c0       	rjmp	.+36     	; 0x6c0 <S7egment_Init+0x76>


	/*initialize 7 segment BCD Bits */	
	for (int i=0 ; i < 4 ;i++ )
	{
		S7eg_PIN_CONFIG.pinS = Segment_Handler->S7eg_Bits[i].Pin_Num;
     69c:	f8 01       	movw	r30, r16
     69e:	ee 0f       	add	r30, r30
     6a0:	ff 1f       	adc	r31, r31
     6a2:	e0 0f       	add	r30, r16
     6a4:	f1 1f       	adc	r31, r17
     6a6:	ee 0d       	add	r30, r14
     6a8:	ff 1d       	adc	r31, r15
     6aa:	84 89       	ldd	r24, Z+20	; 0x14
     6ac:	89 83       	std	Y+1, r24	; 0x01
		HAL_GPIO_INIT_PIN(Segment_Handler->S7eg_Bits[i].Port,&S7eg_PIN_CONFIG);
     6ae:	be 01       	movw	r22, r28
     6b0:	6f 5f       	subi	r22, 0xFF	; 255
     6b2:	7f 4f       	sbci	r23, 0xFF	; 255
     6b4:	82 89       	ldd	r24, Z+18	; 0x12
     6b6:	93 89       	ldd	r25, Z+19	; 0x13
     6b8:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <HAL_GPIO_INIT_PIN>
		HAL_GPIO_INIT_PIN(Segment_Handler->S7eg_Control[i].Port,&S7eg_PIN_CONFIG);	
	}


	/*initialize 7 segment BCD Bits */	
	for (int i=0 ; i < 4 ;i++ )
     6bc:	0f 5f       	subi	r16, 0xFF	; 255
     6be:	1f 4f       	sbci	r17, 0xFF	; 255
     6c0:	04 30       	cpi	r16, 0x04	; 4
     6c2:	11 05       	cpc	r17, r1
     6c4:	5c f3       	brlt	.-42     	; 0x69c <S7egment_Init+0x52>
		HAL_GPIO_INIT_PIN(Segment_Handler->S7eg_Bits[i].Port,&S7eg_PIN_CONFIG);
	}	
	
	
	
}
     6c6:	0f 90       	pop	r0
     6c8:	0f 90       	pop	r0
     6ca:	0f 90       	pop	r0
     6cc:	df 91       	pop	r29
     6ce:	cf 91       	pop	r28
     6d0:	1f 91       	pop	r17
     6d2:	0f 91       	pop	r16
     6d4:	ff 90       	pop	r15
     6d6:	ef 90       	pop	r14
     6d8:	08 95       	ret

000006da <S7egment_Write>:
void S7egment_Write(uint8_t Num_To_S7eg , uint8_t S7eg_Num,Seg7_Handler *  Segment_Handler)
{
     6da:	df 92       	push	r13
     6dc:	ef 92       	push	r14
     6de:	ff 92       	push	r15
     6e0:	0f 93       	push	r16
     6e2:	1f 93       	push	r17
     6e4:	cf 93       	push	r28
     6e6:	df 93       	push	r29
     6e8:	06 2f       	mov	r16, r22
     6ea:	ea 01       	movw	r28, r20


	uint8_t High_Num=0,Low_Num=0 ;
	Low_Num = Num_To_S7eg % 10 ;
     6ec:	9d ec       	ldi	r25, 0xCD	; 205
     6ee:	89 9f       	mul	r24, r25
     6f0:	d1 2c       	mov	r13, r1
     6f2:	11 24       	eor	r1, r1
     6f4:	d6 94       	lsr	r13
     6f6:	d6 94       	lsr	r13
     6f8:	d6 94       	lsr	r13
     6fa:	dd 0c       	add	r13, r13
     6fc:	9d 2d       	mov	r25, r13
     6fe:	99 0f       	add	r25, r25
     700:	99 0f       	add	r25, r25
     702:	d9 0e       	add	r13, r25
     704:	98 2f       	mov	r25, r24
     706:	9d 19       	sub	r25, r13
     708:	d9 2e       	mov	r13, r25
	if (Num_To_S7eg == 0)
     70a:	88 23       	and	r24, r24
     70c:	b9 f0       	breq	.+46     	; 0x73c <S7egment_Write+0x62>
	{
		
	}
	else
	{
	Num_To_S7eg /= 10 ;
     70e:	9d ec       	ldi	r25, 0xCD	; 205
     710:	89 9f       	mul	r24, r25
     712:	81 2d       	mov	r24, r1
     714:	11 24       	eor	r1, r1
     716:	86 95       	lsr	r24
     718:	86 95       	lsr	r24
     71a:	86 95       	lsr	r24
	if (Num_To_S7eg > 0){
     71c:	89 f0       	breq	.+34     	; 0x740 <S7egment_Write+0x66>
		High_Num = Num_To_S7eg % 10 ;
     71e:	1d ec       	ldi	r17, 0xCD	; 205
     720:	81 9f       	mul	r24, r17
     722:	11 2d       	mov	r17, r1
     724:	11 24       	eor	r1, r1
     726:	16 95       	lsr	r17
     728:	16 95       	lsr	r17
     72a:	16 95       	lsr	r17
     72c:	11 0f       	add	r17, r17
     72e:	91 2f       	mov	r25, r17
     730:	99 0f       	add	r25, r25
     732:	99 0f       	add	r25, r25
     734:	19 0f       	add	r17, r25
     736:	81 1b       	sub	r24, r17
     738:	18 2f       	mov	r17, r24
     73a:	03 c0       	rjmp	.+6      	; 0x742 <S7egment_Write+0x68>
}
void S7egment_Write(uint8_t Num_To_S7eg , uint8_t S7eg_Num,Seg7_Handler *  Segment_Handler)
{


	uint8_t High_Num=0,Low_Num=0 ;
     73c:	10 e0       	ldi	r17, 0x00	; 0
     73e:	01 c0       	rjmp	.+2      	; 0x742 <S7egment_Write+0x68>
	{
	Num_To_S7eg /= 10 ;
	if (Num_To_S7eg > 0){
		High_Num = Num_To_S7eg % 10 ;
		}else{
		High_Num = 0 ;
     740:	10 e0       	ldi	r17, 0x00	; 0
	}
	}

	for(int i =0 ;i<4 ;i++)
     742:	e1 2c       	mov	r14, r1
     744:	f1 2c       	mov	r15, r1
     746:	18 c0       	rjmp	.+48     	; 0x778 <S7egment_Write+0x9e>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Bits[i].Port,Segment_Handler->S7eg_Bits[i].Pin_Num,(High_Num>>i)&(0x01));
     748:	41 2f       	mov	r20, r17
     74a:	50 e0       	ldi	r21, 0x00	; 0
     74c:	0e 2c       	mov	r0, r14
     74e:	02 c0       	rjmp	.+4      	; 0x754 <S7egment_Write+0x7a>
     750:	55 95       	asr	r21
     752:	47 95       	ror	r20
     754:	0a 94       	dec	r0
     756:	e2 f7       	brpl	.-8      	; 0x750 <S7egment_Write+0x76>
     758:	41 70       	andi	r20, 0x01	; 1
     75a:	f7 01       	movw	r30, r14
     75c:	ee 0f       	add	r30, r30
     75e:	ff 1f       	adc	r31, r31
     760:	ee 0d       	add	r30, r14
     762:	ff 1d       	adc	r31, r15
     764:	ec 0f       	add	r30, r28
     766:	fd 1f       	adc	r31, r29
     768:	64 89       	ldd	r22, Z+20	; 0x14
     76a:	82 89       	ldd	r24, Z+18	; 0x12
     76c:	93 89       	ldd	r25, Z+19	; 0x13
     76e:	0e 94 1c 01 	call	0x238	; 0x238 <HAL_GPIO_WRITEPIN>
		}else{
		High_Num = 0 ;
	}
	}

	for(int i =0 ;i<4 ;i++)
     772:	ef ef       	ldi	r30, 0xFF	; 255
     774:	ee 1a       	sub	r14, r30
     776:	fe 0a       	sbc	r15, r30
     778:	f4 e0       	ldi	r31, 0x04	; 4
     77a:	ef 16       	cp	r14, r31
     77c:	f1 04       	cpc	r15, r1
     77e:	24 f3       	brlt	.-56     	; 0x748 <S7egment_Write+0x6e>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Bits[i].Port,Segment_Handler->S7eg_Bits[i].Pin_Num,(High_Num>>i)&(0x01));
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Control[S7eg_Num].Port,Segment_Handler->S7eg_Control[S7eg_Num].Pin_Num,1);
     780:	10 e0       	ldi	r17, 0x00	; 0
     782:	78 01       	movw	r14, r16
     784:	ee 0c       	add	r14, r14
     786:	ff 1c       	adc	r15, r15
     788:	e0 0e       	add	r14, r16
     78a:	f1 1e       	adc	r15, r17
     78c:	ec 0e       	add	r14, r28
     78e:	fd 1e       	adc	r15, r29
     790:	41 e0       	ldi	r20, 0x01	; 1
     792:	f7 01       	movw	r30, r14
     794:	62 81       	ldd	r22, Z+2	; 0x02
     796:	80 81       	ld	r24, Z
     798:	91 81       	ldd	r25, Z+1	; 0x01
     79a:	0e 94 1c 01 	call	0x238	; 0x238 <HAL_GPIO_WRITEPIN>
	vTaskDelay(1);
     79e:	81 e0       	ldi	r24, 0x01	; 1
     7a0:	90 e0       	ldi	r25, 0x00	; 0
     7a2:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <vTaskDelay>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Control[S7eg_Num].Port,Segment_Handler->S7eg_Control[S7eg_Num].Pin_Num,0);
     7a6:	40 e0       	ldi	r20, 0x00	; 0
     7a8:	f7 01       	movw	r30, r14
     7aa:	62 81       	ldd	r22, Z+2	; 0x02
     7ac:	80 81       	ld	r24, Z
     7ae:	91 81       	ldd	r25, Z+1	; 0x01
     7b0:	0e 94 1c 01 	call	0x238	; 0x238 <HAL_GPIO_WRITEPIN>

	
	for(int i =0 ;i<4 ;i++)
     7b4:	e1 2c       	mov	r14, r1
     7b6:	f1 2c       	mov	r15, r1
     7b8:	18 c0       	rjmp	.+48     	; 0x7ea <S7egment_Write+0x110>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Bits[i].Port,Segment_Handler->S7eg_Bits[i].Pin_Num,(Low_Num>>i)&(0x01));
     7ba:	4d 2d       	mov	r20, r13
     7bc:	50 e0       	ldi	r21, 0x00	; 0
     7be:	0e 2c       	mov	r0, r14
     7c0:	02 c0       	rjmp	.+4      	; 0x7c6 <S7egment_Write+0xec>
     7c2:	55 95       	asr	r21
     7c4:	47 95       	ror	r20
     7c6:	0a 94       	dec	r0
     7c8:	e2 f7       	brpl	.-8      	; 0x7c2 <S7egment_Write+0xe8>
     7ca:	41 70       	andi	r20, 0x01	; 1
     7cc:	f7 01       	movw	r30, r14
     7ce:	ee 0f       	add	r30, r30
     7d0:	ff 1f       	adc	r31, r31
     7d2:	ee 0d       	add	r30, r14
     7d4:	ff 1d       	adc	r31, r15
     7d6:	ec 0f       	add	r30, r28
     7d8:	fd 1f       	adc	r31, r29
     7da:	64 89       	ldd	r22, Z+20	; 0x14
     7dc:	82 89       	ldd	r24, Z+18	; 0x12
     7de:	93 89       	ldd	r25, Z+19	; 0x13
     7e0:	0e 94 1c 01 	call	0x238	; 0x238 <HAL_GPIO_WRITEPIN>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Control[S7eg_Num].Port,Segment_Handler->S7eg_Control[S7eg_Num].Pin_Num,1);
	vTaskDelay(1);
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Control[S7eg_Num].Port,Segment_Handler->S7eg_Control[S7eg_Num].Pin_Num,0);

	
	for(int i =0 ;i<4 ;i++)
     7e4:	ff ef       	ldi	r31, 0xFF	; 255
     7e6:	ef 1a       	sub	r14, r31
     7e8:	ff 0a       	sbc	r15, r31
     7ea:	84 e0       	ldi	r24, 0x04	; 4
     7ec:	e8 16       	cp	r14, r24
     7ee:	f1 04       	cpc	r15, r1
     7f0:	24 f3       	brlt	.-56     	; 0x7ba <S7egment_Write+0xe0>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Bits[i].Port,Segment_Handler->S7eg_Bits[i].Pin_Num,(Low_Num>>i)&(0x01));
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Control[S7eg_Num+1].Port,Segment_Handler->S7eg_Control[S7eg_Num+1].Pin_Num,1);
     7f2:	0f 5f       	subi	r16, 0xFF	; 255
     7f4:	1f 4f       	sbci	r17, 0xFF	; 255
     7f6:	c8 01       	movw	r24, r16
     7f8:	88 0f       	add	r24, r24
     7fa:	99 1f       	adc	r25, r25
     7fc:	08 0f       	add	r16, r24
     7fe:	19 1f       	adc	r17, r25
     800:	c0 0f       	add	r28, r16
     802:	d1 1f       	adc	r29, r17
     804:	41 e0       	ldi	r20, 0x01	; 1
     806:	6a 81       	ldd	r22, Y+2	; 0x02
     808:	88 81       	ld	r24, Y
     80a:	99 81       	ldd	r25, Y+1	; 0x01
     80c:	0e 94 1c 01 	call	0x238	; 0x238 <HAL_GPIO_WRITEPIN>
	vTaskDelay(6);	
     810:	86 e0       	ldi	r24, 0x06	; 6
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <vTaskDelay>
	HAL_GPIO_WRITEPIN(Segment_Handler->S7eg_Control[S7eg_Num+1].Port,Segment_Handler->S7eg_Control[S7eg_Num+1].Pin_Num,0);
     818:	40 e0       	ldi	r20, 0x00	; 0
     81a:	6a 81       	ldd	r22, Y+2	; 0x02
     81c:	88 81       	ld	r24, Y
     81e:	99 81       	ldd	r25, Y+1	; 0x01
     820:	0e 94 1c 01 	call	0x238	; 0x238 <HAL_GPIO_WRITEPIN>
     824:	df 91       	pop	r29
     826:	cf 91       	pop	r28
     828:	1f 91       	pop	r17
     82a:	0f 91       	pop	r16
     82c:	ff 90       	pop	r15
     82e:	ef 90       	pop	r14
     830:	df 90       	pop	r13
     832:	08 95       	ret

00000834 <InterrutInt>:
EXIT_Handler_t  exti_handler ;



void InterrutInt(void)
{
     834:	cf 93       	push	r28
     836:	df 93       	push	r29
		exti_handler.EXTI_NUM = EXTI_NUM_0 ;
     838:	cb ef       	ldi	r28, 0xFB	; 251
     83a:	d0 e0       	ldi	r29, 0x00	; 0
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	88 83       	st	Y, r24
		exti_handler.EXTI_EDGE_DETECTION = EXTI_EDGE_LOW_LENEL ;
     840:	19 82       	std	Y+1, r1	; 0x01
		EXTI_Init(&exti_handler);
     842:	ce 01       	movw	r24, r28
     844:	0e 94 49 00 	call	0x92	; 0x92 <EXTI_Init>
		
		exti_handler.EXTI_NUM = EXTI_NUM_1 ;
     848:	82 e0       	ldi	r24, 0x02	; 2
     84a:	88 83       	st	Y, r24
		exti_handler.EXTI_EDGE_DETECTION = EXTI_EDGE_LOW_LENEL ;
     84c:	19 82       	std	Y+1, r1	; 0x01
		EXTI_Init(&exti_handler);
     84e:	ce 01       	movw	r24, r28
     850:	0e 94 49 00 	call	0x92	; 0x92 <EXTI_Init>
		
		exti_handler.EXTI_NUM = EXTI_NUM_2 ;
     854:	18 82       	st	Y, r1
		exti_handler.EXTI_EDGE_DETECTION = EXTI_EDGE_LOW_LENEL ;
     856:	19 82       	std	Y+1, r1	; 0x01
		EXTI_Init(&exti_handler);
     858:	ce 01       	movw	r24, r28
     85a:	0e 94 49 00 	call	0x92	; 0x92 <EXTI_Init>
		
	
     85e:	df 91       	pop	r29
     860:	cf 91       	pop	r28
     862:	08 95       	ret

00000864 <INT0_Handler>:
void INT0_Handler(void )
{

	 static uint8_t i =0 ;

		xQueueSendFromISR(XQueueSYNC , &i , NULL);
     864:	20 e0       	ldi	r18, 0x00	; 0
     866:	40 e0       	ldi	r20, 0x00	; 0
     868:	50 e0       	ldi	r21, 0x00	; 0
     86a:	6e e9       	ldi	r22, 0x9E	; 158
     86c:	70 e0       	ldi	r23, 0x00	; 0
     86e:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <XQueueSYNC>
     872:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <XQueueSYNC+0x1>
     876:	0e 94 99 09 	call	0x1332	; 0x1332 <xQueueGenericSendFromISR>
		
		
	if(i++ == 1)
     87a:	80 91 9e 00 	lds	r24, 0x009E	; 0x80009e <i.2372>
     87e:	91 e0       	ldi	r25, 0x01	; 1
     880:	98 0f       	add	r25, r24
     882:	90 93 9e 00 	sts	0x009E, r25	; 0x80009e <i.2372>
     886:	81 30       	cpi	r24, 0x01	; 1
     888:	11 f4       	brne	.+4      	; 0x88e <INT0_Handler+0x2a>
		i=0 ;
     88a:	10 92 9e 00 	sts	0x009E, r1	; 0x80009e <i.2372>
     88e:	08 95       	ret

00000890 <SYNC_Task>:




void SYNC_Task(void  * Param) 
{
     890:	cf 93       	push	r28
     892:	df 93       	push	r29
     894:	00 d0       	rcall	.+0      	; 0x896 <SYNC_Task+0x6>
     896:	cd b7       	in	r28, 0x3d	; 61
     898:	de b7       	in	r29, 0x3e	; 62
int i =0 ;
     89a:	1a 82       	std	Y+2, r1	; 0x02
     89c:	19 82       	std	Y+1, r1	; 0x01

	while(1)
	{
		xQueueReceive(XQueueSYNC , &i ,portMAX_DELAY);
     89e:	20 e0       	ldi	r18, 0x00	; 0
     8a0:	4f ef       	ldi	r20, 0xFF	; 255
     8a2:	5f ef       	ldi	r21, 0xFF	; 255
     8a4:	be 01       	movw	r22, r28
     8a6:	6f 5f       	subi	r22, 0xFF	; 255
     8a8:	7f 4f       	sbci	r23, 0xFF	; 255
     8aa:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <XQueueSYNC>
     8ae:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <XQueueSYNC+0x1>
     8b2:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <xQueueGenericReceive>
		if (i == 0)
     8b6:	89 81       	ldd	r24, Y+1	; 0x01
     8b8:	9a 81       	ldd	r25, Y+2	; 0x02
     8ba:	89 2b       	or	r24, r25
     8bc:	69 f4       	brne	.+26     	; 0x8d8 <SYNC_Task+0x48>
		{
		
		vTaskSuspend(ShowTimeTaskhandler);
     8be:	80 91 ff 00 	lds	r24, 0x00FF	; 0x8000ff <ShowTimeTaskhandler>
     8c2:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <ShowTimeTaskhandler+0x1>
     8c6:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vTaskSuspend>
		vTaskResume(ShowDateTaskhandler);
     8ca:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <ShowDateTaskhandler>
     8ce:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <ShowDateTaskhandler+0x1>
     8d2:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <vTaskResume>
     8d6:	0c c0       	rjmp	.+24     	; 0x8f0 <SYNC_Task+0x60>
		}
		else
		{
		vTaskSuspend(ShowDateTaskhandler);
     8d8:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <ShowDateTaskhandler>
     8dc:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <ShowDateTaskhandler+0x1>
     8e0:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vTaskSuspend>
		vTaskResume(ShowTimeTaskhandler);			
     8e4:	80 91 ff 00 	lds	r24, 0x00FF	; 0x8000ff <ShowTimeTaskhandler>
     8e8:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <ShowTimeTaskhandler+0x1>
     8ec:	0e 94 78 0c 	call	0x18f0	; 0x18f0 <vTaskResume>
			
		}
		vTaskDelay(5);
     8f0:	85 e0       	ldi	r24, 0x05	; 5
     8f2:	90 e0       	ldi	r25, 0x00	; 0
     8f4:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <vTaskDelay>
		
	}
     8f8:	d2 cf       	rjmp	.-92     	; 0x89e <SYNC_Task+0xe>

000008fa <main>:


int main(void)
{
	
	DS1305_Init();
     8fa:	0e 94 d9 01 	call	0x3b2	; 0x3b2 <DS1305_Init>
	S7egment_Init(&S7egHendler);
     8fe:	89 e7       	ldi	r24, 0x79	; 121
     900:	90 e0       	ldi	r25, 0x00	; 0
     902:	0e 94 25 03 	call	0x64a	; 0x64a <S7egment_Init>
	RTC_Set_Time(&Time);
     906:	84 e7       	ldi	r24, 0x74	; 116
     908:	90 e0       	ldi	r25, 0x00	; 0
     90a:	0e 94 a0 02 	call	0x540	; 0x540 <RTC_Set_Time>
	RTC_Set_Date(&Date);
     90e:	8f e6       	ldi	r24, 0x6F	; 111
     910:	90 e0       	ldi	r25, 0x00	; 0
     912:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <RTC_Set_Date>
	
	
	InterrutInt();
     916:	0e 94 1a 04 	call	0x834	; 0x834 <InterrutInt>
	EXIT_INT0_CallBack(INT0_Handler);
     91a:	82 e3       	ldi	r24, 0x32	; 50
     91c:	94 e0       	ldi	r25, 0x04	; 4
     91e:	0e 94 81 00 	call	0x102	; 0x102 <EXIT_INT0_CallBack>
	
		xMutexGoalKeeper = xSemaphoreCreateMutex();	
     922:	81 e0       	ldi	r24, 0x01	; 1
     924:	0e 94 8b 09 	call	0x1316	; 0x1316 <xQueueCreateMutex>
     928:	90 93 fe 00 	sts	0x00FE, r25	; 0x8000fe <xMutexGoalKeeper+0x1>
     92c:	80 93 fd 00 	sts	0x00FD, r24	; 0x8000fd <xMutexGoalKeeper>
	
	
	
	XMailboxGoalKeeper  = xQueueCreate(1,sizeof(RTC_Data));
     930:	40 e0       	ldi	r20, 0x00	; 0
     932:	6a e0       	ldi	r22, 0x0A	; 10
     934:	81 e0       	ldi	r24, 0x01	; 1
     936:	0e 94 bf 08 	call	0x117e	; 0x117e <xQueueGenericCreate>
     93a:	90 93 04 01 	sts	0x0104, r25	; 0x800104 <XMailboxGoalKeeper+0x1>
     93e:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <XMailboxGoalKeeper>
	
	XQueueSYNC     = xQueueCreate(1,sizeof(uint8_t));
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	61 e0       	ldi	r22, 0x01	; 1
     946:	81 e0       	ldi	r24, 0x01	; 1
     948:	0e 94 bf 08 	call	0x117e	; 0x117e <xQueueGenericCreate>
     94c:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <XQueueSYNC+0x1>
     950:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <XQueueSYNC>
	
	xTaskCreate(ShowTimeTask,NULL,200,NULL,1,&ShowTimeTaskhandler);
     954:	0f 2e       	mov	r0, r31
     956:	ff ef       	ldi	r31, 0xFF	; 255
     958:	ef 2e       	mov	r14, r31
     95a:	f0 e0       	ldi	r31, 0x00	; 0
     95c:	ff 2e       	mov	r15, r31
     95e:	f0 2d       	mov	r31, r0
     960:	01 e0       	ldi	r16, 0x01	; 1
     962:	20 e0       	ldi	r18, 0x00	; 0
     964:	30 e0       	ldi	r19, 0x00	; 0
     966:	48 ec       	ldi	r20, 0xC8	; 200
     968:	50 e0       	ldi	r21, 0x00	; 0
     96a:	60 e0       	ldi	r22, 0x00	; 0
     96c:	70 e0       	ldi	r23, 0x00	; 0
     96e:	85 ee       	ldi	r24, 0xE5	; 229
     970:	94 e0       	ldi	r25, 0x04	; 4
     972:	0e 94 24 0c 	call	0x1848	; 0x1848 <xTaskCreate>
	xTaskCreate(ShowDateTask,NULL,200,NULL,1,&ShowDateTaskhandler);	
     976:	0f 2e       	mov	r0, r31
     978:	ff e0       	ldi	r31, 0x0F	; 15
     97a:	ef 2e       	mov	r14, r31
     97c:	f1 e0       	ldi	r31, 0x01	; 1
     97e:	ff 2e       	mov	r15, r31
     980:	f0 2d       	mov	r31, r0
     982:	20 e0       	ldi	r18, 0x00	; 0
     984:	30 e0       	ldi	r19, 0x00	; 0
     986:	48 ec       	ldi	r20, 0xC8	; 200
     988:	50 e0       	ldi	r21, 0x00	; 0
     98a:	60 e0       	ldi	r22, 0x00	; 0
     98c:	70 e0       	ldi	r23, 0x00	; 0
     98e:	8b e1       	ldi	r24, 0x1B	; 27
     990:	95 e0       	ldi	r25, 0x05	; 5
     992:	0e 94 24 0c 	call	0x1848	; 0x1848 <xTaskCreate>
	xTaskCreate(GoalKeeper_Task,NULL,200,NULL,3,NULL);	
     996:	e1 2c       	mov	r14, r1
     998:	f1 2c       	mov	r15, r1
     99a:	03 e0       	ldi	r16, 0x03	; 3
     99c:	20 e0       	ldi	r18, 0x00	; 0
     99e:	30 e0       	ldi	r19, 0x00	; 0
     9a0:	48 ec       	ldi	r20, 0xC8	; 200
     9a2:	50 e0       	ldi	r21, 0x00	; 0
     9a4:	60 e0       	ldi	r22, 0x00	; 0
     9a6:	70 e0       	ldi	r23, 0x00	; 0
     9a8:	81 e5       	ldi	r24, 0x51	; 81
     9aa:	95 e0       	ldi	r25, 0x05	; 5
     9ac:	0e 94 24 0c 	call	0x1848	; 0x1848 <xTaskCreate>
	xTaskCreate(SYNC_Task,NULL,85,NULL,3,NULL);	
     9b0:	20 e0       	ldi	r18, 0x00	; 0
     9b2:	30 e0       	ldi	r19, 0x00	; 0
     9b4:	45 e5       	ldi	r20, 0x55	; 85
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	88 e4       	ldi	r24, 0x48	; 72
     9be:	94 e0       	ldi	r25, 0x04	; 4
     9c0:	0e 94 24 0c 	call	0x1848	; 0x1848 <xTaskCreate>
	
	
		vTaskStartScheduler();
     9c4:	0e 94 ba 0c 	call	0x1974	; 0x1974 <vTaskStartScheduler>
     9c8:	ff cf       	rjmp	.-2      	; 0x9c8 <main+0xce>

000009ca <ShowTimeTask>:
extern Seg7_Handler S7egHendler ;


/* main task that functionality is present  Time on the 7 Segment display */
void   ShowTimeTask(void  * param)
{
     9ca:	cf 93       	push	r28
     9cc:	df 93       	push	r29
     9ce:	cd b7       	in	r28, 0x3d	; 61
     9d0:	de b7       	in	r29, 0x3e	; 62
     9d2:	2a 97       	sbiw	r28, 0x0a	; 10
     9d4:	0f b6       	in	r0, 0x3f	; 63
     9d6:	f8 94       	cli
     9d8:	de bf       	out	0x3e, r29	; 62
     9da:	0f be       	out	0x3f, r0	; 63
     9dc:	cd bf       	out	0x3d, r28	; 61

	
	struct _GoalKeeperStruct  Buf = {0} ;	
     9de:	fe 01       	movw	r30, r28
     9e0:	31 96       	adiw	r30, 0x01	; 1
     9e2:	8a e0       	ldi	r24, 0x0A	; 10
     9e4:	df 01       	movw	r26, r30
     9e6:	1d 92       	st	X+, r1
     9e8:	8a 95       	dec	r24
     9ea:	e9 f7       	brne	.-6      	; 0x9e6 <ShowTimeTask+0x1c>
			Buf.RTCTime.RTC_Time_Format = RTC_Format_BIN ;
     9ec:	82 e0       	ldi	r24, 0x02	; 2
     9ee:	8c 83       	std	Y+4, r24	; 0x04

	
	while(1)
	{
			xQueueReceive(XMailboxGoalKeeper, &Buf ,1);	
     9f0:	20 e0       	ldi	r18, 0x00	; 0
     9f2:	41 e0       	ldi	r20, 0x01	; 1
     9f4:	50 e0       	ldi	r21, 0x00	; 0
     9f6:	be 01       	movw	r22, r28
     9f8:	6f 5f       	subi	r22, 0xFF	; 255
     9fa:	7f 4f       	sbci	r23, 0xFF	; 255
     9fc:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <XMailboxGoalKeeper>
     a00:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <XMailboxGoalKeeper+0x1>
     a04:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <xQueueGenericReceive>
			S7egment_Write(Buf.RTCTime.Hours  , 0,&S7egHendler);
     a08:	49 e7       	ldi	r20, 0x79	; 121
     a0a:	50 e0       	ldi	r21, 0x00	; 0
     a0c:	60 e0       	ldi	r22, 0x00	; 0
     a0e:	8b 81       	ldd	r24, Y+3	; 0x03
     a10:	0e 94 6d 03 	call	0x6da	; 0x6da <S7egment_Write>
			S7egment_Write(Buf.RTCTime.Minutes ,2,&S7egHendler);
     a14:	49 e7       	ldi	r20, 0x79	; 121
     a16:	50 e0       	ldi	r21, 0x00	; 0
     a18:	62 e0       	ldi	r22, 0x02	; 2
     a1a:	8a 81       	ldd	r24, Y+2	; 0x02
     a1c:	0e 94 6d 03 	call	0x6da	; 0x6da <S7egment_Write>
			S7egment_Write(Buf.RTCTime.Seconds ,4,&S7egHendler);	
     a20:	49 e7       	ldi	r20, 0x79	; 121
     a22:	50 e0       	ldi	r21, 0x00	; 0
     a24:	64 e0       	ldi	r22, 0x04	; 4
     a26:	89 81       	ldd	r24, Y+1	; 0x01
     a28:	0e 94 6d 03 	call	0x6da	; 0x6da <S7egment_Write>
			vTaskDelay(1);
     a2c:	81 e0       	ldi	r24, 0x01	; 1
     a2e:	90 e0       	ldi	r25, 0x00	; 0
     a30:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <vTaskDelay>
     a34:	dd cf       	rjmp	.-70     	; 0x9f0 <ShowTimeTask+0x26>

00000a36 <ShowDateTask>:
		
	}
}

void ShowDateTask(void  * param)
{
     a36:	cf 93       	push	r28
     a38:	df 93       	push	r29
     a3a:	cd b7       	in	r28, 0x3d	; 61
     a3c:	de b7       	in	r29, 0x3e	; 62
     a3e:	2a 97       	sbiw	r28, 0x0a	; 10
     a40:	0f b6       	in	r0, 0x3f	; 63
     a42:	f8 94       	cli
     a44:	de bf       	out	0x3e, r29	; 62
     a46:	0f be       	out	0x3f, r0	; 63
     a48:	cd bf       	out	0x3d, r28	; 61
	
	
	
struct _GoalKeeperStruct  Buf = {0} ;
     a4a:	fe 01       	movw	r30, r28
     a4c:	31 96       	adiw	r30, 0x01	; 1
     a4e:	8a e0       	ldi	r24, 0x0A	; 10
     a50:	df 01       	movw	r26, r30
     a52:	1d 92       	st	X+, r1
     a54:	8a 95       	dec	r24
     a56:	e9 f7       	brne	.-6      	; 0xa52 <ShowDateTask+0x1c>
	Buf.RTCDate.RTC_Time_Format = RTC_Format_BIN ;
     a58:	82 e0       	ldi	r24, 0x02	; 2
     a5a:	8a 87       	std	Y+10, r24	; 0x0a
	
	while(1)
	{
			xQueueReceive(XMailboxGoalKeeper, &Buf ,1);			
     a5c:	20 e0       	ldi	r18, 0x00	; 0
     a5e:	41 e0       	ldi	r20, 0x01	; 1
     a60:	50 e0       	ldi	r21, 0x00	; 0
     a62:	be 01       	movw	r22, r28
     a64:	6f 5f       	subi	r22, 0xFF	; 255
     a66:	7f 4f       	sbci	r23, 0xFF	; 255
     a68:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <XMailboxGoalKeeper>
     a6c:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <XMailboxGoalKeeper+0x1>
     a70:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <xQueueGenericReceive>
			S7egment_Write(Buf.RTCDate.Year , 0,&S7egHendler);
     a74:	49 e7       	ldi	r20, 0x79	; 121
     a76:	50 e0       	ldi	r21, 0x00	; 0
     a78:	60 e0       	ldi	r22, 0x00	; 0
     a7a:	89 85       	ldd	r24, Y+9	; 0x09
     a7c:	0e 94 6d 03 	call	0x6da	; 0x6da <S7egment_Write>
			S7egment_Write(Buf.RTCDate.month,2,&S7egHendler);
     a80:	49 e7       	ldi	r20, 0x79	; 121
     a82:	50 e0       	ldi	r21, 0x00	; 0
     a84:	62 e0       	ldi	r22, 0x02	; 2
     a86:	88 85       	ldd	r24, Y+8	; 0x08
     a88:	0e 94 6d 03 	call	0x6da	; 0x6da <S7egment_Write>
			S7egment_Write(Buf.RTCDate.Day  ,4,&S7egHendler);
     a8c:	49 e7       	ldi	r20, 0x79	; 121
     a8e:	50 e0       	ldi	r21, 0x00	; 0
     a90:	64 e0       	ldi	r22, 0x04	; 4
     a92:	8e 81       	ldd	r24, Y+6	; 0x06
     a94:	0e 94 6d 03 	call	0x6da	; 0x6da <S7egment_Write>
			vTaskDelay(1);	
     a98:	81 e0       	ldi	r24, 0x01	; 1
     a9a:	90 e0       	ldi	r25, 0x00	; 0
     a9c:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <vTaskDelay>
     aa0:	dd cf       	rjmp	.-70     	; 0xa5c <ShowDateTask+0x26>

00000aa2 <GoalKeeper_Task>:
	}	
}

void  GoalKeeper_Task(void * Param)
{
     aa2:	cf 93       	push	r28
     aa4:	df 93       	push	r29
     aa6:	cd b7       	in	r28, 0x3d	; 61
     aa8:	de b7       	in	r29, 0x3e	; 62
     aaa:	2a 97       	sbiw	r28, 0x0a	; 10
     aac:	0f b6       	in	r0, 0x3f	; 63
     aae:	f8 94       	cli
     ab0:	de bf       	out	0x3e, r29	; 62
     ab2:	0f be       	out	0x3f, r0	; 63
     ab4:	cd bf       	out	0x3d, r28	; 61
struct _GoalKeeperStruct  Buf = {0} ;
     ab6:	fe 01       	movw	r30, r28
     ab8:	31 96       	adiw	r30, 0x01	; 1
     aba:	8a e0       	ldi	r24, 0x0A	; 10
     abc:	df 01       	movw	r26, r30
     abe:	1d 92       	st	X+, r1
     ac0:	8a 95       	dec	r24
     ac2:	e9 f7       	brne	.-6      	; 0xabe <GoalKeeper_Task+0x1c>
		Buf.RTCDate.RTC_Time_Format = RTC_Format_BIN ;
     ac4:	82 e0       	ldi	r24, 0x02	; 2
     ac6:	8a 87       	std	Y+10, r24	; 0x0a
		Buf.RTCTime.RTC_Time_Format = RTC_Format_BIN ;
     ac8:	8c 83       	std	Y+4, r24	; 0x04
		vTaskSuspend(ShowDateTaskhandler);
     aca:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <ShowDateTaskhandler>
     ace:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <ShowDateTaskhandler+0x1>
     ad2:	0e 94 80 0e 	call	0x1d00	; 0x1d00 <vTaskSuspend>

	while(1)
	{
		/* access I2C non shared resources so we need to protect it through mutex */
		xSemaphoreTake(xMutexGoalKeeper,1);
     ad6:	20 e0       	ldi	r18, 0x00	; 0
     ad8:	41 e0       	ldi	r20, 0x01	; 1
     ada:	50 e0       	ldi	r21, 0x00	; 0
     adc:	60 e0       	ldi	r22, 0x00	; 0
     ade:	70 e0       	ldi	r23, 0x00	; 0
     ae0:	80 91 fd 00 	lds	r24, 0x00FD	; 0x8000fd <xMutexGoalKeeper>
     ae4:	90 91 fe 00 	lds	r25, 0x00FE	; 0x8000fe <xMutexGoalKeeper+0x1>
     ae8:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <xQueueGenericReceive>
		RTC_Get_Time(&Buf.RTCTime);
     aec:	ce 01       	movw	r24, r28
     aee:	01 96       	adiw	r24, 0x01	; 1
     af0:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <RTC_Get_Time>
		RTC_Get_Date(&Buf.RTCDate);
     af4:	ce 01       	movw	r24, r28
     af6:	06 96       	adiw	r24, 0x06	; 6
     af8:	0e 94 41 02 	call	0x482	; 0x482 <RTC_Get_Date>
		xSemaphoreGive(xMutexGoalKeeper);		
     afc:	20 e0       	ldi	r18, 0x00	; 0
     afe:	40 e0       	ldi	r20, 0x00	; 0
     b00:	50 e0       	ldi	r21, 0x00	; 0
     b02:	60 e0       	ldi	r22, 0x00	; 0
     b04:	70 e0       	ldi	r23, 0x00	; 0
     b06:	80 91 fd 00 	lds	r24, 0x00FD	; 0x8000fd <xMutexGoalKeeper>
     b0a:	90 91 fe 00 	lds	r25, 0x00FE	; 0x8000fe <xMutexGoalKeeper+0x1>
     b0e:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <xQueueGenericSend>
		
		/* use mailbox to send message */
		xQueueOverwrite(XMailboxGoalKeeper,&Buf);
     b12:	22 e0       	ldi	r18, 0x02	; 2
     b14:	40 e0       	ldi	r20, 0x00	; 0
     b16:	50 e0       	ldi	r21, 0x00	; 0
     b18:	be 01       	movw	r22, r28
     b1a:	6f 5f       	subi	r22, 0xFF	; 255
     b1c:	7f 4f       	sbci	r23, 0xFF	; 255
     b1e:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <XMailboxGoalKeeper>
     b22:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <XMailboxGoalKeeper+0x1>
     b26:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <xQueueGenericSend>
		vTaskDelay(700);
     b2a:	8c eb       	ldi	r24, 0xBC	; 188
     b2c:	92 e0       	ldi	r25, 0x02	; 2
     b2e:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <vTaskDelay>
     b32:	d1 cf       	rjmp	.-94     	; 0xad6 <GoalKeeper_Task+0x34>

00000b34 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     b34:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b36:	03 96       	adiw	r24, 0x03	; 3
     b38:	92 83       	std	Z+2, r25	; 0x02
     b3a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     b3c:	2f ef       	ldi	r18, 0xFF	; 255
     b3e:	3f ef       	ldi	r19, 0xFF	; 255
     b40:	34 83       	std	Z+4, r19	; 0x04
     b42:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b44:	96 83       	std	Z+6, r25	; 0x06
     b46:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b48:	90 87       	std	Z+8, r25	; 0x08
     b4a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     b4c:	10 82       	st	Z, r1
     b4e:	08 95       	ret

00000b50 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     b50:	fc 01       	movw	r30, r24
     b52:	11 86       	std	Z+9, r1	; 0x09
     b54:	10 86       	std	Z+8, r1	; 0x08
     b56:	08 95       	ret

00000b58 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     b58:	cf 93       	push	r28
     b5a:	df 93       	push	r29
     b5c:	9c 01       	movw	r18, r24
     b5e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     b60:	dc 01       	movw	r26, r24
     b62:	11 96       	adiw	r26, 0x01	; 1
     b64:	cd 91       	ld	r28, X+
     b66:	dc 91       	ld	r29, X
     b68:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     b6a:	d3 83       	std	Z+3, r29	; 0x03
     b6c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     b6e:	8c 81       	ldd	r24, Y+4	; 0x04
     b70:	9d 81       	ldd	r25, Y+5	; 0x05
     b72:	95 83       	std	Z+5, r25	; 0x05
     b74:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     b76:	8c 81       	ldd	r24, Y+4	; 0x04
     b78:	9d 81       	ldd	r25, Y+5	; 0x05
     b7a:	dc 01       	movw	r26, r24
     b7c:	13 96       	adiw	r26, 0x03	; 3
     b7e:	7c 93       	st	X, r23
     b80:	6e 93       	st	-X, r22
     b82:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     b84:	7d 83       	std	Y+5, r23	; 0x05
     b86:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     b88:	31 87       	std	Z+9, r19	; 0x09
     b8a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     b8c:	f9 01       	movw	r30, r18
     b8e:	80 81       	ld	r24, Z
     b90:	8f 5f       	subi	r24, 0xFF	; 255
     b92:	80 83       	st	Z, r24
}
     b94:	df 91       	pop	r29
     b96:	cf 91       	pop	r28
     b98:	08 95       	ret

00000b9a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     b9a:	cf 93       	push	r28
     b9c:	df 93       	push	r29
     b9e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     ba0:	48 81       	ld	r20, Y
     ba2:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     ba4:	4f 3f       	cpi	r20, 0xFF	; 255
     ba6:	2f ef       	ldi	r18, 0xFF	; 255
     ba8:	52 07       	cpc	r21, r18
     baa:	21 f4       	brne	.+8      	; 0xbb4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     bac:	fc 01       	movw	r30, r24
     bae:	a7 81       	ldd	r26, Z+7	; 0x07
     bb0:	b0 85       	ldd	r27, Z+8	; 0x08
     bb2:	0d c0       	rjmp	.+26     	; 0xbce <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     bb4:	dc 01       	movw	r26, r24
     bb6:	13 96       	adiw	r26, 0x03	; 3
     bb8:	01 c0       	rjmp	.+2      	; 0xbbc <vListInsert+0x22>
     bba:	df 01       	movw	r26, r30
     bbc:	12 96       	adiw	r26, 0x02	; 2
     bbe:	ed 91       	ld	r30, X+
     bc0:	fc 91       	ld	r31, X
     bc2:	13 97       	sbiw	r26, 0x03	; 3
     bc4:	20 81       	ld	r18, Z
     bc6:	31 81       	ldd	r19, Z+1	; 0x01
     bc8:	42 17       	cp	r20, r18
     bca:	53 07       	cpc	r21, r19
     bcc:	b0 f7       	brcc	.-20     	; 0xbba <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     bce:	12 96       	adiw	r26, 0x02	; 2
     bd0:	ed 91       	ld	r30, X+
     bd2:	fc 91       	ld	r31, X
     bd4:	13 97       	sbiw	r26, 0x03	; 3
     bd6:	fb 83       	std	Y+3, r31	; 0x03
     bd8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     bda:	d5 83       	std	Z+5, r29	; 0x05
     bdc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     bde:	bd 83       	std	Y+5, r27	; 0x05
     be0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     be2:	13 96       	adiw	r26, 0x03	; 3
     be4:	dc 93       	st	X, r29
     be6:	ce 93       	st	-X, r28
     be8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     bea:	99 87       	std	Y+9, r25	; 0x09
     bec:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     bee:	fc 01       	movw	r30, r24
     bf0:	20 81       	ld	r18, Z
     bf2:	2f 5f       	subi	r18, 0xFF	; 255
     bf4:	20 83       	st	Z, r18
}
     bf6:	df 91       	pop	r29
     bf8:	cf 91       	pop	r28
     bfa:	08 95       	ret

00000bfc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     bfc:	cf 93       	push	r28
     bfe:	df 93       	push	r29
     c00:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     c02:	a0 85       	ldd	r26, Z+8	; 0x08
     c04:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     c06:	c2 81       	ldd	r28, Z+2	; 0x02
     c08:	d3 81       	ldd	r29, Z+3	; 0x03
     c0a:	84 81       	ldd	r24, Z+4	; 0x04
     c0c:	95 81       	ldd	r25, Z+5	; 0x05
     c0e:	9d 83       	std	Y+5, r25	; 0x05
     c10:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     c12:	c4 81       	ldd	r28, Z+4	; 0x04
     c14:	d5 81       	ldd	r29, Z+5	; 0x05
     c16:	82 81       	ldd	r24, Z+2	; 0x02
     c18:	93 81       	ldd	r25, Z+3	; 0x03
     c1a:	9b 83       	std	Y+3, r25	; 0x03
     c1c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     c1e:	11 96       	adiw	r26, 0x01	; 1
     c20:	8d 91       	ld	r24, X+
     c22:	9c 91       	ld	r25, X
     c24:	12 97       	sbiw	r26, 0x02	; 2
     c26:	e8 17       	cp	r30, r24
     c28:	f9 07       	cpc	r31, r25
     c2a:	31 f4       	brne	.+12     	; 0xc38 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     c2c:	84 81       	ldd	r24, Z+4	; 0x04
     c2e:	95 81       	ldd	r25, Z+5	; 0x05
     c30:	12 96       	adiw	r26, 0x02	; 2
     c32:	9c 93       	st	X, r25
     c34:	8e 93       	st	-X, r24
     c36:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     c38:	11 86       	std	Z+9, r1	; 0x09
     c3a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     c3c:	8c 91       	ld	r24, X
     c3e:	81 50       	subi	r24, 0x01	; 1
     c40:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     c42:	df 91       	pop	r29
     c44:	cf 91       	pop	r28
     c46:	08 95       	ret

00000c48 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     c48:	1b bc       	out	0x2b, r1	; 43
     c4a:	89 ef       	ldi	r24, 0xF9	; 249
     c4c:	8a bd       	out	0x2a, r24	; 42
     c4e:	8b e0       	ldi	r24, 0x0B	; 11
     c50:	8e bd       	out	0x2e, r24	; 46
     c52:	89 b7       	in	r24, 0x39	; 57
     c54:	80 61       	ori	r24, 0x10	; 16
     c56:	89 bf       	out	0x39, r24	; 57
     c58:	08 95       	ret

00000c5a <pxPortInitialiseStack>:
     c5a:	31 e1       	ldi	r19, 0x11	; 17
     c5c:	fc 01       	movw	r30, r24
     c5e:	30 83       	st	Z, r19
     c60:	31 97       	sbiw	r30, 0x01	; 1
     c62:	22 e2       	ldi	r18, 0x22	; 34
     c64:	20 83       	st	Z, r18
     c66:	31 97       	sbiw	r30, 0x01	; 1
     c68:	a3 e3       	ldi	r26, 0x33	; 51
     c6a:	a0 83       	st	Z, r26
     c6c:	31 97       	sbiw	r30, 0x01	; 1
     c6e:	60 83       	st	Z, r22
     c70:	31 97       	sbiw	r30, 0x01	; 1
     c72:	70 83       	st	Z, r23
     c74:	31 97       	sbiw	r30, 0x01	; 1
     c76:	10 82       	st	Z, r1
     c78:	31 97       	sbiw	r30, 0x01	; 1
     c7a:	60 e8       	ldi	r22, 0x80	; 128
     c7c:	60 83       	st	Z, r22
     c7e:	31 97       	sbiw	r30, 0x01	; 1
     c80:	10 82       	st	Z, r1
     c82:	31 97       	sbiw	r30, 0x01	; 1
     c84:	62 e0       	ldi	r22, 0x02	; 2
     c86:	60 83       	st	Z, r22
     c88:	31 97       	sbiw	r30, 0x01	; 1
     c8a:	63 e0       	ldi	r22, 0x03	; 3
     c8c:	60 83       	st	Z, r22
     c8e:	31 97       	sbiw	r30, 0x01	; 1
     c90:	64 e0       	ldi	r22, 0x04	; 4
     c92:	60 83       	st	Z, r22
     c94:	31 97       	sbiw	r30, 0x01	; 1
     c96:	65 e0       	ldi	r22, 0x05	; 5
     c98:	60 83       	st	Z, r22
     c9a:	31 97       	sbiw	r30, 0x01	; 1
     c9c:	66 e0       	ldi	r22, 0x06	; 6
     c9e:	60 83       	st	Z, r22
     ca0:	31 97       	sbiw	r30, 0x01	; 1
     ca2:	67 e0       	ldi	r22, 0x07	; 7
     ca4:	60 83       	st	Z, r22
     ca6:	31 97       	sbiw	r30, 0x01	; 1
     ca8:	68 e0       	ldi	r22, 0x08	; 8
     caa:	60 83       	st	Z, r22
     cac:	31 97       	sbiw	r30, 0x01	; 1
     cae:	69 e0       	ldi	r22, 0x09	; 9
     cb0:	60 83       	st	Z, r22
     cb2:	31 97       	sbiw	r30, 0x01	; 1
     cb4:	60 e1       	ldi	r22, 0x10	; 16
     cb6:	60 83       	st	Z, r22
     cb8:	31 97       	sbiw	r30, 0x01	; 1
     cba:	30 83       	st	Z, r19
     cbc:	31 97       	sbiw	r30, 0x01	; 1
     cbe:	32 e1       	ldi	r19, 0x12	; 18
     cc0:	30 83       	st	Z, r19
     cc2:	31 97       	sbiw	r30, 0x01	; 1
     cc4:	33 e1       	ldi	r19, 0x13	; 19
     cc6:	30 83       	st	Z, r19
     cc8:	31 97       	sbiw	r30, 0x01	; 1
     cca:	34 e1       	ldi	r19, 0x14	; 20
     ccc:	30 83       	st	Z, r19
     cce:	31 97       	sbiw	r30, 0x01	; 1
     cd0:	35 e1       	ldi	r19, 0x15	; 21
     cd2:	30 83       	st	Z, r19
     cd4:	31 97       	sbiw	r30, 0x01	; 1
     cd6:	36 e1       	ldi	r19, 0x16	; 22
     cd8:	30 83       	st	Z, r19
     cda:	31 97       	sbiw	r30, 0x01	; 1
     cdc:	37 e1       	ldi	r19, 0x17	; 23
     cde:	30 83       	st	Z, r19
     ce0:	31 97       	sbiw	r30, 0x01	; 1
     ce2:	38 e1       	ldi	r19, 0x18	; 24
     ce4:	30 83       	st	Z, r19
     ce6:	31 97       	sbiw	r30, 0x01	; 1
     ce8:	39 e1       	ldi	r19, 0x19	; 25
     cea:	30 83       	st	Z, r19
     cec:	31 97       	sbiw	r30, 0x01	; 1
     cee:	30 e2       	ldi	r19, 0x20	; 32
     cf0:	30 83       	st	Z, r19
     cf2:	31 97       	sbiw	r30, 0x01	; 1
     cf4:	31 e2       	ldi	r19, 0x21	; 33
     cf6:	30 83       	st	Z, r19
     cf8:	31 97       	sbiw	r30, 0x01	; 1
     cfa:	20 83       	st	Z, r18
     cfc:	31 97       	sbiw	r30, 0x01	; 1
     cfe:	23 e2       	ldi	r18, 0x23	; 35
     d00:	20 83       	st	Z, r18
     d02:	31 97       	sbiw	r30, 0x01	; 1
     d04:	40 83       	st	Z, r20
     d06:	31 97       	sbiw	r30, 0x01	; 1
     d08:	50 83       	st	Z, r21
     d0a:	31 97       	sbiw	r30, 0x01	; 1
     d0c:	26 e2       	ldi	r18, 0x26	; 38
     d0e:	20 83       	st	Z, r18
     d10:	31 97       	sbiw	r30, 0x01	; 1
     d12:	27 e2       	ldi	r18, 0x27	; 39
     d14:	20 83       	st	Z, r18
     d16:	31 97       	sbiw	r30, 0x01	; 1
     d18:	28 e2       	ldi	r18, 0x28	; 40
     d1a:	20 83       	st	Z, r18
     d1c:	31 97       	sbiw	r30, 0x01	; 1
     d1e:	29 e2       	ldi	r18, 0x29	; 41
     d20:	20 83       	st	Z, r18
     d22:	31 97       	sbiw	r30, 0x01	; 1
     d24:	20 e3       	ldi	r18, 0x30	; 48
     d26:	20 83       	st	Z, r18
     d28:	31 97       	sbiw	r30, 0x01	; 1
     d2a:	21 e3       	ldi	r18, 0x31	; 49
     d2c:	20 83       	st	Z, r18
     d2e:	86 97       	sbiw	r24, 0x26	; 38
     d30:	08 95       	ret

00000d32 <xPortStartScheduler>:
     d32:	0e 94 24 06 	call	0xc48	; 0xc48 <prvSetupTimerInterrupt>
     d36:	a0 91 f9 00 	lds	r26, 0x00F9	; 0x8000f9 <pxCurrentTCB>
     d3a:	b0 91 fa 00 	lds	r27, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
     d3e:	cd 91       	ld	r28, X+
     d40:	cd bf       	out	0x3d, r28	; 61
     d42:	dd 91       	ld	r29, X+
     d44:	de bf       	out	0x3e, r29	; 62
     d46:	ff 91       	pop	r31
     d48:	ef 91       	pop	r30
     d4a:	df 91       	pop	r29
     d4c:	cf 91       	pop	r28
     d4e:	bf 91       	pop	r27
     d50:	af 91       	pop	r26
     d52:	9f 91       	pop	r25
     d54:	8f 91       	pop	r24
     d56:	7f 91       	pop	r23
     d58:	6f 91       	pop	r22
     d5a:	5f 91       	pop	r21
     d5c:	4f 91       	pop	r20
     d5e:	3f 91       	pop	r19
     d60:	2f 91       	pop	r18
     d62:	1f 91       	pop	r17
     d64:	0f 91       	pop	r16
     d66:	ff 90       	pop	r15
     d68:	ef 90       	pop	r14
     d6a:	df 90       	pop	r13
     d6c:	cf 90       	pop	r12
     d6e:	bf 90       	pop	r11
     d70:	af 90       	pop	r10
     d72:	9f 90       	pop	r9
     d74:	8f 90       	pop	r8
     d76:	7f 90       	pop	r7
     d78:	6f 90       	pop	r6
     d7a:	5f 90       	pop	r5
     d7c:	4f 90       	pop	r4
     d7e:	3f 90       	pop	r3
     d80:	2f 90       	pop	r2
     d82:	1f 90       	pop	r1
     d84:	0f 90       	pop	r0
     d86:	0f be       	out	0x3f, r0	; 63
     d88:	0f 90       	pop	r0
     d8a:	08 95       	ret
     d8c:	81 e0       	ldi	r24, 0x01	; 1
     d8e:	08 95       	ret

00000d90 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     d90:	0f 92       	push	r0
     d92:	0f b6       	in	r0, 0x3f	; 63
     d94:	f8 94       	cli
     d96:	0f 92       	push	r0
     d98:	1f 92       	push	r1
     d9a:	11 24       	eor	r1, r1
     d9c:	2f 92       	push	r2
     d9e:	3f 92       	push	r3
     da0:	4f 92       	push	r4
     da2:	5f 92       	push	r5
     da4:	6f 92       	push	r6
     da6:	7f 92       	push	r7
     da8:	8f 92       	push	r8
     daa:	9f 92       	push	r9
     dac:	af 92       	push	r10
     dae:	bf 92       	push	r11
     db0:	cf 92       	push	r12
     db2:	df 92       	push	r13
     db4:	ef 92       	push	r14
     db6:	ff 92       	push	r15
     db8:	0f 93       	push	r16
     dba:	1f 93       	push	r17
     dbc:	2f 93       	push	r18
     dbe:	3f 93       	push	r19
     dc0:	4f 93       	push	r20
     dc2:	5f 93       	push	r21
     dc4:	6f 93       	push	r22
     dc6:	7f 93       	push	r23
     dc8:	8f 93       	push	r24
     dca:	9f 93       	push	r25
     dcc:	af 93       	push	r26
     dce:	bf 93       	push	r27
     dd0:	cf 93       	push	r28
     dd2:	df 93       	push	r29
     dd4:	ef 93       	push	r30
     dd6:	ff 93       	push	r31
     dd8:	a0 91 f9 00 	lds	r26, 0x00F9	; 0x8000f9 <pxCurrentTCB>
     ddc:	b0 91 fa 00 	lds	r27, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
     de0:	0d b6       	in	r0, 0x3d	; 61
     de2:	0d 92       	st	X+, r0
     de4:	0e b6       	in	r0, 0x3e	; 62
     de6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     de8:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     dec:	a0 91 f9 00 	lds	r26, 0x00F9	; 0x8000f9 <pxCurrentTCB>
     df0:	b0 91 fa 00 	lds	r27, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
     df4:	cd 91       	ld	r28, X+
     df6:	cd bf       	out	0x3d, r28	; 61
     df8:	dd 91       	ld	r29, X+
     dfa:	de bf       	out	0x3e, r29	; 62
     dfc:	ff 91       	pop	r31
     dfe:	ef 91       	pop	r30
     e00:	df 91       	pop	r29
     e02:	cf 91       	pop	r28
     e04:	bf 91       	pop	r27
     e06:	af 91       	pop	r26
     e08:	9f 91       	pop	r25
     e0a:	8f 91       	pop	r24
     e0c:	7f 91       	pop	r23
     e0e:	6f 91       	pop	r22
     e10:	5f 91       	pop	r21
     e12:	4f 91       	pop	r20
     e14:	3f 91       	pop	r19
     e16:	2f 91       	pop	r18
     e18:	1f 91       	pop	r17
     e1a:	0f 91       	pop	r16
     e1c:	ff 90       	pop	r15
     e1e:	ef 90       	pop	r14
     e20:	df 90       	pop	r13
     e22:	cf 90       	pop	r12
     e24:	bf 90       	pop	r11
     e26:	af 90       	pop	r10
     e28:	9f 90       	pop	r9
     e2a:	8f 90       	pop	r8
     e2c:	7f 90       	pop	r7
     e2e:	6f 90       	pop	r6
     e30:	5f 90       	pop	r5
     e32:	4f 90       	pop	r4
     e34:	3f 90       	pop	r3
     e36:	2f 90       	pop	r2
     e38:	1f 90       	pop	r1
     e3a:	0f 90       	pop	r0
     e3c:	0f be       	out	0x3f, r0	; 63
     e3e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e40:	08 95       	ret

00000e42 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     e42:	0f 92       	push	r0
     e44:	0f b6       	in	r0, 0x3f	; 63
     e46:	f8 94       	cli
     e48:	0f 92       	push	r0
     e4a:	1f 92       	push	r1
     e4c:	11 24       	eor	r1, r1
     e4e:	2f 92       	push	r2
     e50:	3f 92       	push	r3
     e52:	4f 92       	push	r4
     e54:	5f 92       	push	r5
     e56:	6f 92       	push	r6
     e58:	7f 92       	push	r7
     e5a:	8f 92       	push	r8
     e5c:	9f 92       	push	r9
     e5e:	af 92       	push	r10
     e60:	bf 92       	push	r11
     e62:	cf 92       	push	r12
     e64:	df 92       	push	r13
     e66:	ef 92       	push	r14
     e68:	ff 92       	push	r15
     e6a:	0f 93       	push	r16
     e6c:	1f 93       	push	r17
     e6e:	2f 93       	push	r18
     e70:	3f 93       	push	r19
     e72:	4f 93       	push	r20
     e74:	5f 93       	push	r21
     e76:	6f 93       	push	r22
     e78:	7f 93       	push	r23
     e7a:	8f 93       	push	r24
     e7c:	9f 93       	push	r25
     e7e:	af 93       	push	r26
     e80:	bf 93       	push	r27
     e82:	cf 93       	push	r28
     e84:	df 93       	push	r29
     e86:	ef 93       	push	r30
     e88:	ff 93       	push	r31
     e8a:	a0 91 f9 00 	lds	r26, 0x00F9	; 0x8000f9 <pxCurrentTCB>
     e8e:	b0 91 fa 00 	lds	r27, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
     e92:	0d b6       	in	r0, 0x3d	; 61
     e94:	0d 92       	st	X+, r0
     e96:	0e b6       	in	r0, 0x3e	; 62
     e98:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     e9a:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <xTaskIncrementTick>
     e9e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     ea0:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     ea4:	a0 91 f9 00 	lds	r26, 0x00F9	; 0x8000f9 <pxCurrentTCB>
     ea8:	b0 91 fa 00 	lds	r27, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
     eac:	cd 91       	ld	r28, X+
     eae:	cd bf       	out	0x3d, r28	; 61
     eb0:	dd 91       	ld	r29, X+
     eb2:	de bf       	out	0x3e, r29	; 62
     eb4:	ff 91       	pop	r31
     eb6:	ef 91       	pop	r30
     eb8:	df 91       	pop	r29
     eba:	cf 91       	pop	r28
     ebc:	bf 91       	pop	r27
     ebe:	af 91       	pop	r26
     ec0:	9f 91       	pop	r25
     ec2:	8f 91       	pop	r24
     ec4:	7f 91       	pop	r23
     ec6:	6f 91       	pop	r22
     ec8:	5f 91       	pop	r21
     eca:	4f 91       	pop	r20
     ecc:	3f 91       	pop	r19
     ece:	2f 91       	pop	r18
     ed0:	1f 91       	pop	r17
     ed2:	0f 91       	pop	r16
     ed4:	ff 90       	pop	r15
     ed6:	ef 90       	pop	r14
     ed8:	df 90       	pop	r13
     eda:	cf 90       	pop	r12
     edc:	bf 90       	pop	r11
     ede:	af 90       	pop	r10
     ee0:	9f 90       	pop	r9
     ee2:	8f 90       	pop	r8
     ee4:	7f 90       	pop	r7
     ee6:	6f 90       	pop	r6
     ee8:	5f 90       	pop	r5
     eea:	4f 90       	pop	r4
     eec:	3f 90       	pop	r3
     eee:	2f 90       	pop	r2
     ef0:	1f 90       	pop	r1
     ef2:	0f 90       	pop	r0
     ef4:	0f be       	out	0x3f, r0	; 63
     ef6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ef8:	08 95       	ret

00000efa <__vector_7>:
	 * DeeThe: Changed from SIG_OUTPUT_COMPARE1A to TIMER1_COMPA_vect
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     efa:	0e 94 21 07 	call	0xe42	; 0xe42 <vPortYieldFromTick>
		asm volatile ( "reti" );
     efe:	18 95       	reti

00000f00 <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     f00:	cf 93       	push	r28
     f02:	df 93       	push	r29
     f04:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
     f06:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
     f0a:	ce 01       	movw	r24, r28
     f0c:	0e 94 70 10 	call	0x20e0	; 0x20e0 <malloc>
     f10:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     f12:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     f16:	ce 01       	movw	r24, r28
     f18:	df 91       	pop	r29
     f1a:	cf 91       	pop	r28
     f1c:	08 95       	ret

00000f1e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
	if( pv )
     f22:	00 97       	sbiw	r24, 0x00	; 0
     f24:	41 f0       	breq	.+16     	; 0xf36 <vPortFree+0x18>
     f26:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
     f28:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <vTaskSuspendAll>
		{
			free( pv );
     f2c:	ce 01       	movw	r24, r28
     f2e:	0e 94 08 11 	call	0x2210	; 0x2210 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
     f32:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <xTaskResumeAll>
	}
}
     f36:	df 91       	pop	r29
     f38:	cf 91       	pop	r28
     f3a:	08 95       	ret

00000f3c <prvIsQueueEmpty>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f3c:	0f b6       	in	r0, 0x3f	; 63
     f3e:	f8 94       	cli
     f40:	0f 92       	push	r0
     f42:	fc 01       	movw	r30, r24
     f44:	82 8d       	ldd	r24, Z+26	; 0x1a
     f46:	81 11       	cpse	r24, r1
     f48:	02 c0       	rjmp	.+4      	; 0xf4e <prvIsQueueEmpty+0x12>
     f4a:	81 e0       	ldi	r24, 0x01	; 1
     f4c:	01 c0       	rjmp	.+2      	; 0xf50 <prvIsQueueEmpty+0x14>
     f4e:	80 e0       	ldi	r24, 0x00	; 0
     f50:	0f 90       	pop	r0
     f52:	0f be       	out	0x3f, r0	; 63
     f54:	08 95       	ret

00000f56 <prvIsQueueFull>:
     f56:	0f b6       	in	r0, 0x3f	; 63
     f58:	f8 94       	cli
     f5a:	0f 92       	push	r0
     f5c:	fc 01       	movw	r30, r24
     f5e:	22 8d       	ldd	r18, Z+26	; 0x1a
     f60:	83 8d       	ldd	r24, Z+27	; 0x1b
     f62:	28 13       	cpse	r18, r24
     f64:	02 c0       	rjmp	.+4      	; 0xf6a <prvIsQueueFull+0x14>
     f66:	81 e0       	ldi	r24, 0x01	; 1
     f68:	01 c0       	rjmp	.+2      	; 0xf6c <prvIsQueueFull+0x16>
     f6a:	80 e0       	ldi	r24, 0x00	; 0
     f6c:	0f 90       	pop	r0
     f6e:	0f be       	out	0x3f, r0	; 63
     f70:	08 95       	ret

00000f72 <prvCopyDataToQueue>:
     f72:	0f 93       	push	r16
     f74:	1f 93       	push	r17
     f76:	cf 93       	push	r28
     f78:	df 93       	push	r29
     f7a:	ec 01       	movw	r28, r24
     f7c:	04 2f       	mov	r16, r20
     f7e:	1a 8d       	ldd	r17, Y+26	; 0x1a
     f80:	4c 8d       	ldd	r20, Y+28	; 0x1c
     f82:	41 11       	cpse	r20, r1
     f84:	0c c0       	rjmp	.+24     	; 0xf9e <prvCopyDataToQueue+0x2c>
     f86:	88 81       	ld	r24, Y
     f88:	99 81       	ldd	r25, Y+1	; 0x01
     f8a:	89 2b       	or	r24, r25
     f8c:	09 f0       	breq	.+2      	; 0xf90 <prvCopyDataToQueue+0x1e>
     f8e:	42 c0       	rjmp	.+132    	; 0x1014 <prvCopyDataToQueue+0xa2>
     f90:	8a 81       	ldd	r24, Y+2	; 0x02
     f92:	9b 81       	ldd	r25, Y+3	; 0x03
     f94:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <xTaskPriorityDisinherit>
     f98:	1b 82       	std	Y+3, r1	; 0x03
     f9a:	1a 82       	std	Y+2, r1	; 0x02
     f9c:	42 c0       	rjmp	.+132    	; 0x1022 <prvCopyDataToQueue+0xb0>
     f9e:	01 11       	cpse	r16, r1
     fa0:	17 c0       	rjmp	.+46     	; 0xfd0 <prvCopyDataToQueue+0x5e>
     fa2:	50 e0       	ldi	r21, 0x00	; 0
     fa4:	8c 81       	ldd	r24, Y+4	; 0x04
     fa6:	9d 81       	ldd	r25, Y+5	; 0x05
     fa8:	0e 94 91 11 	call	0x2322	; 0x2322 <memcpy>
     fac:	2c 8d       	ldd	r18, Y+28	; 0x1c
     fae:	8c 81       	ldd	r24, Y+4	; 0x04
     fb0:	9d 81       	ldd	r25, Y+5	; 0x05
     fb2:	82 0f       	add	r24, r18
     fb4:	91 1d       	adc	r25, r1
     fb6:	9d 83       	std	Y+5, r25	; 0x05
     fb8:	8c 83       	std	Y+4, r24	; 0x04
     fba:	2a 81       	ldd	r18, Y+2	; 0x02
     fbc:	3b 81       	ldd	r19, Y+3	; 0x03
     fbe:	82 17       	cp	r24, r18
     fc0:	93 07       	cpc	r25, r19
     fc2:	50 f1       	brcs	.+84     	; 0x1018 <prvCopyDataToQueue+0xa6>
     fc4:	88 81       	ld	r24, Y
     fc6:	99 81       	ldd	r25, Y+1	; 0x01
     fc8:	9d 83       	std	Y+5, r25	; 0x05
     fca:	8c 83       	std	Y+4, r24	; 0x04
     fcc:	80 e0       	ldi	r24, 0x00	; 0
     fce:	29 c0       	rjmp	.+82     	; 0x1022 <prvCopyDataToQueue+0xb0>
     fd0:	50 e0       	ldi	r21, 0x00	; 0
     fd2:	8e 81       	ldd	r24, Y+6	; 0x06
     fd4:	9f 81       	ldd	r25, Y+7	; 0x07
     fd6:	0e 94 91 11 	call	0x2322	; 0x2322 <memcpy>
     fda:	8c 8d       	ldd	r24, Y+28	; 0x1c
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	91 95       	neg	r25
     fe0:	81 95       	neg	r24
     fe2:	91 09       	sbc	r25, r1
     fe4:	2e 81       	ldd	r18, Y+6	; 0x06
     fe6:	3f 81       	ldd	r19, Y+7	; 0x07
     fe8:	28 0f       	add	r18, r24
     fea:	39 1f       	adc	r19, r25
     fec:	3f 83       	std	Y+7, r19	; 0x07
     fee:	2e 83       	std	Y+6, r18	; 0x06
     ff0:	48 81       	ld	r20, Y
     ff2:	59 81       	ldd	r21, Y+1	; 0x01
     ff4:	24 17       	cp	r18, r20
     ff6:	35 07       	cpc	r19, r21
     ff8:	30 f4       	brcc	.+12     	; 0x1006 <prvCopyDataToQueue+0x94>
     ffa:	2a 81       	ldd	r18, Y+2	; 0x02
     ffc:	3b 81       	ldd	r19, Y+3	; 0x03
     ffe:	82 0f       	add	r24, r18
    1000:	93 1f       	adc	r25, r19
    1002:	9f 83       	std	Y+7, r25	; 0x07
    1004:	8e 83       	std	Y+6, r24	; 0x06
    1006:	02 30       	cpi	r16, 0x02	; 2
    1008:	49 f4       	brne	.+18     	; 0x101c <prvCopyDataToQueue+0xaa>
    100a:	11 23       	and	r17, r17
    100c:	49 f0       	breq	.+18     	; 0x1020 <prvCopyDataToQueue+0xae>
    100e:	11 50       	subi	r17, 0x01	; 1
    1010:	80 e0       	ldi	r24, 0x00	; 0
    1012:	07 c0       	rjmp	.+14     	; 0x1022 <prvCopyDataToQueue+0xb0>
    1014:	80 e0       	ldi	r24, 0x00	; 0
    1016:	05 c0       	rjmp	.+10     	; 0x1022 <prvCopyDataToQueue+0xb0>
    1018:	80 e0       	ldi	r24, 0x00	; 0
    101a:	03 c0       	rjmp	.+6      	; 0x1022 <prvCopyDataToQueue+0xb0>
    101c:	80 e0       	ldi	r24, 0x00	; 0
    101e:	01 c0       	rjmp	.+2      	; 0x1022 <prvCopyDataToQueue+0xb0>
    1020:	80 e0       	ldi	r24, 0x00	; 0
    1022:	1f 5f       	subi	r17, 0xFF	; 255
    1024:	1a 8f       	std	Y+26, r17	; 0x1a
    1026:	df 91       	pop	r29
    1028:	cf 91       	pop	r28
    102a:	1f 91       	pop	r17
    102c:	0f 91       	pop	r16
    102e:	08 95       	ret

00001030 <prvCopyDataFromQueue>:
    1030:	fc 01       	movw	r30, r24
    1032:	44 8d       	ldd	r20, Z+28	; 0x1c
    1034:	44 23       	and	r20, r20
    1036:	a9 f0       	breq	.+42     	; 0x1062 <prvCopyDataFromQueue+0x32>
    1038:	50 e0       	ldi	r21, 0x00	; 0
    103a:	26 81       	ldd	r18, Z+6	; 0x06
    103c:	37 81       	ldd	r19, Z+7	; 0x07
    103e:	24 0f       	add	r18, r20
    1040:	35 1f       	adc	r19, r21
    1042:	37 83       	std	Z+7, r19	; 0x07
    1044:	26 83       	std	Z+6, r18	; 0x06
    1046:	82 81       	ldd	r24, Z+2	; 0x02
    1048:	93 81       	ldd	r25, Z+3	; 0x03
    104a:	28 17       	cp	r18, r24
    104c:	39 07       	cpc	r19, r25
    104e:	20 f0       	brcs	.+8      	; 0x1058 <prvCopyDataFromQueue+0x28>
    1050:	80 81       	ld	r24, Z
    1052:	91 81       	ldd	r25, Z+1	; 0x01
    1054:	97 83       	std	Z+7, r25	; 0x07
    1056:	86 83       	std	Z+6, r24	; 0x06
    1058:	cb 01       	movw	r24, r22
    105a:	66 81       	ldd	r22, Z+6	; 0x06
    105c:	77 81       	ldd	r23, Z+7	; 0x07
    105e:	0e 94 91 11 	call	0x2322	; 0x2322 <memcpy>
    1062:	08 95       	ret

00001064 <prvUnlockQueue>:
    1064:	1f 93       	push	r17
    1066:	cf 93       	push	r28
    1068:	df 93       	push	r29
    106a:	ec 01       	movw	r28, r24
    106c:	0f b6       	in	r0, 0x3f	; 63
    106e:	f8 94       	cli
    1070:	0f 92       	push	r0
    1072:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1074:	0b c0       	rjmp	.+22     	; 0x108c <prvUnlockQueue+0x28>
    1076:	89 89       	ldd	r24, Y+17	; 0x11
    1078:	88 23       	and	r24, r24
    107a:	51 f0       	breq	.+20     	; 0x1090 <prvUnlockQueue+0x2c>
    107c:	ce 01       	movw	r24, r28
    107e:	41 96       	adiw	r24, 0x11	; 17
    1080:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <xTaskRemoveFromEventList>
    1084:	81 11       	cpse	r24, r1
    1086:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vTaskMissedYield>
    108a:	11 50       	subi	r17, 0x01	; 1
    108c:	11 16       	cp	r1, r17
    108e:	9c f3       	brlt	.-26     	; 0x1076 <prvUnlockQueue+0x12>
    1090:	8f ef       	ldi	r24, 0xFF	; 255
    1092:	8e 8f       	std	Y+30, r24	; 0x1e
    1094:	0f 90       	pop	r0
    1096:	0f be       	out	0x3f, r0	; 63
    1098:	0f b6       	in	r0, 0x3f	; 63
    109a:	f8 94       	cli
    109c:	0f 92       	push	r0
    109e:	1d 8d       	ldd	r17, Y+29	; 0x1d
    10a0:	0b c0       	rjmp	.+22     	; 0x10b8 <prvUnlockQueue+0x54>
    10a2:	88 85       	ldd	r24, Y+8	; 0x08
    10a4:	88 23       	and	r24, r24
    10a6:	51 f0       	breq	.+20     	; 0x10bc <prvUnlockQueue+0x58>
    10a8:	ce 01       	movw	r24, r28
    10aa:	08 96       	adiw	r24, 0x08	; 8
    10ac:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <xTaskRemoveFromEventList>
    10b0:	81 11       	cpse	r24, r1
    10b2:	0e 94 6c 0f 	call	0x1ed8	; 0x1ed8 <vTaskMissedYield>
    10b6:	11 50       	subi	r17, 0x01	; 1
    10b8:	11 16       	cp	r1, r17
    10ba:	9c f3       	brlt	.-26     	; 0x10a2 <prvUnlockQueue+0x3e>
    10bc:	8f ef       	ldi	r24, 0xFF	; 255
    10be:	8d 8f       	std	Y+29, r24	; 0x1d
    10c0:	0f 90       	pop	r0
    10c2:	0f be       	out	0x3f, r0	; 63
    10c4:	df 91       	pop	r29
    10c6:	cf 91       	pop	r28
    10c8:	1f 91       	pop	r17
    10ca:	08 95       	ret

000010cc <xQueueGenericReset>:
    10cc:	cf 93       	push	r28
    10ce:	df 93       	push	r29
    10d0:	ec 01       	movw	r28, r24
    10d2:	0f b6       	in	r0, 0x3f	; 63
    10d4:	f8 94       	cli
    10d6:	0f 92       	push	r0
    10d8:	e8 81       	ld	r30, Y
    10da:	f9 81       	ldd	r31, Y+1	; 0x01
    10dc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    10de:	90 e0       	ldi	r25, 0x00	; 0
    10e0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    10e2:	30 e0       	ldi	r19, 0x00	; 0
    10e4:	82 9f       	mul	r24, r18
    10e6:	a0 01       	movw	r20, r0
    10e8:	83 9f       	mul	r24, r19
    10ea:	50 0d       	add	r21, r0
    10ec:	92 9f       	mul	r25, r18
    10ee:	50 0d       	add	r21, r0
    10f0:	11 24       	eor	r1, r1
    10f2:	4e 0f       	add	r20, r30
    10f4:	5f 1f       	adc	r21, r31
    10f6:	5b 83       	std	Y+3, r21	; 0x03
    10f8:	4a 83       	std	Y+2, r20	; 0x02
    10fa:	1a 8e       	std	Y+26, r1	; 0x1a
    10fc:	fd 83       	std	Y+5, r31	; 0x05
    10fe:	ec 83       	std	Y+4, r30	; 0x04
    1100:	01 97       	sbiw	r24, 0x01	; 1
    1102:	28 9f       	mul	r18, r24
    1104:	a0 01       	movw	r20, r0
    1106:	29 9f       	mul	r18, r25
    1108:	50 0d       	add	r21, r0
    110a:	38 9f       	mul	r19, r24
    110c:	50 0d       	add	r21, r0
    110e:	11 24       	eor	r1, r1
    1110:	cf 01       	movw	r24, r30
    1112:	84 0f       	add	r24, r20
    1114:	95 1f       	adc	r25, r21
    1116:	9f 83       	std	Y+7, r25	; 0x07
    1118:	8e 83       	std	Y+6, r24	; 0x06
    111a:	8f ef       	ldi	r24, 0xFF	; 255
    111c:	8d 8f       	std	Y+29, r24	; 0x1d
    111e:	8e 8f       	std	Y+30, r24	; 0x1e
    1120:	61 11       	cpse	r22, r1
    1122:	0c c0       	rjmp	.+24     	; 0x113c <xQueueGenericReset+0x70>
    1124:	88 85       	ldd	r24, Y+8	; 0x08
    1126:	88 23       	and	r24, r24
    1128:	89 f0       	breq	.+34     	; 0x114c <xQueueGenericReset+0x80>
    112a:	ce 01       	movw	r24, r28
    112c:	08 96       	adiw	r24, 0x08	; 8
    112e:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <xTaskRemoveFromEventList>
    1132:	88 23       	and	r24, r24
    1134:	59 f0       	breq	.+22     	; 0x114c <xQueueGenericReset+0x80>
    1136:	0e 94 c8 06 	call	0xd90	; 0xd90 <vPortYield>
    113a:	08 c0       	rjmp	.+16     	; 0x114c <xQueueGenericReset+0x80>
    113c:	ce 01       	movw	r24, r28
    113e:	08 96       	adiw	r24, 0x08	; 8
    1140:	0e 94 9a 05 	call	0xb34	; 0xb34 <vListInitialise>
    1144:	ce 01       	movw	r24, r28
    1146:	41 96       	adiw	r24, 0x11	; 17
    1148:	0e 94 9a 05 	call	0xb34	; 0xb34 <vListInitialise>
    114c:	0f 90       	pop	r0
    114e:	0f be       	out	0x3f, r0	; 63
    1150:	81 e0       	ldi	r24, 0x01	; 1
    1152:	df 91       	pop	r29
    1154:	cf 91       	pop	r28
    1156:	08 95       	ret

00001158 <prvInitialiseNewQueue>:
    1158:	0f 93       	push	r16
    115a:	1f 93       	push	r17
    115c:	f8 01       	movw	r30, r16
    115e:	61 11       	cpse	r22, r1
    1160:	03 c0       	rjmp	.+6      	; 0x1168 <prvInitialiseNewQueue+0x10>
    1162:	11 83       	std	Z+1, r17	; 0x01
    1164:	00 83       	st	Z, r16
    1166:	02 c0       	rjmp	.+4      	; 0x116c <prvInitialiseNewQueue+0x14>
    1168:	51 83       	std	Z+1, r21	; 0x01
    116a:	40 83       	st	Z, r20
    116c:	83 8f       	std	Z+27, r24	; 0x1b
    116e:	64 8f       	std	Z+28, r22	; 0x1c
    1170:	61 e0       	ldi	r22, 0x01	; 1
    1172:	cf 01       	movw	r24, r30
    1174:	0e 94 66 08 	call	0x10cc	; 0x10cc <xQueueGenericReset>
    1178:	1f 91       	pop	r17
    117a:	0f 91       	pop	r16
    117c:	08 95       	ret

0000117e <xQueueGenericCreate>:
    117e:	df 92       	push	r13
    1180:	ef 92       	push	r14
    1182:	ff 92       	push	r15
    1184:	0f 93       	push	r16
    1186:	1f 93       	push	r17
    1188:	cf 93       	push	r28
    118a:	df 93       	push	r29
    118c:	e8 2e       	mov	r14, r24
    118e:	f6 2e       	mov	r15, r22
    1190:	d4 2e       	mov	r13, r20
    1192:	66 23       	and	r22, r22
    1194:	21 f0       	breq	.+8      	; 0x119e <xQueueGenericCreate+0x20>
    1196:	86 9f       	mul	r24, r22
    1198:	c0 01       	movw	r24, r0
    119a:	11 24       	eor	r1, r1
    119c:	02 c0       	rjmp	.+4      	; 0x11a2 <xQueueGenericCreate+0x24>
    119e:	80 e0       	ldi	r24, 0x00	; 0
    11a0:	90 e0       	ldi	r25, 0x00	; 0
    11a2:	4f 96       	adiw	r24, 0x1f	; 31
    11a4:	0e 94 80 07 	call	0xf00	; 0xf00 <pvPortMalloc>
    11a8:	ec 01       	movw	r28, r24
    11aa:	00 97       	sbiw	r24, 0x00	; 0
    11ac:	49 f0       	breq	.+18     	; 0x11c0 <xQueueGenericCreate+0x42>
    11ae:	8c 01       	movw	r16, r24
    11b0:	2d 2d       	mov	r18, r13
    11b2:	ac 01       	movw	r20, r24
    11b4:	41 5e       	subi	r20, 0xE1	; 225
    11b6:	5f 4f       	sbci	r21, 0xFF	; 255
    11b8:	6f 2d       	mov	r22, r15
    11ba:	8e 2d       	mov	r24, r14
    11bc:	0e 94 ac 08 	call	0x1158	; 0x1158 <prvInitialiseNewQueue>
    11c0:	ce 01       	movw	r24, r28
    11c2:	df 91       	pop	r29
    11c4:	cf 91       	pop	r28
    11c6:	1f 91       	pop	r17
    11c8:	0f 91       	pop	r16
    11ca:	ff 90       	pop	r15
    11cc:	ef 90       	pop	r14
    11ce:	df 90       	pop	r13
    11d0:	08 95       	ret

000011d2 <xQueueGenericSend>:
    11d2:	cf 92       	push	r12
    11d4:	df 92       	push	r13
    11d6:	ef 92       	push	r14
    11d8:	ff 92       	push	r15
    11da:	0f 93       	push	r16
    11dc:	1f 93       	push	r17
    11de:	cf 93       	push	r28
    11e0:	df 93       	push	r29
    11e2:	00 d0       	rcall	.+0      	; 0x11e4 <xQueueGenericSend+0x12>
    11e4:	00 d0       	rcall	.+0      	; 0x11e6 <xQueueGenericSend+0x14>
    11e6:	1f 92       	push	r1
    11e8:	cd b7       	in	r28, 0x3d	; 61
    11ea:	de b7       	in	r29, 0x3e	; 62
    11ec:	8c 01       	movw	r16, r24
    11ee:	7b 01       	movw	r14, r22
    11f0:	5d 83       	std	Y+5, r21	; 0x05
    11f2:	4c 83       	std	Y+4, r20	; 0x04
    11f4:	c2 2e       	mov	r12, r18
    11f6:	d1 2c       	mov	r13, r1
    11f8:	0f b6       	in	r0, 0x3f	; 63
    11fa:	f8 94       	cli
    11fc:	0f 92       	push	r0
    11fe:	f8 01       	movw	r30, r16
    1200:	92 8d       	ldd	r25, Z+26	; 0x1a
    1202:	83 8d       	ldd	r24, Z+27	; 0x1b
    1204:	98 17       	cp	r25, r24
    1206:	18 f0       	brcs	.+6      	; 0x120e <xQueueGenericSend+0x3c>
    1208:	f2 e0       	ldi	r31, 0x02	; 2
    120a:	cf 12       	cpse	r12, r31
    120c:	19 c0       	rjmp	.+50     	; 0x1240 <xQueueGenericSend+0x6e>
    120e:	4c 2d       	mov	r20, r12
    1210:	b7 01       	movw	r22, r14
    1212:	c8 01       	movw	r24, r16
    1214:	0e 94 b9 07 	call	0xf72	; 0xf72 <prvCopyDataToQueue>
    1218:	f8 01       	movw	r30, r16
    121a:	91 89       	ldd	r25, Z+17	; 0x11
    121c:	99 23       	and	r25, r25
    121e:	49 f0       	breq	.+18     	; 0x1232 <xQueueGenericSend+0x60>
    1220:	c8 01       	movw	r24, r16
    1222:	41 96       	adiw	r24, 0x11	; 17
    1224:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <xTaskRemoveFromEventList>
    1228:	88 23       	and	r24, r24
    122a:	31 f0       	breq	.+12     	; 0x1238 <xQueueGenericSend+0x66>
    122c:	0e 94 c8 06 	call	0xd90	; 0xd90 <vPortYield>
    1230:	03 c0       	rjmp	.+6      	; 0x1238 <xQueueGenericSend+0x66>
    1232:	81 11       	cpse	r24, r1
    1234:	0e 94 c8 06 	call	0xd90	; 0xd90 <vPortYield>
    1238:	0f 90       	pop	r0
    123a:	0f be       	out	0x3f, r0	; 63
    123c:	81 e0       	ldi	r24, 0x01	; 1
    123e:	4d c0       	rjmp	.+154    	; 0x12da <xQueueGenericSend+0x108>
    1240:	8c 81       	ldd	r24, Y+4	; 0x04
    1242:	9d 81       	ldd	r25, Y+5	; 0x05
    1244:	89 2b       	or	r24, r25
    1246:	21 f4       	brne	.+8      	; 0x1250 <xQueueGenericSend+0x7e>
    1248:	0f 90       	pop	r0
    124a:	0f be       	out	0x3f, r0	; 63
    124c:	80 e0       	ldi	r24, 0x00	; 0
    124e:	45 c0       	rjmp	.+138    	; 0x12da <xQueueGenericSend+0x108>
    1250:	d1 10       	cpse	r13, r1
    1252:	06 c0       	rjmp	.+12     	; 0x1260 <xQueueGenericSend+0x8e>
    1254:	ce 01       	movw	r24, r28
    1256:	01 96       	adiw	r24, 0x01	; 1
    1258:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vTaskSetTimeOutState>
    125c:	dd 24       	eor	r13, r13
    125e:	d3 94       	inc	r13
    1260:	0f 90       	pop	r0
    1262:	0f be       	out	0x3f, r0	; 63
    1264:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <vTaskSuspendAll>
    1268:	0f b6       	in	r0, 0x3f	; 63
    126a:	f8 94       	cli
    126c:	0f 92       	push	r0
    126e:	f8 01       	movw	r30, r16
    1270:	85 8d       	ldd	r24, Z+29	; 0x1d
    1272:	8f 3f       	cpi	r24, 0xFF	; 255
    1274:	09 f4       	brne	.+2      	; 0x1278 <xQueueGenericSend+0xa6>
    1276:	15 8e       	std	Z+29, r1	; 0x1d
    1278:	f8 01       	movw	r30, r16
    127a:	86 8d       	ldd	r24, Z+30	; 0x1e
    127c:	8f 3f       	cpi	r24, 0xFF	; 255
    127e:	09 f4       	brne	.+2      	; 0x1282 <xQueueGenericSend+0xb0>
    1280:	16 8e       	std	Z+30, r1	; 0x1e
    1282:	0f 90       	pop	r0
    1284:	0f be       	out	0x3f, r0	; 63
    1286:	be 01       	movw	r22, r28
    1288:	6c 5f       	subi	r22, 0xFC	; 252
    128a:	7f 4f       	sbci	r23, 0xFF	; 255
    128c:	ce 01       	movw	r24, r28
    128e:	01 96       	adiw	r24, 0x01	; 1
    1290:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <xTaskCheckForTimeOut>
    1294:	81 11       	cpse	r24, r1
    1296:	1b c0       	rjmp	.+54     	; 0x12ce <xQueueGenericSend+0xfc>
    1298:	c8 01       	movw	r24, r16
    129a:	0e 94 ab 07 	call	0xf56	; 0xf56 <prvIsQueueFull>
    129e:	88 23       	and	r24, r24
    12a0:	81 f0       	breq	.+32     	; 0x12c2 <xQueueGenericSend+0xf0>
    12a2:	6c 81       	ldd	r22, Y+4	; 0x04
    12a4:	7d 81       	ldd	r23, Y+5	; 0x05
    12a6:	c8 01       	movw	r24, r16
    12a8:	08 96       	adiw	r24, 0x08	; 8
    12aa:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <vTaskPlaceOnEventList>
    12ae:	c8 01       	movw	r24, r16
    12b0:	0e 94 32 08 	call	0x1064	; 0x1064 <prvUnlockQueue>
    12b4:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <xTaskResumeAll>
    12b8:	81 11       	cpse	r24, r1
    12ba:	9e cf       	rjmp	.-196    	; 0x11f8 <xQueueGenericSend+0x26>
    12bc:	0e 94 c8 06 	call	0xd90	; 0xd90 <vPortYield>
    12c0:	9b cf       	rjmp	.-202    	; 0x11f8 <xQueueGenericSend+0x26>
    12c2:	c8 01       	movw	r24, r16
    12c4:	0e 94 32 08 	call	0x1064	; 0x1064 <prvUnlockQueue>
    12c8:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <xTaskResumeAll>
    12cc:	95 cf       	rjmp	.-214    	; 0x11f8 <xQueueGenericSend+0x26>
    12ce:	c8 01       	movw	r24, r16
    12d0:	0e 94 32 08 	call	0x1064	; 0x1064 <prvUnlockQueue>
    12d4:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <xTaskResumeAll>
    12d8:	80 e0       	ldi	r24, 0x00	; 0
    12da:	0f 90       	pop	r0
    12dc:	0f 90       	pop	r0
    12de:	0f 90       	pop	r0
    12e0:	0f 90       	pop	r0
    12e2:	0f 90       	pop	r0
    12e4:	df 91       	pop	r29
    12e6:	cf 91       	pop	r28
    12e8:	1f 91       	pop	r17
    12ea:	0f 91       	pop	r16
    12ec:	ff 90       	pop	r15
    12ee:	ef 90       	pop	r14
    12f0:	df 90       	pop	r13
    12f2:	cf 90       	pop	r12
    12f4:	08 95       	ret

000012f6 <prvInitialiseMutex>:
    12f6:	00 97       	sbiw	r24, 0x00	; 0
    12f8:	69 f0       	breq	.+26     	; 0x1314 <prvInitialiseMutex+0x1e>
    12fa:	fc 01       	movw	r30, r24
    12fc:	13 82       	std	Z+3, r1	; 0x03
    12fe:	12 82       	std	Z+2, r1	; 0x02
    1300:	11 82       	std	Z+1, r1	; 0x01
    1302:	10 82       	st	Z, r1
    1304:	16 82       	std	Z+6, r1	; 0x06
    1306:	20 e0       	ldi	r18, 0x00	; 0
    1308:	40 e0       	ldi	r20, 0x00	; 0
    130a:	50 e0       	ldi	r21, 0x00	; 0
    130c:	60 e0       	ldi	r22, 0x00	; 0
    130e:	70 e0       	ldi	r23, 0x00	; 0
    1310:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <xQueueGenericSend>
    1314:	08 95       	ret

00001316 <xQueueCreateMutex>:
    1316:	cf 93       	push	r28
    1318:	df 93       	push	r29
    131a:	48 2f       	mov	r20, r24
    131c:	60 e0       	ldi	r22, 0x00	; 0
    131e:	81 e0       	ldi	r24, 0x01	; 1
    1320:	0e 94 bf 08 	call	0x117e	; 0x117e <xQueueGenericCreate>
    1324:	ec 01       	movw	r28, r24
    1326:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <prvInitialiseMutex>
    132a:	ce 01       	movw	r24, r28
    132c:	df 91       	pop	r29
    132e:	cf 91       	pop	r28
    1330:	08 95       	ret

00001332 <xQueueGenericSendFromISR>:
    1332:	ef 92       	push	r14
    1334:	ff 92       	push	r15
    1336:	0f 93       	push	r16
    1338:	1f 93       	push	r17
    133a:	cf 93       	push	r28
    133c:	df 93       	push	r29
    133e:	8a 01       	movw	r16, r20
    1340:	fc 01       	movw	r30, r24
    1342:	52 8d       	ldd	r21, Z+26	; 0x1a
    1344:	33 8d       	ldd	r19, Z+27	; 0x1b
    1346:	53 17       	cp	r21, r19
    1348:	10 f0       	brcs	.+4      	; 0x134e <xQueueGenericSendFromISR+0x1c>
    134a:	22 30       	cpi	r18, 0x02	; 2
    134c:	f1 f4       	brne	.+60     	; 0x138a <xQueueGenericSendFromISR+0x58>
    134e:	42 2f       	mov	r20, r18
    1350:	78 01       	movw	r14, r16
    1352:	ec 01       	movw	r28, r24
    1354:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1356:	0e 94 b9 07 	call	0xf72	; 0xf72 <prvCopyDataToQueue>
    135a:	1f 3f       	cpi	r17, 0xFF	; 255
    135c:	81 f4       	brne	.+32     	; 0x137e <xQueueGenericSendFromISR+0x4c>
    135e:	89 89       	ldd	r24, Y+17	; 0x11
    1360:	88 23       	and	r24, r24
    1362:	a9 f0       	breq	.+42     	; 0x138e <xQueueGenericSendFromISR+0x5c>
    1364:	ce 01       	movw	r24, r28
    1366:	41 96       	adiw	r24, 0x11	; 17
    1368:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <xTaskRemoveFromEventList>
    136c:	88 23       	and	r24, r24
    136e:	89 f0       	breq	.+34     	; 0x1392 <xQueueGenericSendFromISR+0x60>
    1370:	e1 14       	cp	r14, r1
    1372:	f1 04       	cpc	r15, r1
    1374:	81 f0       	breq	.+32     	; 0x1396 <xQueueGenericSendFromISR+0x64>
    1376:	81 e0       	ldi	r24, 0x01	; 1
    1378:	f7 01       	movw	r30, r14
    137a:	80 83       	st	Z, r24
    137c:	0d c0       	rjmp	.+26     	; 0x1398 <xQueueGenericSendFromISR+0x66>
    137e:	ff 24       	eor	r15, r15
    1380:	f3 94       	inc	r15
    1382:	f1 0e       	add	r15, r17
    1384:	fe 8e       	std	Y+30, r15	; 0x1e
    1386:	81 e0       	ldi	r24, 0x01	; 1
    1388:	07 c0       	rjmp	.+14     	; 0x1398 <xQueueGenericSendFromISR+0x66>
    138a:	80 e0       	ldi	r24, 0x00	; 0
    138c:	05 c0       	rjmp	.+10     	; 0x1398 <xQueueGenericSendFromISR+0x66>
    138e:	81 e0       	ldi	r24, 0x01	; 1
    1390:	03 c0       	rjmp	.+6      	; 0x1398 <xQueueGenericSendFromISR+0x66>
    1392:	81 e0       	ldi	r24, 0x01	; 1
    1394:	01 c0       	rjmp	.+2      	; 0x1398 <xQueueGenericSendFromISR+0x66>
    1396:	81 e0       	ldi	r24, 0x01	; 1
    1398:	df 91       	pop	r29
    139a:	cf 91       	pop	r28
    139c:	1f 91       	pop	r17
    139e:	0f 91       	pop	r16
    13a0:	ff 90       	pop	r15
    13a2:	ef 90       	pop	r14
    13a4:	08 95       	ret

000013a6 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    13a6:	8f 92       	push	r8
    13a8:	9f 92       	push	r9
    13aa:	bf 92       	push	r11
    13ac:	cf 92       	push	r12
    13ae:	df 92       	push	r13
    13b0:	ef 92       	push	r14
    13b2:	ff 92       	push	r15
    13b4:	0f 93       	push	r16
    13b6:	1f 93       	push	r17
    13b8:	cf 93       	push	r28
    13ba:	df 93       	push	r29
    13bc:	00 d0       	rcall	.+0      	; 0x13be <xQueueGenericReceive+0x18>
    13be:	00 d0       	rcall	.+0      	; 0x13c0 <xQueueGenericReceive+0x1a>
    13c0:	1f 92       	push	r1
    13c2:	cd b7       	in	r28, 0x3d	; 61
    13c4:	de b7       	in	r29, 0x3e	; 62
    13c6:	8c 01       	movw	r16, r24
    13c8:	6b 01       	movw	r12, r22
    13ca:	5d 83       	std	Y+5, r21	; 0x05
    13cc:	4c 83       	std	Y+4, r20	; 0x04
    13ce:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
    13d0:	e1 2c       	mov	r14, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    13d2:	0f b6       	in	r0, 0x3f	; 63
    13d4:	f8 94       	cli
    13d6:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    13d8:	f8 01       	movw	r30, r16
    13da:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    13dc:	ff 20       	and	r15, r15
    13de:	91 f1       	breq	.+100    	; 0x1444 <xQueueGenericReceive+0x9e>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    13e0:	86 80       	ldd	r8, Z+6	; 0x06
    13e2:	97 80       	ldd	r9, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    13e4:	b6 01       	movw	r22, r12
    13e6:	c8 01       	movw	r24, r16
    13e8:	0e 94 18 08 	call	0x1030	; 0x1030 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    13ec:	b1 10       	cpse	r11, r1
    13ee:	19 c0       	rjmp	.+50     	; 0x1422 <xQueueGenericReceive+0x7c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    13f0:	fa 94       	dec	r15
    13f2:	f8 01       	movw	r30, r16
    13f4:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    13f6:	80 81       	ld	r24, Z
    13f8:	91 81       	ldd	r25, Z+1	; 0x01
    13fa:	89 2b       	or	r24, r25
    13fc:	29 f4       	brne	.+10     	; 0x1408 <xQueueGenericReceive+0x62>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    13fe:	0e 94 12 10 	call	0x2024	; 0x2024 <pvTaskIncrementMutexHeldCount>
    1402:	f8 01       	movw	r30, r16
    1404:	93 83       	std	Z+3, r25	; 0x03
    1406:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1408:	f8 01       	movw	r30, r16
    140a:	80 85       	ldd	r24, Z+8	; 0x08
    140c:	88 23       	and	r24, r24
    140e:	b1 f0       	breq	.+44     	; 0x143c <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1410:	c8 01       	movw	r24, r16
    1412:	08 96       	adiw	r24, 0x08	; 8
    1414:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <xTaskRemoveFromEventList>
    1418:	88 23       	and	r24, r24
    141a:	81 f0       	breq	.+32     	; 0x143c <xQueueGenericReceive+0x96>
						{
							queueYIELD_IF_USING_PREEMPTION();
    141c:	0e 94 c8 06 	call	0xd90	; 0xd90 <vPortYield>
    1420:	0d c0       	rjmp	.+26     	; 0x143c <xQueueGenericReceive+0x96>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1422:	f8 01       	movw	r30, r16
    1424:	97 82       	std	Z+7, r9	; 0x07
    1426:	86 82       	std	Z+6, r8	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1428:	81 89       	ldd	r24, Z+17	; 0x11
    142a:	88 23       	and	r24, r24
    142c:	39 f0       	breq	.+14     	; 0x143c <xQueueGenericReceive+0x96>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    142e:	c8 01       	movw	r24, r16
    1430:	41 96       	adiw	r24, 0x11	; 17
    1432:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <xTaskRemoveFromEventList>
    1436:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1438:	0e 94 c8 06 	call	0xd90	; 0xd90 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    143c:	0f 90       	pop	r0
    143e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1440:	81 e0       	ldi	r24, 0x01	; 1
    1442:	61 c0       	rjmp	.+194    	; 0x1506 <xQueueGenericReceive+0x160>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1444:	8c 81       	ldd	r24, Y+4	; 0x04
    1446:	9d 81       	ldd	r25, Y+5	; 0x05
    1448:	89 2b       	or	r24, r25
    144a:	21 f4       	brne	.+8      	; 0x1454 <xQueueGenericReceive+0xae>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    144c:	0f 90       	pop	r0
    144e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1450:	80 e0       	ldi	r24, 0x00	; 0
    1452:	59 c0       	rjmp	.+178    	; 0x1506 <xQueueGenericReceive+0x160>
				}
				else if( xEntryTimeSet == pdFALSE )
    1454:	e1 10       	cpse	r14, r1
    1456:	06 c0       	rjmp	.+12     	; 0x1464 <xQueueGenericReceive+0xbe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1458:	ce 01       	movw	r24, r28
    145a:	01 96       	adiw	r24, 0x01	; 1
    145c:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1460:	ee 24       	eor	r14, r14
    1462:	e3 94       	inc	r14
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1464:	0f 90       	pop	r0
    1466:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1468:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    146c:	0f b6       	in	r0, 0x3f	; 63
    146e:	f8 94       	cli
    1470:	0f 92       	push	r0
    1472:	f8 01       	movw	r30, r16
    1474:	85 8d       	ldd	r24, Z+29	; 0x1d
    1476:	8f 3f       	cpi	r24, 0xFF	; 255
    1478:	09 f4       	brne	.+2      	; 0x147c <xQueueGenericReceive+0xd6>
    147a:	15 8e       	std	Z+29, r1	; 0x1d
    147c:	f8 01       	movw	r30, r16
    147e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1480:	8f 3f       	cpi	r24, 0xFF	; 255
    1482:	09 f4       	brne	.+2      	; 0x1486 <xQueueGenericReceive+0xe0>
    1484:	16 8e       	std	Z+30, r1	; 0x1e
    1486:	0f 90       	pop	r0
    1488:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    148a:	be 01       	movw	r22, r28
    148c:	6c 5f       	subi	r22, 0xFC	; 252
    148e:	7f 4f       	sbci	r23, 0xFF	; 255
    1490:	ce 01       	movw	r24, r28
    1492:	01 96       	adiw	r24, 0x01	; 1
    1494:	0e 94 33 0f 	call	0x1e66	; 0x1e66 <xTaskCheckForTimeOut>
    1498:	81 11       	cpse	r24, r1
    149a:	29 c0       	rjmp	.+82     	; 0x14ee <xQueueGenericReceive+0x148>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    149c:	c8 01       	movw	r24, r16
    149e:	0e 94 9e 07 	call	0xf3c	; 0xf3c <prvIsQueueEmpty>
    14a2:	88 23       	and	r24, r24
    14a4:	f1 f0       	breq	.+60     	; 0x14e2 <xQueueGenericReceive+0x13c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    14a6:	f8 01       	movw	r30, r16
    14a8:	80 81       	ld	r24, Z
    14aa:	91 81       	ldd	r25, Z+1	; 0x01
    14ac:	89 2b       	or	r24, r25
    14ae:	49 f4       	brne	.+18     	; 0x14c2 <xQueueGenericReceive+0x11c>
					{
						taskENTER_CRITICAL();
    14b0:	0f b6       	in	r0, 0x3f	; 63
    14b2:	f8 94       	cli
    14b4:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    14b6:	82 81       	ldd	r24, Z+2	; 0x02
    14b8:	93 81       	ldd	r25, Z+3	; 0x03
    14ba:	0e 94 70 0f 	call	0x1ee0	; 0x1ee0 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    14be:	0f 90       	pop	r0
    14c0:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    14c2:	6c 81       	ldd	r22, Y+4	; 0x04
    14c4:	7d 81       	ldd	r23, Y+5	; 0x05
    14c6:	c8 01       	movw	r24, r16
    14c8:	41 96       	adiw	r24, 0x11	; 17
    14ca:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    14ce:	c8 01       	movw	r24, r16
    14d0:	0e 94 32 08 	call	0x1064	; 0x1064 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    14d4:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <xTaskResumeAll>
    14d8:	81 11       	cpse	r24, r1
    14da:	7b cf       	rjmp	.-266    	; 0x13d2 <xQueueGenericReceive+0x2c>
				{
					portYIELD_WITHIN_API();
    14dc:	0e 94 c8 06 	call	0xd90	; 0xd90 <vPortYield>
    14e0:	78 cf       	rjmp	.-272    	; 0x13d2 <xQueueGenericReceive+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    14e2:	c8 01       	movw	r24, r16
    14e4:	0e 94 32 08 	call	0x1064	; 0x1064 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    14e8:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <xTaskResumeAll>
    14ec:	72 cf       	rjmp	.-284    	; 0x13d2 <xQueueGenericReceive+0x2c>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    14ee:	c8 01       	movw	r24, r16
    14f0:	0e 94 32 08 	call	0x1064	; 0x1064 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    14f4:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    14f8:	c8 01       	movw	r24, r16
    14fa:	0e 94 9e 07 	call	0xf3c	; 0xf3c <prvIsQueueEmpty>
    14fe:	88 23       	and	r24, r24
    1500:	09 f4       	brne	.+2      	; 0x1504 <xQueueGenericReceive+0x15e>
    1502:	67 cf       	rjmp	.-306    	; 0x13d2 <xQueueGenericReceive+0x2c>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1504:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1506:	0f 90       	pop	r0
    1508:	0f 90       	pop	r0
    150a:	0f 90       	pop	r0
    150c:	0f 90       	pop	r0
    150e:	0f 90       	pop	r0
    1510:	df 91       	pop	r29
    1512:	cf 91       	pop	r28
    1514:	1f 91       	pop	r17
    1516:	0f 91       	pop	r16
    1518:	ff 90       	pop	r15
    151a:	ef 90       	pop	r14
    151c:	df 90       	pop	r13
    151e:	cf 90       	pop	r12
    1520:	bf 90       	pop	r11
    1522:	9f 90       	pop	r9
    1524:	8f 90       	pop	r8
    1526:	08 95       	ret

00001528 <prvTaskIsTaskSuspended>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1528:	fc 01       	movw	r30, r24
    152a:	22 85       	ldd	r18, Z+10	; 0x0a
    152c:	33 85       	ldd	r19, Z+11	; 0x0b
    152e:	2d 5a       	subi	r18, 0xAD	; 173
    1530:	30 40       	sbci	r19, 0x00	; 0
    1532:	59 f4       	brne	.+22     	; 0x154a <prvTaskIsTaskSuspended+0x22>
    1534:	fc 01       	movw	r30, r24
    1536:	84 89       	ldd	r24, Z+20	; 0x14
    1538:	95 89       	ldd	r25, Z+21	; 0x15
    153a:	f0 e0       	ldi	r31, 0x00	; 0
    153c:	86 3b       	cpi	r24, 0xB6	; 182
    153e:	9f 07       	cpc	r25, r31
    1540:	31 f0       	breq	.+12     	; 0x154e <prvTaskIsTaskSuspended+0x26>
    1542:	89 2b       	or	r24, r25
    1544:	31 f0       	breq	.+12     	; 0x1552 <prvTaskIsTaskSuspended+0x2a>
    1546:	80 e0       	ldi	r24, 0x00	; 0
    1548:	08 95       	ret
    154a:	80 e0       	ldi	r24, 0x00	; 0
    154c:	08 95       	ret
    154e:	80 e0       	ldi	r24, 0x00	; 0
    1550:	08 95       	ret
    1552:	81 e0       	ldi	r24, 0x01	; 1
    1554:	08 95       	ret

00001556 <prvResetNextTaskUnblockTime>:
    1556:	e0 91 c1 00 	lds	r30, 0x00C1	; 0x8000c1 <pxDelayedTaskList>
    155a:	f0 91 c2 00 	lds	r31, 0x00C2	; 0x8000c2 <pxDelayedTaskList+0x1>
    155e:	80 81       	ld	r24, Z
    1560:	81 11       	cpse	r24, r1
    1562:	07 c0       	rjmp	.+14     	; 0x1572 <prvResetNextTaskUnblockTime+0x1c>
    1564:	8f ef       	ldi	r24, 0xFF	; 255
    1566:	9f ef       	ldi	r25, 0xFF	; 255
    1568:	90 93 a3 00 	sts	0x00A3, r25	; 0x8000a3 <xNextTaskUnblockTime+0x1>
    156c:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <xNextTaskUnblockTime>
    1570:	08 95       	ret
    1572:	e0 91 c1 00 	lds	r30, 0x00C1	; 0x8000c1 <pxDelayedTaskList>
    1576:	f0 91 c2 00 	lds	r31, 0x00C2	; 0x8000c2 <pxDelayedTaskList+0x1>
    157a:	05 80       	ldd	r0, Z+5	; 0x05
    157c:	f6 81       	ldd	r31, Z+6	; 0x06
    157e:	e0 2d       	mov	r30, r0
    1580:	06 80       	ldd	r0, Z+6	; 0x06
    1582:	f7 81       	ldd	r31, Z+7	; 0x07
    1584:	e0 2d       	mov	r30, r0
    1586:	82 81       	ldd	r24, Z+2	; 0x02
    1588:	93 81       	ldd	r25, Z+3	; 0x03
    158a:	90 93 a3 00 	sts	0x00A3, r25	; 0x8000a3 <xNextTaskUnblockTime+0x1>
    158e:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <xNextTaskUnblockTime>
    1592:	08 95       	ret

00001594 <prvInitialiseNewTask>:
    1594:	6f 92       	push	r6
    1596:	7f 92       	push	r7
    1598:	8f 92       	push	r8
    159a:	9f 92       	push	r9
    159c:	af 92       	push	r10
    159e:	bf 92       	push	r11
    15a0:	cf 92       	push	r12
    15a2:	df 92       	push	r13
    15a4:	ef 92       	push	r14
    15a6:	0f 93       	push	r16
    15a8:	1f 93       	push	r17
    15aa:	cf 93       	push	r28
    15ac:	df 93       	push	r29
    15ae:	cd b7       	in	r28, 0x3d	; 61
    15b0:	de b7       	in	r29, 0x3e	; 62
    15b2:	4c 01       	movw	r8, r24
    15b4:	f5 01       	movw	r30, r10
    15b6:	87 89       	ldd	r24, Z+23	; 0x17
    15b8:	90 8d       	ldd	r25, Z+24	; 0x18
    15ba:	21 50       	subi	r18, 0x01	; 1
    15bc:	31 09       	sbc	r19, r1
    15be:	3c 01       	movw	r6, r24
    15c0:	62 0e       	add	r6, r18
    15c2:	73 1e       	adc	r7, r19
    15c4:	20 e0       	ldi	r18, 0x00	; 0
    15c6:	0f c0       	rjmp	.+30     	; 0x15e6 <prvInitialiseNewTask+0x52>
    15c8:	82 2f       	mov	r24, r18
    15ca:	90 e0       	ldi	r25, 0x00	; 0
    15cc:	fb 01       	movw	r30, r22
    15ce:	e8 0f       	add	r30, r24
    15d0:	f9 1f       	adc	r31, r25
    15d2:	30 81       	ld	r19, Z
    15d4:	d5 01       	movw	r26, r10
    15d6:	a8 0f       	add	r26, r24
    15d8:	b9 1f       	adc	r27, r25
    15da:	59 96       	adiw	r26, 0x19	; 25
    15dc:	3c 93       	st	X, r19
    15de:	80 81       	ld	r24, Z
    15e0:	88 23       	and	r24, r24
    15e2:	19 f0       	breq	.+6      	; 0x15ea <prvInitialiseNewTask+0x56>
    15e4:	2f 5f       	subi	r18, 0xFF	; 255
    15e6:	28 30       	cpi	r18, 0x08	; 8
    15e8:	78 f3       	brcs	.-34     	; 0x15c8 <prvInitialiseNewTask+0x34>
    15ea:	f5 01       	movw	r30, r10
    15ec:	10 a2       	std	Z+32, r1	; 0x20
    15ee:	f3 e0       	ldi	r31, 0x03	; 3
    15f0:	fe 15       	cp	r31, r14
    15f2:	20 f4       	brcc	.+8      	; 0x15fc <prvInitialiseNewTask+0x68>
    15f4:	0f 2e       	mov	r0, r31
    15f6:	f3 e0       	ldi	r31, 0x03	; 3
    15f8:	ef 2e       	mov	r14, r31
    15fa:	f0 2d       	mov	r31, r0
    15fc:	f5 01       	movw	r30, r10
    15fe:	e6 8a       	std	Z+22, r14	; 0x16
    1600:	e1 a2       	std	Z+33, r14	; 0x21
    1602:	12 a2       	std	Z+34, r1	; 0x22
    1604:	c5 01       	movw	r24, r10
    1606:	02 96       	adiw	r24, 0x02	; 2
    1608:	0e 94 a8 05 	call	0xb50	; 0xb50 <vListInitialiseItem>
    160c:	c5 01       	movw	r24, r10
    160e:	0c 96       	adiw	r24, 0x0c	; 12
    1610:	0e 94 a8 05 	call	0xb50	; 0xb50 <vListInitialiseItem>
    1614:	f5 01       	movw	r30, r10
    1616:	b1 86       	std	Z+9, r11	; 0x09
    1618:	a0 86       	std	Z+8, r10	; 0x08
    161a:	84 e0       	ldi	r24, 0x04	; 4
    161c:	90 e0       	ldi	r25, 0x00	; 0
    161e:	8e 19       	sub	r24, r14
    1620:	91 09       	sbc	r25, r1
    1622:	95 87       	std	Z+13, r25	; 0x0d
    1624:	84 87       	std	Z+12, r24	; 0x0c
    1626:	b3 8a       	std	Z+19, r11	; 0x13
    1628:	a2 8a       	std	Z+18, r10	; 0x12
    162a:	13 a2       	std	Z+35, r1	; 0x23
    162c:	14 a2       	std	Z+36, r1	; 0x24
    162e:	15 a2       	std	Z+37, r1	; 0x25
    1630:	16 a2       	std	Z+38, r1	; 0x26
    1632:	17 a2       	std	Z+39, r1	; 0x27
    1634:	a8 01       	movw	r20, r16
    1636:	b4 01       	movw	r22, r8
    1638:	c3 01       	movw	r24, r6
    163a:	0e 94 2d 06 	call	0xc5a	; 0xc5a <pxPortInitialiseStack>
    163e:	f5 01       	movw	r30, r10
    1640:	91 83       	std	Z+1, r25	; 0x01
    1642:	80 83       	st	Z, r24
    1644:	c1 14       	cp	r12, r1
    1646:	d1 04       	cpc	r13, r1
    1648:	19 f0       	breq	.+6      	; 0x1650 <prvInitialiseNewTask+0xbc>
    164a:	f6 01       	movw	r30, r12
    164c:	b1 82       	std	Z+1, r11	; 0x01
    164e:	a0 82       	st	Z, r10
    1650:	df 91       	pop	r29
    1652:	cf 91       	pop	r28
    1654:	1f 91       	pop	r17
    1656:	0f 91       	pop	r16
    1658:	ef 90       	pop	r14
    165a:	df 90       	pop	r13
    165c:	cf 90       	pop	r12
    165e:	bf 90       	pop	r11
    1660:	af 90       	pop	r10
    1662:	9f 90       	pop	r9
    1664:	8f 90       	pop	r8
    1666:	7f 90       	pop	r7
    1668:	6f 90       	pop	r6
    166a:	08 95       	ret

0000166c <prvIdleTask>:
    166c:	80 91 d5 00 	lds	r24, 0x00D5	; 0x8000d5 <pxReadyTasksLists>
    1670:	82 30       	cpi	r24, 0x02	; 2
    1672:	e0 f3       	brcs	.-8      	; 0x166c <prvIdleTask>
    1674:	0e 94 c8 06 	call	0xd90	; 0xd90 <vPortYield>
    1678:	f9 cf       	rjmp	.-14     	; 0x166c <prvIdleTask>

0000167a <prvInitialiseTaskLists>:
    167a:	cf 93       	push	r28
    167c:	c0 e0       	ldi	r28, 0x00	; 0
    167e:	10 c0       	rjmp	.+32     	; 0x16a0 <prvInitialiseTaskLists+0x26>
    1680:	8c 2f       	mov	r24, r28
    1682:	90 e0       	ldi	r25, 0x00	; 0
    1684:	9c 01       	movw	r18, r24
    1686:	22 0f       	add	r18, r18
    1688:	33 1f       	adc	r19, r19
    168a:	22 0f       	add	r18, r18
    168c:	33 1f       	adc	r19, r19
    168e:	22 0f       	add	r18, r18
    1690:	33 1f       	adc	r19, r19
    1692:	82 0f       	add	r24, r18
    1694:	93 1f       	adc	r25, r19
    1696:	8b 52       	subi	r24, 0x2B	; 43
    1698:	9f 4f       	sbci	r25, 0xFF	; 255
    169a:	0e 94 9a 05 	call	0xb34	; 0xb34 <vListInitialise>
    169e:	cf 5f       	subi	r28, 0xFF	; 255
    16a0:	c4 30       	cpi	r28, 0x04	; 4
    16a2:	70 f3       	brcs	.-36     	; 0x1680 <prvInitialiseTaskLists+0x6>
    16a4:	8c ec       	ldi	r24, 0xCC	; 204
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	0e 94 9a 05 	call	0xb34	; 0xb34 <vListInitialise>
    16ac:	83 ec       	ldi	r24, 0xC3	; 195
    16ae:	90 e0       	ldi	r25, 0x00	; 0
    16b0:	0e 94 9a 05 	call	0xb34	; 0xb34 <vListInitialise>
    16b4:	86 eb       	ldi	r24, 0xB6	; 182
    16b6:	90 e0       	ldi	r25, 0x00	; 0
    16b8:	0e 94 9a 05 	call	0xb34	; 0xb34 <vListInitialise>
    16bc:	8d ea       	ldi	r24, 0xAD	; 173
    16be:	90 e0       	ldi	r25, 0x00	; 0
    16c0:	0e 94 9a 05 	call	0xb34	; 0xb34 <vListInitialise>
    16c4:	8c ec       	ldi	r24, 0xCC	; 204
    16c6:	90 e0       	ldi	r25, 0x00	; 0
    16c8:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <pxDelayedTaskList+0x1>
    16cc:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <pxDelayedTaskList>
    16d0:	83 ec       	ldi	r24, 0xC3	; 195
    16d2:	90 e0       	ldi	r25, 0x00	; 0
    16d4:	90 93 c0 00 	sts	0x00C0, r25	; 0x8000c0 <pxOverflowDelayedTaskList+0x1>
    16d8:	80 93 bf 00 	sts	0x00BF, r24	; 0x8000bf <pxOverflowDelayedTaskList>
    16dc:	cf 91       	pop	r28
    16de:	08 95       	ret

000016e0 <prvAddNewTaskToReadyList>:
    16e0:	cf 93       	push	r28
    16e2:	df 93       	push	r29
    16e4:	ec 01       	movw	r28, r24
    16e6:	0f b6       	in	r0, 0x3f	; 63
    16e8:	f8 94       	cli
    16ea:	0f 92       	push	r0
    16ec:	80 91 ac 00 	lds	r24, 0x00AC	; 0x8000ac <uxCurrentNumberOfTasks>
    16f0:	8f 5f       	subi	r24, 0xFF	; 255
    16f2:	80 93 ac 00 	sts	0x00AC, r24	; 0x8000ac <uxCurrentNumberOfTasks>
    16f6:	80 91 f9 00 	lds	r24, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    16fa:	90 91 fa 00 	lds	r25, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    16fe:	89 2b       	or	r24, r25
    1700:	59 f4       	brne	.+22     	; 0x1718 <prvAddNewTaskToReadyList+0x38>
    1702:	d0 93 fa 00 	sts	0x00FA, r29	; 0x8000fa <pxCurrentTCB+0x1>
    1706:	c0 93 f9 00 	sts	0x00F9, r28	; 0x8000f9 <pxCurrentTCB>
    170a:	80 91 ac 00 	lds	r24, 0x00AC	; 0x8000ac <uxCurrentNumberOfTasks>
    170e:	81 30       	cpi	r24, 0x01	; 1
    1710:	99 f4       	brne	.+38     	; 0x1738 <prvAddNewTaskToReadyList+0x58>
    1712:	0e 94 3d 0b 	call	0x167a	; 0x167a <prvInitialiseTaskLists>
    1716:	10 c0       	rjmp	.+32     	; 0x1738 <prvAddNewTaskToReadyList+0x58>
    1718:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <xSchedulerRunning>
    171c:	81 11       	cpse	r24, r1
    171e:	0c c0       	rjmp	.+24     	; 0x1738 <prvAddNewTaskToReadyList+0x58>
    1720:	e0 91 f9 00 	lds	r30, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1724:	f0 91 fa 00 	lds	r31, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1728:	96 89       	ldd	r25, Z+22	; 0x16
    172a:	8e 89       	ldd	r24, Y+22	; 0x16
    172c:	89 17       	cp	r24, r25
    172e:	20 f0       	brcs	.+8      	; 0x1738 <prvAddNewTaskToReadyList+0x58>
    1730:	d0 93 fa 00 	sts	0x00FA, r29	; 0x8000fa <pxCurrentTCB+0x1>
    1734:	c0 93 f9 00 	sts	0x00F9, r28	; 0x8000f9 <pxCurrentTCB>
    1738:	80 91 a4 00 	lds	r24, 0x00A4	; 0x8000a4 <uxTaskNumber>
    173c:	8f 5f       	subi	r24, 0xFF	; 255
    173e:	80 93 a4 00 	sts	0x00A4, r24	; 0x8000a4 <uxTaskNumber>
    1742:	8e 89       	ldd	r24, Y+22	; 0x16
    1744:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <uxTopReadyPriority>
    1748:	98 17       	cp	r25, r24
    174a:	10 f4       	brcc	.+4      	; 0x1750 <prvAddNewTaskToReadyList+0x70>
    174c:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <uxTopReadyPriority>
    1750:	90 e0       	ldi	r25, 0x00	; 0
    1752:	9c 01       	movw	r18, r24
    1754:	22 0f       	add	r18, r18
    1756:	33 1f       	adc	r19, r19
    1758:	22 0f       	add	r18, r18
    175a:	33 1f       	adc	r19, r19
    175c:	22 0f       	add	r18, r18
    175e:	33 1f       	adc	r19, r19
    1760:	82 0f       	add	r24, r18
    1762:	93 1f       	adc	r25, r19
    1764:	be 01       	movw	r22, r28
    1766:	6e 5f       	subi	r22, 0xFE	; 254
    1768:	7f 4f       	sbci	r23, 0xFF	; 255
    176a:	8b 52       	subi	r24, 0x2B	; 43
    176c:	9f 4f       	sbci	r25, 0xFF	; 255
    176e:	0e 94 ac 05 	call	0xb58	; 0xb58 <vListInsertEnd>
    1772:	0f 90       	pop	r0
    1774:	0f be       	out	0x3f, r0	; 63
    1776:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <xSchedulerRunning>
    177a:	88 23       	and	r24, r24
    177c:	51 f0       	breq	.+20     	; 0x1792 <prvAddNewTaskToReadyList+0xb2>
    177e:	e0 91 f9 00 	lds	r30, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1782:	f0 91 fa 00 	lds	r31, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1786:	96 89       	ldd	r25, Z+22	; 0x16
    1788:	8e 89       	ldd	r24, Y+22	; 0x16
    178a:	98 17       	cp	r25, r24
    178c:	10 f4       	brcc	.+4      	; 0x1792 <prvAddNewTaskToReadyList+0xb2>
    178e:	0e 94 c8 06 	call	0xd90	; 0xd90 <vPortYield>
    1792:	df 91       	pop	r29
    1794:	cf 91       	pop	r28
    1796:	08 95       	ret

00001798 <prvAddCurrentTaskToDelayedList>:
    1798:	ff 92       	push	r15
    179a:	0f 93       	push	r16
    179c:	1f 93       	push	r17
    179e:	cf 93       	push	r28
    17a0:	df 93       	push	r29
    17a2:	ec 01       	movw	r28, r24
    17a4:	f6 2e       	mov	r15, r22
    17a6:	00 91 aa 00 	lds	r16, 0x00AA	; 0x8000aa <xTickCount>
    17aa:	10 91 ab 00 	lds	r17, 0x00AB	; 0x8000ab <xTickCount+0x1>
    17ae:	80 91 f9 00 	lds	r24, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    17b2:	90 91 fa 00 	lds	r25, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    17b6:	02 96       	adiw	r24, 0x02	; 2
    17b8:	0e 94 fe 05 	call	0xbfc	; 0xbfc <uxListRemove>
    17bc:	cf 3f       	cpi	r28, 0xFF	; 255
    17be:	8f ef       	ldi	r24, 0xFF	; 255
    17c0:	d8 07       	cpc	r29, r24
    17c2:	69 f4       	brne	.+26     	; 0x17de <prvAddCurrentTaskToDelayedList+0x46>
    17c4:	ff 20       	and	r15, r15
    17c6:	59 f0       	breq	.+22     	; 0x17de <prvAddCurrentTaskToDelayedList+0x46>
    17c8:	60 91 f9 00 	lds	r22, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    17cc:	70 91 fa 00 	lds	r23, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    17d0:	6e 5f       	subi	r22, 0xFE	; 254
    17d2:	7f 4f       	sbci	r23, 0xFF	; 255
    17d4:	8d ea       	ldi	r24, 0xAD	; 173
    17d6:	90 e0       	ldi	r25, 0x00	; 0
    17d8:	0e 94 ac 05 	call	0xb58	; 0xb58 <vListInsertEnd>
    17dc:	2f c0       	rjmp	.+94     	; 0x183c <prvAddCurrentTaskToDelayedList+0xa4>
    17de:	c0 0f       	add	r28, r16
    17e0:	d1 1f       	adc	r29, r17
    17e2:	e0 91 f9 00 	lds	r30, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    17e6:	f0 91 fa 00 	lds	r31, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    17ea:	d3 83       	std	Z+3, r29	; 0x03
    17ec:	c2 83       	std	Z+2, r28	; 0x02
    17ee:	c0 17       	cp	r28, r16
    17f0:	d1 07       	cpc	r29, r17
    17f2:	68 f4       	brcc	.+26     	; 0x180e <prvAddCurrentTaskToDelayedList+0x76>
    17f4:	60 91 f9 00 	lds	r22, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    17f8:	70 91 fa 00 	lds	r23, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    17fc:	80 91 bf 00 	lds	r24, 0x00BF	; 0x8000bf <pxOverflowDelayedTaskList>
    1800:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <pxOverflowDelayedTaskList+0x1>
    1804:	6e 5f       	subi	r22, 0xFE	; 254
    1806:	7f 4f       	sbci	r23, 0xFF	; 255
    1808:	0e 94 cd 05 	call	0xb9a	; 0xb9a <vListInsert>
    180c:	17 c0       	rjmp	.+46     	; 0x183c <prvAddCurrentTaskToDelayedList+0xa4>
    180e:	60 91 f9 00 	lds	r22, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1812:	70 91 fa 00 	lds	r23, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1816:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <pxDelayedTaskList>
    181a:	90 91 c2 00 	lds	r25, 0x00C2	; 0x8000c2 <pxDelayedTaskList+0x1>
    181e:	6e 5f       	subi	r22, 0xFE	; 254
    1820:	7f 4f       	sbci	r23, 0xFF	; 255
    1822:	0e 94 cd 05 	call	0xb9a	; 0xb9a <vListInsert>
    1826:	80 91 a2 00 	lds	r24, 0x00A2	; 0x8000a2 <xNextTaskUnblockTime>
    182a:	90 91 a3 00 	lds	r25, 0x00A3	; 0x8000a3 <xNextTaskUnblockTime+0x1>
    182e:	c8 17       	cp	r28, r24
    1830:	d9 07       	cpc	r29, r25
    1832:	20 f4       	brcc	.+8      	; 0x183c <prvAddCurrentTaskToDelayedList+0xa4>
    1834:	d0 93 a3 00 	sts	0x00A3, r29	; 0x8000a3 <xNextTaskUnblockTime+0x1>
    1838:	c0 93 a2 00 	sts	0x00A2, r28	; 0x8000a2 <xNextTaskUnblockTime>
    183c:	df 91       	pop	r29
    183e:	cf 91       	pop	r28
    1840:	1f 91       	pop	r17
    1842:	0f 91       	pop	r16
    1844:	ff 90       	pop	r15
    1846:	08 95       	ret

00001848 <xTaskCreate>:
    1848:	2f 92       	push	r2
    184a:	3f 92       	push	r3
    184c:	4f 92       	push	r4
    184e:	5f 92       	push	r5
    1850:	6f 92       	push	r6
    1852:	7f 92       	push	r7
    1854:	8f 92       	push	r8
    1856:	9f 92       	push	r9
    1858:	af 92       	push	r10
    185a:	bf 92       	push	r11
    185c:	cf 92       	push	r12
    185e:	df 92       	push	r13
    1860:	ef 92       	push	r14
    1862:	ff 92       	push	r15
    1864:	0f 93       	push	r16
    1866:	1f 93       	push	r17
    1868:	cf 93       	push	r28
    186a:	df 93       	push	r29
    186c:	3c 01       	movw	r6, r24
    186e:	1b 01       	movw	r2, r22
    1870:	5a 01       	movw	r10, r20
    1872:	29 01       	movw	r4, r18
    1874:	ca 01       	movw	r24, r20
    1876:	0e 94 80 07 	call	0xf00	; 0xf00 <pvPortMalloc>
    187a:	6c 01       	movw	r12, r24
    187c:	89 2b       	or	r24, r25
    187e:	71 f0       	breq	.+28     	; 0x189c <xTaskCreate+0x54>
    1880:	88 e2       	ldi	r24, 0x28	; 40
    1882:	90 e0       	ldi	r25, 0x00	; 0
    1884:	0e 94 80 07 	call	0xf00	; 0xf00 <pvPortMalloc>
    1888:	ec 01       	movw	r28, r24
    188a:	89 2b       	or	r24, r25
    188c:	19 f0       	breq	.+6      	; 0x1894 <xTaskCreate+0x4c>
    188e:	d8 8e       	std	Y+24, r13	; 0x18
    1890:	cf 8a       	std	Y+23, r12	; 0x17
    1892:	06 c0       	rjmp	.+12     	; 0x18a0 <xTaskCreate+0x58>
    1894:	c6 01       	movw	r24, r12
    1896:	0e 94 8f 07 	call	0xf1e	; 0xf1e <vPortFree>
    189a:	02 c0       	rjmp	.+4      	; 0x18a0 <xTaskCreate+0x58>
    189c:	c0 e0       	ldi	r28, 0x00	; 0
    189e:	d0 e0       	ldi	r29, 0x00	; 0
    18a0:	20 97       	sbiw	r28, 0x00	; 0
    18a2:	91 f0       	breq	.+36     	; 0x18c8 <xTaskCreate+0x80>
    18a4:	95 01       	movw	r18, r10
    18a6:	40 e0       	ldi	r20, 0x00	; 0
    18a8:	50 e0       	ldi	r21, 0x00	; 0
    18aa:	81 2c       	mov	r8, r1
    18ac:	91 2c       	mov	r9, r1
    18ae:	5e 01       	movw	r10, r28
    18b0:	67 01       	movw	r12, r14
    18b2:	e0 2e       	mov	r14, r16
    18b4:	82 01       	movw	r16, r4
    18b6:	b1 01       	movw	r22, r2
    18b8:	c3 01       	movw	r24, r6
    18ba:	0e 94 ca 0a 	call	0x1594	; 0x1594 <prvInitialiseNewTask>
    18be:	ce 01       	movw	r24, r28
    18c0:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <prvAddNewTaskToReadyList>
    18c4:	81 e0       	ldi	r24, 0x01	; 1
    18c6:	01 c0       	rjmp	.+2      	; 0x18ca <xTaskCreate+0x82>
    18c8:	8f ef       	ldi	r24, 0xFF	; 255
    18ca:	df 91       	pop	r29
    18cc:	cf 91       	pop	r28
    18ce:	1f 91       	pop	r17
    18d0:	0f 91       	pop	r16
    18d2:	ff 90       	pop	r15
    18d4:	ef 90       	pop	r14
    18d6:	df 90       	pop	r13
    18d8:	cf 90       	pop	r12
    18da:	bf 90       	pop	r11
    18dc:	af 90       	pop	r10
    18de:	9f 90       	pop	r9
    18e0:	8f 90       	pop	r8
    18e2:	7f 90       	pop	r7
    18e4:	6f 90       	pop	r6
    18e6:	5f 90       	pop	r5
    18e8:	4f 90       	pop	r4
    18ea:	3f 90       	pop	r3
    18ec:	2f 90       	pop	r2
    18ee:	08 95       	ret

000018f0 <vTaskResume>:
    18f0:	0f 93       	push	r16
    18f2:	1f 93       	push	r17
    18f4:	cf 93       	push	r28
    18f6:	df 93       	push	r29
    18f8:	00 97       	sbiw	r24, 0x00	; 0
    18fa:	b9 f1       	breq	.+110    	; 0x196a <vTaskResume+0x7a>
    18fc:	20 91 f9 00 	lds	r18, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1900:	30 91 fa 00 	lds	r19, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1904:	82 17       	cp	r24, r18
    1906:	93 07       	cpc	r25, r19
    1908:	81 f1       	breq	.+96     	; 0x196a <vTaskResume+0x7a>
    190a:	ec 01       	movw	r28, r24
    190c:	0f b6       	in	r0, 0x3f	; 63
    190e:	f8 94       	cli
    1910:	0f 92       	push	r0
    1912:	0e 94 94 0a 	call	0x1528	; 0x1528 <prvTaskIsTaskSuspended>
    1916:	88 23       	and	r24, r24
    1918:	31 f1       	breq	.+76     	; 0x1966 <vTaskResume+0x76>
    191a:	8e 01       	movw	r16, r28
    191c:	0e 5f       	subi	r16, 0xFE	; 254
    191e:	1f 4f       	sbci	r17, 0xFF	; 255
    1920:	c8 01       	movw	r24, r16
    1922:	0e 94 fe 05 	call	0xbfc	; 0xbfc <uxListRemove>
    1926:	8e 89       	ldd	r24, Y+22	; 0x16
    1928:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <uxTopReadyPriority>
    192c:	98 17       	cp	r25, r24
    192e:	10 f4       	brcc	.+4      	; 0x1934 <vTaskResume+0x44>
    1930:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <uxTopReadyPriority>
    1934:	90 e0       	ldi	r25, 0x00	; 0
    1936:	9c 01       	movw	r18, r24
    1938:	22 0f       	add	r18, r18
    193a:	33 1f       	adc	r19, r19
    193c:	22 0f       	add	r18, r18
    193e:	33 1f       	adc	r19, r19
    1940:	22 0f       	add	r18, r18
    1942:	33 1f       	adc	r19, r19
    1944:	82 0f       	add	r24, r18
    1946:	93 1f       	adc	r25, r19
    1948:	b8 01       	movw	r22, r16
    194a:	8b 52       	subi	r24, 0x2B	; 43
    194c:	9f 4f       	sbci	r25, 0xFF	; 255
    194e:	0e 94 ac 05 	call	0xb58	; 0xb58 <vListInsertEnd>
    1952:	9e 89       	ldd	r25, Y+22	; 0x16
    1954:	e0 91 f9 00 	lds	r30, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1958:	f0 91 fa 00 	lds	r31, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    195c:	86 89       	ldd	r24, Z+22	; 0x16
    195e:	98 17       	cp	r25, r24
    1960:	10 f0       	brcs	.+4      	; 0x1966 <vTaskResume+0x76>
    1962:	0e 94 c8 06 	call	0xd90	; 0xd90 <vPortYield>
    1966:	0f 90       	pop	r0
    1968:	0f be       	out	0x3f, r0	; 63
    196a:	df 91       	pop	r29
    196c:	cf 91       	pop	r28
    196e:	1f 91       	pop	r17
    1970:	0f 91       	pop	r16
    1972:	08 95       	ret

00001974 <vTaskStartScheduler>:
    1974:	ef 92       	push	r14
    1976:	ff 92       	push	r15
    1978:	0f 93       	push	r16
    197a:	0f 2e       	mov	r0, r31
    197c:	f0 ea       	ldi	r31, 0xA0	; 160
    197e:	ef 2e       	mov	r14, r31
    1980:	f0 e0       	ldi	r31, 0x00	; 0
    1982:	ff 2e       	mov	r15, r31
    1984:	f0 2d       	mov	r31, r0
    1986:	00 e0       	ldi	r16, 0x00	; 0
    1988:	20 e0       	ldi	r18, 0x00	; 0
    198a:	30 e0       	ldi	r19, 0x00	; 0
    198c:	45 e5       	ldi	r20, 0x55	; 85
    198e:	50 e0       	ldi	r21, 0x00	; 0
    1990:	67 e9       	ldi	r22, 0x97	; 151
    1992:	70 e0       	ldi	r23, 0x00	; 0
    1994:	86 e3       	ldi	r24, 0x36	; 54
    1996:	9b e0       	ldi	r25, 0x0B	; 11
    1998:	0e 94 24 0c 	call	0x1848	; 0x1848 <xTaskCreate>
    199c:	81 30       	cpi	r24, 0x01	; 1
    199e:	81 f4       	brne	.+32     	; 0x19c0 <vTaskStartScheduler+0x4c>
    19a0:	f8 94       	cli
    19a2:	8f ef       	ldi	r24, 0xFF	; 255
    19a4:	9f ef       	ldi	r25, 0xFF	; 255
    19a6:	90 93 a3 00 	sts	0x00A3, r25	; 0x8000a3 <xNextTaskUnblockTime+0x1>
    19aa:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <xNextTaskUnblockTime>
    19ae:	81 e0       	ldi	r24, 0x01	; 1
    19b0:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <xSchedulerRunning>
    19b4:	10 92 ab 00 	sts	0x00AB, r1	; 0x8000ab <xTickCount+0x1>
    19b8:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <xTickCount>
    19bc:	0e 94 99 06 	call	0xd32	; 0xd32 <xPortStartScheduler>
    19c0:	0f 91       	pop	r16
    19c2:	ff 90       	pop	r15
    19c4:	ef 90       	pop	r14
    19c6:	08 95       	ret

000019c8 <vTaskSuspendAll>:
    19c8:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <uxSchedulerSuspended>
    19cc:	8f 5f       	subi	r24, 0xFF	; 255
    19ce:	80 93 9f 00 	sts	0x009F, r24	; 0x80009f <uxSchedulerSuspended>
    19d2:	08 95       	ret

000019d4 <xTaskIncrementTick>:
    19d4:	df 92       	push	r13
    19d6:	ef 92       	push	r14
    19d8:	ff 92       	push	r15
    19da:	0f 93       	push	r16
    19dc:	1f 93       	push	r17
    19de:	cf 93       	push	r28
    19e0:	df 93       	push	r29
    19e2:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <uxSchedulerSuspended>
    19e6:	81 11       	cpse	r24, r1
    19e8:	97 c0       	rjmp	.+302    	; 0x1b18 <xTaskIncrementTick+0x144>
    19ea:	e0 90 aa 00 	lds	r14, 0x00AA	; 0x8000aa <xTickCount>
    19ee:	f0 90 ab 00 	lds	r15, 0x00AB	; 0x8000ab <xTickCount+0x1>
    19f2:	8f ef       	ldi	r24, 0xFF	; 255
    19f4:	e8 1a       	sub	r14, r24
    19f6:	f8 0a       	sbc	r15, r24
    19f8:	f0 92 ab 00 	sts	0x00AB, r15	; 0x8000ab <xTickCount+0x1>
    19fc:	e0 92 aa 00 	sts	0x00AA, r14	; 0x8000aa <xTickCount>
    1a00:	e1 14       	cp	r14, r1
    1a02:	f1 04       	cpc	r15, r1
    1a04:	b9 f4       	brne	.+46     	; 0x1a34 <xTaskIncrementTick+0x60>
    1a06:	80 91 c1 00 	lds	r24, 0x00C1	; 0x8000c1 <pxDelayedTaskList>
    1a0a:	90 91 c2 00 	lds	r25, 0x00C2	; 0x8000c2 <pxDelayedTaskList+0x1>
    1a0e:	20 91 bf 00 	lds	r18, 0x00BF	; 0x8000bf <pxOverflowDelayedTaskList>
    1a12:	30 91 c0 00 	lds	r19, 0x00C0	; 0x8000c0 <pxOverflowDelayedTaskList+0x1>
    1a16:	30 93 c2 00 	sts	0x00C2, r19	; 0x8000c2 <pxDelayedTaskList+0x1>
    1a1a:	20 93 c1 00 	sts	0x00C1, r18	; 0x8000c1 <pxDelayedTaskList>
    1a1e:	90 93 c0 00 	sts	0x00C0, r25	; 0x8000c0 <pxOverflowDelayedTaskList+0x1>
    1a22:	80 93 bf 00 	sts	0x00BF, r24	; 0x8000bf <pxOverflowDelayedTaskList>
    1a26:	80 91 a5 00 	lds	r24, 0x00A5	; 0x8000a5 <xNumOfOverflows>
    1a2a:	8f 5f       	subi	r24, 0xFF	; 255
    1a2c:	80 93 a5 00 	sts	0x00A5, r24	; 0x8000a5 <xNumOfOverflows>
    1a30:	0e 94 ab 0a 	call	0x1556	; 0x1556 <prvResetNextTaskUnblockTime>
    1a34:	80 91 a2 00 	lds	r24, 0x00A2	; 0x8000a2 <xNextTaskUnblockTime>
    1a38:	90 91 a3 00 	lds	r25, 0x00A3	; 0x8000a3 <xNextTaskUnblockTime+0x1>
    1a3c:	e8 16       	cp	r14, r24
    1a3e:	f9 06       	cpc	r15, r25
    1a40:	28 f4       	brcc	.+10     	; 0x1a4c <xTaskIncrementTick+0x78>
    1a42:	d1 2c       	mov	r13, r1
    1a44:	53 c0       	rjmp	.+166    	; 0x1aec <xTaskIncrementTick+0x118>
    1a46:	dd 24       	eor	r13, r13
    1a48:	d3 94       	inc	r13
    1a4a:	01 c0       	rjmp	.+2      	; 0x1a4e <xTaskIncrementTick+0x7a>
    1a4c:	d1 2c       	mov	r13, r1
    1a4e:	e0 91 c1 00 	lds	r30, 0x00C1	; 0x8000c1 <pxDelayedTaskList>
    1a52:	f0 91 c2 00 	lds	r31, 0x00C2	; 0x8000c2 <pxDelayedTaskList+0x1>
    1a56:	80 81       	ld	r24, Z
    1a58:	81 11       	cpse	r24, r1
    1a5a:	07 c0       	rjmp	.+14     	; 0x1a6a <xTaskIncrementTick+0x96>
    1a5c:	8f ef       	ldi	r24, 0xFF	; 255
    1a5e:	9f ef       	ldi	r25, 0xFF	; 255
    1a60:	90 93 a3 00 	sts	0x00A3, r25	; 0x8000a3 <xNextTaskUnblockTime+0x1>
    1a64:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <xNextTaskUnblockTime>
    1a68:	41 c0       	rjmp	.+130    	; 0x1aec <xTaskIncrementTick+0x118>
    1a6a:	e0 91 c1 00 	lds	r30, 0x00C1	; 0x8000c1 <pxDelayedTaskList>
    1a6e:	f0 91 c2 00 	lds	r31, 0x00C2	; 0x8000c2 <pxDelayedTaskList+0x1>
    1a72:	05 80       	ldd	r0, Z+5	; 0x05
    1a74:	f6 81       	ldd	r31, Z+6	; 0x06
    1a76:	e0 2d       	mov	r30, r0
    1a78:	c6 81       	ldd	r28, Z+6	; 0x06
    1a7a:	d7 81       	ldd	r29, Z+7	; 0x07
    1a7c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a7e:	9b 81       	ldd	r25, Y+3	; 0x03
    1a80:	e8 16       	cp	r14, r24
    1a82:	f9 06       	cpc	r15, r25
    1a84:	28 f4       	brcc	.+10     	; 0x1a90 <xTaskIncrementTick+0xbc>
    1a86:	90 93 a3 00 	sts	0x00A3, r25	; 0x8000a3 <xNextTaskUnblockTime+0x1>
    1a8a:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <xNextTaskUnblockTime>
    1a8e:	2e c0       	rjmp	.+92     	; 0x1aec <xTaskIncrementTick+0x118>
    1a90:	8e 01       	movw	r16, r28
    1a92:	0e 5f       	subi	r16, 0xFE	; 254
    1a94:	1f 4f       	sbci	r17, 0xFF	; 255
    1a96:	c8 01       	movw	r24, r16
    1a98:	0e 94 fe 05 	call	0xbfc	; 0xbfc <uxListRemove>
    1a9c:	8c 89       	ldd	r24, Y+20	; 0x14
    1a9e:	9d 89       	ldd	r25, Y+21	; 0x15
    1aa0:	89 2b       	or	r24, r25
    1aa2:	21 f0       	breq	.+8      	; 0x1aac <xTaskIncrementTick+0xd8>
    1aa4:	ce 01       	movw	r24, r28
    1aa6:	0c 96       	adiw	r24, 0x0c	; 12
    1aa8:	0e 94 fe 05 	call	0xbfc	; 0xbfc <uxListRemove>
    1aac:	8e 89       	ldd	r24, Y+22	; 0x16
    1aae:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <uxTopReadyPriority>
    1ab2:	98 17       	cp	r25, r24
    1ab4:	10 f4       	brcc	.+4      	; 0x1aba <xTaskIncrementTick+0xe6>
    1ab6:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <uxTopReadyPriority>
    1aba:	90 e0       	ldi	r25, 0x00	; 0
    1abc:	9c 01       	movw	r18, r24
    1abe:	22 0f       	add	r18, r18
    1ac0:	33 1f       	adc	r19, r19
    1ac2:	22 0f       	add	r18, r18
    1ac4:	33 1f       	adc	r19, r19
    1ac6:	22 0f       	add	r18, r18
    1ac8:	33 1f       	adc	r19, r19
    1aca:	82 0f       	add	r24, r18
    1acc:	93 1f       	adc	r25, r19
    1ace:	b8 01       	movw	r22, r16
    1ad0:	8b 52       	subi	r24, 0x2B	; 43
    1ad2:	9f 4f       	sbci	r25, 0xFF	; 255
    1ad4:	0e 94 ac 05 	call	0xb58	; 0xb58 <vListInsertEnd>
    1ad8:	9e 89       	ldd	r25, Y+22	; 0x16
    1ada:	e0 91 f9 00 	lds	r30, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1ade:	f0 91 fa 00 	lds	r31, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1ae2:	86 89       	ldd	r24, Z+22	; 0x16
    1ae4:	98 17       	cp	r25, r24
    1ae6:	08 f0       	brcs	.+2      	; 0x1aea <xTaskIncrementTick+0x116>
    1ae8:	ae cf       	rjmp	.-164    	; 0x1a46 <xTaskIncrementTick+0x72>
    1aea:	b1 cf       	rjmp	.-158    	; 0x1a4e <xTaskIncrementTick+0x7a>
    1aec:	e0 91 f9 00 	lds	r30, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1af0:	f0 91 fa 00 	lds	r31, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1af4:	86 89       	ldd	r24, Z+22	; 0x16
    1af6:	90 e0       	ldi	r25, 0x00	; 0
    1af8:	fc 01       	movw	r30, r24
    1afa:	ee 0f       	add	r30, r30
    1afc:	ff 1f       	adc	r31, r31
    1afe:	ee 0f       	add	r30, r30
    1b00:	ff 1f       	adc	r31, r31
    1b02:	ee 0f       	add	r30, r30
    1b04:	ff 1f       	adc	r31, r31
    1b06:	8e 0f       	add	r24, r30
    1b08:	9f 1f       	adc	r25, r31
    1b0a:	fc 01       	movw	r30, r24
    1b0c:	eb 52       	subi	r30, 0x2B	; 43
    1b0e:	ff 4f       	sbci	r31, 0xFF	; 255
    1b10:	80 81       	ld	r24, Z
    1b12:	82 30       	cpi	r24, 0x02	; 2
    1b14:	40 f4       	brcc	.+16     	; 0x1b26 <xTaskIncrementTick+0x152>
    1b16:	09 c0       	rjmp	.+18     	; 0x1b2a <xTaskIncrementTick+0x156>
    1b18:	80 91 a7 00 	lds	r24, 0x00A7	; 0x8000a7 <uxPendedTicks>
    1b1c:	8f 5f       	subi	r24, 0xFF	; 255
    1b1e:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <uxPendedTicks>
    1b22:	d1 2c       	mov	r13, r1
    1b24:	02 c0       	rjmp	.+4      	; 0x1b2a <xTaskIncrementTick+0x156>
    1b26:	dd 24       	eor	r13, r13
    1b28:	d3 94       	inc	r13
    1b2a:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <xYieldPending>
    1b2e:	88 23       	and	r24, r24
    1b30:	11 f0       	breq	.+4      	; 0x1b36 <xTaskIncrementTick+0x162>
    1b32:	dd 24       	eor	r13, r13
    1b34:	d3 94       	inc	r13
    1b36:	8d 2d       	mov	r24, r13
    1b38:	df 91       	pop	r29
    1b3a:	cf 91       	pop	r28
    1b3c:	1f 91       	pop	r17
    1b3e:	0f 91       	pop	r16
    1b40:	ff 90       	pop	r15
    1b42:	ef 90       	pop	r14
    1b44:	df 90       	pop	r13
    1b46:	08 95       	ret

00001b48 <xTaskResumeAll>:
    1b48:	0f 93       	push	r16
    1b4a:	1f 93       	push	r17
    1b4c:	cf 93       	push	r28
    1b4e:	df 93       	push	r29
    1b50:	0f b6       	in	r0, 0x3f	; 63
    1b52:	f8 94       	cli
    1b54:	0f 92       	push	r0
    1b56:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <uxSchedulerSuspended>
    1b5a:	81 50       	subi	r24, 0x01	; 1
    1b5c:	80 93 9f 00 	sts	0x009F, r24	; 0x80009f <uxSchedulerSuspended>
    1b60:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <uxSchedulerSuspended>
    1b64:	81 11       	cpse	r24, r1
    1b66:	58 c0       	rjmp	.+176    	; 0x1c18 <xTaskResumeAll+0xd0>
    1b68:	80 91 ac 00 	lds	r24, 0x00AC	; 0x8000ac <uxCurrentNumberOfTasks>
    1b6c:	81 11       	cpse	r24, r1
    1b6e:	33 c0       	rjmp	.+102    	; 0x1bd6 <xTaskResumeAll+0x8e>
    1b70:	56 c0       	rjmp	.+172    	; 0x1c1e <xTaskResumeAll+0xd6>
    1b72:	e0 91 bb 00 	lds	r30, 0x00BB	; 0x8000bb <xPendingReadyList+0x5>
    1b76:	f0 91 bc 00 	lds	r31, 0x00BC	; 0x8000bc <xPendingReadyList+0x6>
    1b7a:	c6 81       	ldd	r28, Z+6	; 0x06
    1b7c:	d7 81       	ldd	r29, Z+7	; 0x07
    1b7e:	ce 01       	movw	r24, r28
    1b80:	0c 96       	adiw	r24, 0x0c	; 12
    1b82:	0e 94 fe 05 	call	0xbfc	; 0xbfc <uxListRemove>
    1b86:	8e 01       	movw	r16, r28
    1b88:	0e 5f       	subi	r16, 0xFE	; 254
    1b8a:	1f 4f       	sbci	r17, 0xFF	; 255
    1b8c:	c8 01       	movw	r24, r16
    1b8e:	0e 94 fe 05 	call	0xbfc	; 0xbfc <uxListRemove>
    1b92:	8e 89       	ldd	r24, Y+22	; 0x16
    1b94:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <uxTopReadyPriority>
    1b98:	98 17       	cp	r25, r24
    1b9a:	10 f4       	brcc	.+4      	; 0x1ba0 <xTaskResumeAll+0x58>
    1b9c:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <uxTopReadyPriority>
    1ba0:	90 e0       	ldi	r25, 0x00	; 0
    1ba2:	9c 01       	movw	r18, r24
    1ba4:	22 0f       	add	r18, r18
    1ba6:	33 1f       	adc	r19, r19
    1ba8:	22 0f       	add	r18, r18
    1baa:	33 1f       	adc	r19, r19
    1bac:	22 0f       	add	r18, r18
    1bae:	33 1f       	adc	r19, r19
    1bb0:	82 0f       	add	r24, r18
    1bb2:	93 1f       	adc	r25, r19
    1bb4:	b8 01       	movw	r22, r16
    1bb6:	8b 52       	subi	r24, 0x2B	; 43
    1bb8:	9f 4f       	sbci	r25, 0xFF	; 255
    1bba:	0e 94 ac 05 	call	0xb58	; 0xb58 <vListInsertEnd>
    1bbe:	9e 89       	ldd	r25, Y+22	; 0x16
    1bc0:	e0 91 f9 00 	lds	r30, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1bc4:	f0 91 fa 00 	lds	r31, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1bc8:	86 89       	ldd	r24, Z+22	; 0x16
    1bca:	98 17       	cp	r25, r24
    1bcc:	30 f0       	brcs	.+12     	; 0x1bda <xTaskResumeAll+0x92>
    1bce:	81 e0       	ldi	r24, 0x01	; 1
    1bd0:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <xYieldPending>
    1bd4:	02 c0       	rjmp	.+4      	; 0x1bda <xTaskResumeAll+0x92>
    1bd6:	c0 e0       	ldi	r28, 0x00	; 0
    1bd8:	d0 e0       	ldi	r29, 0x00	; 0
    1bda:	80 91 b6 00 	lds	r24, 0x00B6	; 0x8000b6 <xPendingReadyList>
    1bde:	81 11       	cpse	r24, r1
    1be0:	c8 cf       	rjmp	.-112    	; 0x1b72 <xTaskResumeAll+0x2a>
    1be2:	cd 2b       	or	r28, r29
    1be4:	11 f0       	breq	.+4      	; 0x1bea <xTaskResumeAll+0xa2>
    1be6:	0e 94 ab 0a 	call	0x1556	; 0x1556 <prvResetNextTaskUnblockTime>
    1bea:	c0 91 a7 00 	lds	r28, 0x00A7	; 0x8000a7 <uxPendedTicks>
    1bee:	cc 23       	and	r28, r28
    1bf0:	59 f0       	breq	.+22     	; 0x1c08 <xTaskResumeAll+0xc0>
    1bf2:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <xTaskIncrementTick>
    1bf6:	88 23       	and	r24, r24
    1bf8:	19 f0       	breq	.+6      	; 0x1c00 <xTaskResumeAll+0xb8>
    1bfa:	81 e0       	ldi	r24, 0x01	; 1
    1bfc:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <xYieldPending>
    1c00:	c1 50       	subi	r28, 0x01	; 1
    1c02:	b9 f7       	brne	.-18     	; 0x1bf2 <xTaskResumeAll+0xaa>
    1c04:	10 92 a7 00 	sts	0x00A7, r1	; 0x8000a7 <uxPendedTicks>
    1c08:	80 91 a6 00 	lds	r24, 0x00A6	; 0x8000a6 <xYieldPending>
    1c0c:	88 23       	and	r24, r24
    1c0e:	31 f0       	breq	.+12     	; 0x1c1c <xTaskResumeAll+0xd4>
    1c10:	0e 94 c8 06 	call	0xd90	; 0xd90 <vPortYield>
    1c14:	81 e0       	ldi	r24, 0x01	; 1
    1c16:	03 c0       	rjmp	.+6      	; 0x1c1e <xTaskResumeAll+0xd6>
    1c18:	80 e0       	ldi	r24, 0x00	; 0
    1c1a:	01 c0       	rjmp	.+2      	; 0x1c1e <xTaskResumeAll+0xd6>
    1c1c:	80 e0       	ldi	r24, 0x00	; 0
    1c1e:	0f 90       	pop	r0
    1c20:	0f be       	out	0x3f, r0	; 63
    1c22:	df 91       	pop	r29
    1c24:	cf 91       	pop	r28
    1c26:	1f 91       	pop	r17
    1c28:	0f 91       	pop	r16
    1c2a:	08 95       	ret

00001c2c <vTaskDelay>:
    1c2c:	cf 93       	push	r28
    1c2e:	df 93       	push	r29
    1c30:	ec 01       	movw	r28, r24
    1c32:	89 2b       	or	r24, r25
    1c34:	49 f0       	breq	.+18     	; 0x1c48 <vTaskDelay+0x1c>
    1c36:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <vTaskSuspendAll>
    1c3a:	60 e0       	ldi	r22, 0x00	; 0
    1c3c:	ce 01       	movw	r24, r28
    1c3e:	0e 94 cc 0b 	call	0x1798	; 0x1798 <prvAddCurrentTaskToDelayedList>
    1c42:	0e 94 a4 0d 	call	0x1b48	; 0x1b48 <xTaskResumeAll>
    1c46:	01 c0       	rjmp	.+2      	; 0x1c4a <vTaskDelay+0x1e>
    1c48:	80 e0       	ldi	r24, 0x00	; 0
    1c4a:	81 11       	cpse	r24, r1
    1c4c:	02 c0       	rjmp	.+4      	; 0x1c52 <vTaskDelay+0x26>
    1c4e:	0e 94 c8 06 	call	0xd90	; 0xd90 <vPortYield>
    1c52:	df 91       	pop	r29
    1c54:	cf 91       	pop	r28
    1c56:	08 95       	ret

00001c58 <vTaskSwitchContext>:
    1c58:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <uxSchedulerSuspended>
    1c5c:	88 23       	and	r24, r24
    1c5e:	21 f0       	breq	.+8      	; 0x1c68 <vTaskSwitchContext+0x10>
    1c60:	81 e0       	ldi	r24, 0x01	; 1
    1c62:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <xYieldPending>
    1c66:	08 95       	ret
    1c68:	10 92 a6 00 	sts	0x00A6, r1	; 0x8000a6 <xYieldPending>
    1c6c:	20 91 a9 00 	lds	r18, 0x00A9	; 0x8000a9 <uxTopReadyPriority>
    1c70:	01 c0       	rjmp	.+2      	; 0x1c74 <vTaskSwitchContext+0x1c>
    1c72:	21 50       	subi	r18, 0x01	; 1
    1c74:	82 2f       	mov	r24, r18
    1c76:	90 e0       	ldi	r25, 0x00	; 0
    1c78:	fc 01       	movw	r30, r24
    1c7a:	ee 0f       	add	r30, r30
    1c7c:	ff 1f       	adc	r31, r31
    1c7e:	ee 0f       	add	r30, r30
    1c80:	ff 1f       	adc	r31, r31
    1c82:	ee 0f       	add	r30, r30
    1c84:	ff 1f       	adc	r31, r31
    1c86:	e8 0f       	add	r30, r24
    1c88:	f9 1f       	adc	r31, r25
    1c8a:	eb 52       	subi	r30, 0x2B	; 43
    1c8c:	ff 4f       	sbci	r31, 0xFF	; 255
    1c8e:	30 81       	ld	r19, Z
    1c90:	33 23       	and	r19, r19
    1c92:	79 f3       	breq	.-34     	; 0x1c72 <vTaskSwitchContext+0x1a>
    1c94:	ac 01       	movw	r20, r24
    1c96:	44 0f       	add	r20, r20
    1c98:	55 1f       	adc	r21, r21
    1c9a:	44 0f       	add	r20, r20
    1c9c:	55 1f       	adc	r21, r21
    1c9e:	44 0f       	add	r20, r20
    1ca0:	55 1f       	adc	r21, r21
    1ca2:	48 0f       	add	r20, r24
    1ca4:	59 1f       	adc	r21, r25
    1ca6:	df 01       	movw	r26, r30
    1ca8:	01 80       	ldd	r0, Z+1	; 0x01
    1caa:	f2 81       	ldd	r31, Z+2	; 0x02
    1cac:	e0 2d       	mov	r30, r0
    1cae:	02 80       	ldd	r0, Z+2	; 0x02
    1cb0:	f3 81       	ldd	r31, Z+3	; 0x03
    1cb2:	e0 2d       	mov	r30, r0
    1cb4:	12 96       	adiw	r26, 0x02	; 2
    1cb6:	fc 93       	st	X, r31
    1cb8:	ee 93       	st	-X, r30
    1cba:	11 97       	sbiw	r26, 0x01	; 1
    1cbc:	48 52       	subi	r20, 0x28	; 40
    1cbe:	5f 4f       	sbci	r21, 0xFF	; 255
    1cc0:	e4 17       	cp	r30, r20
    1cc2:	f5 07       	cpc	r31, r21
    1cc4:	29 f4       	brne	.+10     	; 0x1cd0 <vTaskSwitchContext+0x78>
    1cc6:	42 81       	ldd	r20, Z+2	; 0x02
    1cc8:	53 81       	ldd	r21, Z+3	; 0x03
    1cca:	fd 01       	movw	r30, r26
    1ccc:	52 83       	std	Z+2, r21	; 0x02
    1cce:	41 83       	std	Z+1, r20	; 0x01
    1cd0:	fc 01       	movw	r30, r24
    1cd2:	ee 0f       	add	r30, r30
    1cd4:	ff 1f       	adc	r31, r31
    1cd6:	ee 0f       	add	r30, r30
    1cd8:	ff 1f       	adc	r31, r31
    1cda:	ee 0f       	add	r30, r30
    1cdc:	ff 1f       	adc	r31, r31
    1cde:	8e 0f       	add	r24, r30
    1ce0:	9f 1f       	adc	r25, r31
    1ce2:	fc 01       	movw	r30, r24
    1ce4:	eb 52       	subi	r30, 0x2B	; 43
    1ce6:	ff 4f       	sbci	r31, 0xFF	; 255
    1ce8:	01 80       	ldd	r0, Z+1	; 0x01
    1cea:	f2 81       	ldd	r31, Z+2	; 0x02
    1cec:	e0 2d       	mov	r30, r0
    1cee:	86 81       	ldd	r24, Z+6	; 0x06
    1cf0:	97 81       	ldd	r25, Z+7	; 0x07
    1cf2:	90 93 fa 00 	sts	0x00FA, r25	; 0x8000fa <pxCurrentTCB+0x1>
    1cf6:	80 93 f9 00 	sts	0x00F9, r24	; 0x8000f9 <pxCurrentTCB>
    1cfa:	20 93 a9 00 	sts	0x00A9, r18	; 0x8000a9 <uxTopReadyPriority>
    1cfe:	08 95       	ret

00001d00 <vTaskSuspend>:
    1d00:	0f 93       	push	r16
    1d02:	1f 93       	push	r17
    1d04:	cf 93       	push	r28
    1d06:	df 93       	push	r29
    1d08:	ec 01       	movw	r28, r24
    1d0a:	0f b6       	in	r0, 0x3f	; 63
    1d0c:	f8 94       	cli
    1d0e:	0f 92       	push	r0
    1d10:	89 2b       	or	r24, r25
    1d12:	21 f4       	brne	.+8      	; 0x1d1c <vTaskSuspend+0x1c>
    1d14:	c0 91 f9 00 	lds	r28, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1d18:	d0 91 fa 00 	lds	r29, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1d1c:	8e 01       	movw	r16, r28
    1d1e:	0e 5f       	subi	r16, 0xFE	; 254
    1d20:	1f 4f       	sbci	r17, 0xFF	; 255
    1d22:	c8 01       	movw	r24, r16
    1d24:	0e 94 fe 05 	call	0xbfc	; 0xbfc <uxListRemove>
    1d28:	8c 89       	ldd	r24, Y+20	; 0x14
    1d2a:	9d 89       	ldd	r25, Y+21	; 0x15
    1d2c:	89 2b       	or	r24, r25
    1d2e:	21 f0       	breq	.+8      	; 0x1d38 <vTaskSuspend+0x38>
    1d30:	ce 01       	movw	r24, r28
    1d32:	0c 96       	adiw	r24, 0x0c	; 12
    1d34:	0e 94 fe 05 	call	0xbfc	; 0xbfc <uxListRemove>
    1d38:	b8 01       	movw	r22, r16
    1d3a:	8d ea       	ldi	r24, 0xAD	; 173
    1d3c:	90 e0       	ldi	r25, 0x00	; 0
    1d3e:	0e 94 ac 05 	call	0xb58	; 0xb58 <vListInsertEnd>
    1d42:	0f 90       	pop	r0
    1d44:	0f be       	out	0x3f, r0	; 63
    1d46:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <xSchedulerRunning>
    1d4a:	88 23       	and	r24, r24
    1d4c:	39 f0       	breq	.+14     	; 0x1d5c <vTaskSuspend+0x5c>
    1d4e:	0f b6       	in	r0, 0x3f	; 63
    1d50:	f8 94       	cli
    1d52:	0f 92       	push	r0
    1d54:	0e 94 ab 0a 	call	0x1556	; 0x1556 <prvResetNextTaskUnblockTime>
    1d58:	0f 90       	pop	r0
    1d5a:	0f be       	out	0x3f, r0	; 63
    1d5c:	80 91 f9 00 	lds	r24, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1d60:	90 91 fa 00 	lds	r25, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1d64:	c8 17       	cp	r28, r24
    1d66:	d9 07       	cpc	r29, r25
    1d68:	a1 f4       	brne	.+40     	; 0x1d92 <vTaskSuspend+0x92>
    1d6a:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <xSchedulerRunning>
    1d6e:	88 23       	and	r24, r24
    1d70:	19 f0       	breq	.+6      	; 0x1d78 <vTaskSuspend+0x78>
    1d72:	0e 94 c8 06 	call	0xd90	; 0xd90 <vPortYield>
    1d76:	0d c0       	rjmp	.+26     	; 0x1d92 <vTaskSuspend+0x92>
    1d78:	90 91 ad 00 	lds	r25, 0x00AD	; 0x8000ad <xSuspendedTaskList>
    1d7c:	80 91 ac 00 	lds	r24, 0x00AC	; 0x8000ac <uxCurrentNumberOfTasks>
    1d80:	98 13       	cpse	r25, r24
    1d82:	05 c0       	rjmp	.+10     	; 0x1d8e <vTaskSuspend+0x8e>
    1d84:	10 92 fa 00 	sts	0x00FA, r1	; 0x8000fa <pxCurrentTCB+0x1>
    1d88:	10 92 f9 00 	sts	0x00F9, r1	; 0x8000f9 <pxCurrentTCB>
    1d8c:	02 c0       	rjmp	.+4      	; 0x1d92 <vTaskSuspend+0x92>
    1d8e:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vTaskSwitchContext>
    1d92:	df 91       	pop	r29
    1d94:	cf 91       	pop	r28
    1d96:	1f 91       	pop	r17
    1d98:	0f 91       	pop	r16
    1d9a:	08 95       	ret

00001d9c <vTaskPlaceOnEventList>:
    1d9c:	cf 93       	push	r28
    1d9e:	df 93       	push	r29
    1da0:	eb 01       	movw	r28, r22
    1da2:	60 91 f9 00 	lds	r22, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1da6:	70 91 fa 00 	lds	r23, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1daa:	64 5f       	subi	r22, 0xF4	; 244
    1dac:	7f 4f       	sbci	r23, 0xFF	; 255
    1dae:	0e 94 cd 05 	call	0xb9a	; 0xb9a <vListInsert>
    1db2:	61 e0       	ldi	r22, 0x01	; 1
    1db4:	ce 01       	movw	r24, r28
    1db6:	0e 94 cc 0b 	call	0x1798	; 0x1798 <prvAddCurrentTaskToDelayedList>
    1dba:	df 91       	pop	r29
    1dbc:	cf 91       	pop	r28
    1dbe:	08 95       	ret

00001dc0 <xTaskRemoveFromEventList>:
    1dc0:	0f 93       	push	r16
    1dc2:	1f 93       	push	r17
    1dc4:	cf 93       	push	r28
    1dc6:	df 93       	push	r29
    1dc8:	dc 01       	movw	r26, r24
    1dca:	15 96       	adiw	r26, 0x05	; 5
    1dcc:	ed 91       	ld	r30, X+
    1dce:	fc 91       	ld	r31, X
    1dd0:	16 97       	sbiw	r26, 0x06	; 6
    1dd2:	c6 81       	ldd	r28, Z+6	; 0x06
    1dd4:	d7 81       	ldd	r29, Z+7	; 0x07
    1dd6:	8e 01       	movw	r16, r28
    1dd8:	04 5f       	subi	r16, 0xF4	; 244
    1dda:	1f 4f       	sbci	r17, 0xFF	; 255
    1ddc:	c8 01       	movw	r24, r16
    1dde:	0e 94 fe 05 	call	0xbfc	; 0xbfc <uxListRemove>
    1de2:	80 91 9f 00 	lds	r24, 0x009F	; 0x80009f <uxSchedulerSuspended>
    1de6:	81 11       	cpse	r24, r1
    1de8:	1c c0       	rjmp	.+56     	; 0x1e22 <xTaskRemoveFromEventList+0x62>
    1dea:	0a 50       	subi	r16, 0x0A	; 10
    1dec:	11 09       	sbc	r17, r1
    1dee:	c8 01       	movw	r24, r16
    1df0:	0e 94 fe 05 	call	0xbfc	; 0xbfc <uxListRemove>
    1df4:	8e 89       	ldd	r24, Y+22	; 0x16
    1df6:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <uxTopReadyPriority>
    1dfa:	98 17       	cp	r25, r24
    1dfc:	10 f4       	brcc	.+4      	; 0x1e02 <xTaskRemoveFromEventList+0x42>
    1dfe:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <uxTopReadyPriority>
    1e02:	90 e0       	ldi	r25, 0x00	; 0
    1e04:	9c 01       	movw	r18, r24
    1e06:	22 0f       	add	r18, r18
    1e08:	33 1f       	adc	r19, r19
    1e0a:	22 0f       	add	r18, r18
    1e0c:	33 1f       	adc	r19, r19
    1e0e:	22 0f       	add	r18, r18
    1e10:	33 1f       	adc	r19, r19
    1e12:	82 0f       	add	r24, r18
    1e14:	93 1f       	adc	r25, r19
    1e16:	b8 01       	movw	r22, r16
    1e18:	8b 52       	subi	r24, 0x2B	; 43
    1e1a:	9f 4f       	sbci	r25, 0xFF	; 255
    1e1c:	0e 94 ac 05 	call	0xb58	; 0xb58 <vListInsertEnd>
    1e20:	05 c0       	rjmp	.+10     	; 0x1e2c <xTaskRemoveFromEventList+0x6c>
    1e22:	b8 01       	movw	r22, r16
    1e24:	86 eb       	ldi	r24, 0xB6	; 182
    1e26:	90 e0       	ldi	r25, 0x00	; 0
    1e28:	0e 94 ac 05 	call	0xb58	; 0xb58 <vListInsertEnd>
    1e2c:	9e 89       	ldd	r25, Y+22	; 0x16
    1e2e:	e0 91 f9 00 	lds	r30, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1e32:	f0 91 fa 00 	lds	r31, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1e36:	86 89       	ldd	r24, Z+22	; 0x16
    1e38:	89 17       	cp	r24, r25
    1e3a:	20 f4       	brcc	.+8      	; 0x1e44 <xTaskRemoveFromEventList+0x84>
    1e3c:	81 e0       	ldi	r24, 0x01	; 1
    1e3e:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <xYieldPending>
    1e42:	01 c0       	rjmp	.+2      	; 0x1e46 <xTaskRemoveFromEventList+0x86>
    1e44:	80 e0       	ldi	r24, 0x00	; 0
    1e46:	df 91       	pop	r29
    1e48:	cf 91       	pop	r28
    1e4a:	1f 91       	pop	r17
    1e4c:	0f 91       	pop	r16
    1e4e:	08 95       	ret

00001e50 <vTaskSetTimeOutState>:
    1e50:	20 91 a5 00 	lds	r18, 0x00A5	; 0x8000a5 <xNumOfOverflows>
    1e54:	fc 01       	movw	r30, r24
    1e56:	20 83       	st	Z, r18
    1e58:	20 91 aa 00 	lds	r18, 0x00AA	; 0x8000aa <xTickCount>
    1e5c:	30 91 ab 00 	lds	r19, 0x00AB	; 0x8000ab <xTickCount+0x1>
    1e60:	32 83       	std	Z+2, r19	; 0x02
    1e62:	21 83       	std	Z+1, r18	; 0x01
    1e64:	08 95       	ret

00001e66 <xTaskCheckForTimeOut>:
    1e66:	0f b6       	in	r0, 0x3f	; 63
    1e68:	f8 94       	cli
    1e6a:	0f 92       	push	r0
    1e6c:	40 91 aa 00 	lds	r20, 0x00AA	; 0x8000aa <xTickCount>
    1e70:	50 91 ab 00 	lds	r21, 0x00AB	; 0x8000ab <xTickCount+0x1>
    1e74:	db 01       	movw	r26, r22
    1e76:	2d 91       	ld	r18, X+
    1e78:	3c 91       	ld	r19, X
    1e7a:	2f 3f       	cpi	r18, 0xFF	; 255
    1e7c:	bf ef       	ldi	r27, 0xFF	; 255
    1e7e:	3b 07       	cpc	r19, r27
    1e80:	19 f1       	breq	.+70     	; 0x1ec8 <xTaskCheckForTimeOut+0x62>
    1e82:	dc 01       	movw	r26, r24
    1e84:	fc 91       	ld	r31, X
    1e86:	e0 91 a5 00 	lds	r30, 0x00A5	; 0x8000a5 <xNumOfOverflows>
    1e8a:	fe 17       	cp	r31, r30
    1e8c:	39 f0       	breq	.+14     	; 0x1e9c <xTaskCheckForTimeOut+0x36>
    1e8e:	11 96       	adiw	r26, 0x01	; 1
    1e90:	ed 91       	ld	r30, X+
    1e92:	fc 91       	ld	r31, X
    1e94:	12 97       	sbiw	r26, 0x02	; 2
    1e96:	4e 17       	cp	r20, r30
    1e98:	5f 07       	cpc	r21, r31
    1e9a:	c0 f4       	brcc	.+48     	; 0x1ecc <xTaskCheckForTimeOut+0x66>
    1e9c:	dc 01       	movw	r26, r24
    1e9e:	11 96       	adiw	r26, 0x01	; 1
    1ea0:	ed 91       	ld	r30, X+
    1ea2:	fc 91       	ld	r31, X
    1ea4:	12 97       	sbiw	r26, 0x02	; 2
    1ea6:	da 01       	movw	r26, r20
    1ea8:	ae 1b       	sub	r26, r30
    1eaa:	bf 0b       	sbc	r27, r31
    1eac:	a2 17       	cp	r26, r18
    1eae:	b3 07       	cpc	r27, r19
    1eb0:	78 f4       	brcc	.+30     	; 0x1ed0 <xTaskCheckForTimeOut+0x6a>
    1eb2:	db 01       	movw	r26, r22
    1eb4:	e4 1b       	sub	r30, r20
    1eb6:	f5 0b       	sbc	r31, r21
    1eb8:	2e 0f       	add	r18, r30
    1eba:	3f 1f       	adc	r19, r31
    1ebc:	2d 93       	st	X+, r18
    1ebe:	3c 93       	st	X, r19
    1ec0:	0e 94 28 0f 	call	0x1e50	; 0x1e50 <vTaskSetTimeOutState>
    1ec4:	80 e0       	ldi	r24, 0x00	; 0
    1ec6:	05 c0       	rjmp	.+10     	; 0x1ed2 <xTaskCheckForTimeOut+0x6c>
    1ec8:	80 e0       	ldi	r24, 0x00	; 0
    1eca:	03 c0       	rjmp	.+6      	; 0x1ed2 <xTaskCheckForTimeOut+0x6c>
    1ecc:	81 e0       	ldi	r24, 0x01	; 1
    1ece:	01 c0       	rjmp	.+2      	; 0x1ed2 <xTaskCheckForTimeOut+0x6c>
    1ed0:	81 e0       	ldi	r24, 0x01	; 1
    1ed2:	0f 90       	pop	r0
    1ed4:	0f be       	out	0x3f, r0	; 63
    1ed6:	08 95       	ret

00001ed8 <vTaskMissedYield>:
    1ed8:	81 e0       	ldi	r24, 0x01	; 1
    1eda:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <xYieldPending>
    1ede:	08 95       	ret

00001ee0 <vTaskPriorityInherit>:
    1ee0:	0f 93       	push	r16
    1ee2:	1f 93       	push	r17
    1ee4:	cf 93       	push	r28
    1ee6:	df 93       	push	r29
    1ee8:	fc 01       	movw	r30, r24
    1eea:	89 2b       	or	r24, r25
    1eec:	09 f4       	brne	.+2      	; 0x1ef0 <vTaskPriorityInherit+0x10>
    1eee:	55 c0       	rjmp	.+170    	; 0x1f9a <vTaskPriorityInherit+0xba>
    1ef0:	26 89       	ldd	r18, Z+22	; 0x16
    1ef2:	a0 91 f9 00 	lds	r26, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1ef6:	b0 91 fa 00 	lds	r27, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1efa:	56 96       	adiw	r26, 0x16	; 22
    1efc:	8c 91       	ld	r24, X
    1efe:	28 17       	cp	r18, r24
    1f00:	08 f0       	brcs	.+2      	; 0x1f04 <vTaskPriorityInherit+0x24>
    1f02:	4b c0       	rjmp	.+150    	; 0x1f9a <vTaskPriorityInherit+0xba>
    1f04:	84 85       	ldd	r24, Z+12	; 0x0c
    1f06:	95 85       	ldd	r25, Z+13	; 0x0d
    1f08:	99 23       	and	r25, r25
    1f0a:	64 f0       	brlt	.+24     	; 0x1f24 <vTaskPriorityInherit+0x44>
    1f0c:	a0 91 f9 00 	lds	r26, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1f10:	b0 91 fa 00 	lds	r27, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1f14:	56 96       	adiw	r26, 0x16	; 22
    1f16:	3c 91       	ld	r19, X
    1f18:	84 e0       	ldi	r24, 0x04	; 4
    1f1a:	90 e0       	ldi	r25, 0x00	; 0
    1f1c:	83 1b       	sub	r24, r19
    1f1e:	91 09       	sbc	r25, r1
    1f20:	95 87       	std	Z+13, r25	; 0x0d
    1f22:	84 87       	std	Z+12, r24	; 0x0c
    1f24:	82 85       	ldd	r24, Z+10	; 0x0a
    1f26:	93 85       	ldd	r25, Z+11	; 0x0b
    1f28:	30 e0       	ldi	r19, 0x00	; 0
    1f2a:	a9 01       	movw	r20, r18
    1f2c:	44 0f       	add	r20, r20
    1f2e:	55 1f       	adc	r21, r21
    1f30:	44 0f       	add	r20, r20
    1f32:	55 1f       	adc	r21, r21
    1f34:	44 0f       	add	r20, r20
    1f36:	55 1f       	adc	r21, r21
    1f38:	24 0f       	add	r18, r20
    1f3a:	35 1f       	adc	r19, r21
    1f3c:	2b 52       	subi	r18, 0x2B	; 43
    1f3e:	3f 4f       	sbci	r19, 0xFF	; 255
    1f40:	82 17       	cp	r24, r18
    1f42:	93 07       	cpc	r25, r19
    1f44:	19 f5       	brne	.+70     	; 0x1f8c <vTaskPriorityInherit+0xac>
    1f46:	8f 01       	movw	r16, r30
    1f48:	ef 01       	movw	r28, r30
    1f4a:	22 96       	adiw	r28, 0x02	; 2
    1f4c:	ce 01       	movw	r24, r28
    1f4e:	0e 94 fe 05 	call	0xbfc	; 0xbfc <uxListRemove>
    1f52:	e0 91 f9 00 	lds	r30, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1f56:	f0 91 fa 00 	lds	r31, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1f5a:	86 89       	ldd	r24, Z+22	; 0x16
    1f5c:	f8 01       	movw	r30, r16
    1f5e:	86 8b       	std	Z+22, r24	; 0x16
    1f60:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <uxTopReadyPriority>
    1f64:	98 17       	cp	r25, r24
    1f66:	10 f4       	brcc	.+4      	; 0x1f6c <vTaskPriorityInherit+0x8c>
    1f68:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <uxTopReadyPriority>
    1f6c:	90 e0       	ldi	r25, 0x00	; 0
    1f6e:	9c 01       	movw	r18, r24
    1f70:	22 0f       	add	r18, r18
    1f72:	33 1f       	adc	r19, r19
    1f74:	22 0f       	add	r18, r18
    1f76:	33 1f       	adc	r19, r19
    1f78:	22 0f       	add	r18, r18
    1f7a:	33 1f       	adc	r19, r19
    1f7c:	82 0f       	add	r24, r18
    1f7e:	93 1f       	adc	r25, r19
    1f80:	be 01       	movw	r22, r28
    1f82:	8b 52       	subi	r24, 0x2B	; 43
    1f84:	9f 4f       	sbci	r25, 0xFF	; 255
    1f86:	0e 94 ac 05 	call	0xb58	; 0xb58 <vListInsertEnd>
    1f8a:	07 c0       	rjmp	.+14     	; 0x1f9a <vTaskPriorityInherit+0xba>
    1f8c:	a0 91 f9 00 	lds	r26, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    1f90:	b0 91 fa 00 	lds	r27, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    1f94:	56 96       	adiw	r26, 0x16	; 22
    1f96:	8c 91       	ld	r24, X
    1f98:	86 8b       	std	Z+22, r24	; 0x16
    1f9a:	df 91       	pop	r29
    1f9c:	cf 91       	pop	r28
    1f9e:	1f 91       	pop	r17
    1fa0:	0f 91       	pop	r16
    1fa2:	08 95       	ret

00001fa4 <xTaskPriorityDisinherit>:
    1fa4:	0f 93       	push	r16
    1fa6:	1f 93       	push	r17
    1fa8:	cf 93       	push	r28
    1faa:	df 93       	push	r29
    1fac:	fc 01       	movw	r30, r24
    1fae:	89 2b       	or	r24, r25
    1fb0:	79 f1       	breq	.+94     	; 0x2010 <xTaskPriorityDisinherit+0x6c>
    1fb2:	82 a1       	ldd	r24, Z+34	; 0x22
    1fb4:	81 50       	subi	r24, 0x01	; 1
    1fb6:	82 a3       	std	Z+34, r24	; 0x22
    1fb8:	26 89       	ldd	r18, Z+22	; 0x16
    1fba:	91 a1       	ldd	r25, Z+33	; 0x21
    1fbc:	29 17       	cp	r18, r25
    1fbe:	51 f1       	breq	.+84     	; 0x2014 <xTaskPriorityDisinherit+0x70>
    1fc0:	81 11       	cpse	r24, r1
    1fc2:	2a c0       	rjmp	.+84     	; 0x2018 <xTaskPriorityDisinherit+0x74>
    1fc4:	ef 01       	movw	r28, r30
    1fc6:	8f 01       	movw	r16, r30
    1fc8:	0e 5f       	subi	r16, 0xFE	; 254
    1fca:	1f 4f       	sbci	r17, 0xFF	; 255
    1fcc:	c8 01       	movw	r24, r16
    1fce:	0e 94 fe 05 	call	0xbfc	; 0xbfc <uxListRemove>
    1fd2:	89 a1       	ldd	r24, Y+33	; 0x21
    1fd4:	8e 8b       	std	Y+22, r24	; 0x16
    1fd6:	24 e0       	ldi	r18, 0x04	; 4
    1fd8:	30 e0       	ldi	r19, 0x00	; 0
    1fda:	28 1b       	sub	r18, r24
    1fdc:	31 09       	sbc	r19, r1
    1fde:	3d 87       	std	Y+13, r19	; 0x0d
    1fe0:	2c 87       	std	Y+12, r18	; 0x0c
    1fe2:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <uxTopReadyPriority>
    1fe6:	98 17       	cp	r25, r24
    1fe8:	10 f4       	brcc	.+4      	; 0x1fee <xTaskPriorityDisinherit+0x4a>
    1fea:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <uxTopReadyPriority>
    1fee:	90 e0       	ldi	r25, 0x00	; 0
    1ff0:	9c 01       	movw	r18, r24
    1ff2:	22 0f       	add	r18, r18
    1ff4:	33 1f       	adc	r19, r19
    1ff6:	22 0f       	add	r18, r18
    1ff8:	33 1f       	adc	r19, r19
    1ffa:	22 0f       	add	r18, r18
    1ffc:	33 1f       	adc	r19, r19
    1ffe:	82 0f       	add	r24, r18
    2000:	93 1f       	adc	r25, r19
    2002:	b8 01       	movw	r22, r16
    2004:	8b 52       	subi	r24, 0x2B	; 43
    2006:	9f 4f       	sbci	r25, 0xFF	; 255
    2008:	0e 94 ac 05 	call	0xb58	; 0xb58 <vListInsertEnd>
    200c:	81 e0       	ldi	r24, 0x01	; 1
    200e:	05 c0       	rjmp	.+10     	; 0x201a <xTaskPriorityDisinherit+0x76>
    2010:	80 e0       	ldi	r24, 0x00	; 0
    2012:	03 c0       	rjmp	.+6      	; 0x201a <xTaskPriorityDisinherit+0x76>
    2014:	80 e0       	ldi	r24, 0x00	; 0
    2016:	01 c0       	rjmp	.+2      	; 0x201a <xTaskPriorityDisinherit+0x76>
    2018:	80 e0       	ldi	r24, 0x00	; 0
    201a:	df 91       	pop	r29
    201c:	cf 91       	pop	r28
    201e:	1f 91       	pop	r17
    2020:	0f 91       	pop	r16
    2022:	08 95       	ret

00002024 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2024:	80 91 f9 00 	lds	r24, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    2028:	90 91 fa 00 	lds	r25, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    202c:	89 2b       	or	r24, r25
    202e:	39 f0       	breq	.+14     	; 0x203e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2030:	e0 91 f9 00 	lds	r30, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    2034:	f0 91 fa 00 	lds	r31, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
    2038:	82 a1       	ldd	r24, Z+34	; 0x22
    203a:	8f 5f       	subi	r24, 0xFF	; 255
    203c:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    203e:	80 91 f9 00 	lds	r24, 0x00F9	; 0x8000f9 <pxCurrentTCB>
    2042:	90 91 fa 00 	lds	r25, 0x00FA	; 0x8000fa <pxCurrentTCB+0x1>
	}
    2046:	08 95       	ret

00002048 <__udivmodsi4>:
    2048:	a1 e2       	ldi	r26, 0x21	; 33
    204a:	1a 2e       	mov	r1, r26
    204c:	aa 1b       	sub	r26, r26
    204e:	bb 1b       	sub	r27, r27
    2050:	fd 01       	movw	r30, r26
    2052:	0d c0       	rjmp	.+26     	; 0x206e <__udivmodsi4_ep>

00002054 <__udivmodsi4_loop>:
    2054:	aa 1f       	adc	r26, r26
    2056:	bb 1f       	adc	r27, r27
    2058:	ee 1f       	adc	r30, r30
    205a:	ff 1f       	adc	r31, r31
    205c:	a2 17       	cp	r26, r18
    205e:	b3 07       	cpc	r27, r19
    2060:	e4 07       	cpc	r30, r20
    2062:	f5 07       	cpc	r31, r21
    2064:	20 f0       	brcs	.+8      	; 0x206e <__udivmodsi4_ep>
    2066:	a2 1b       	sub	r26, r18
    2068:	b3 0b       	sbc	r27, r19
    206a:	e4 0b       	sbc	r30, r20
    206c:	f5 0b       	sbc	r31, r21

0000206e <__udivmodsi4_ep>:
    206e:	66 1f       	adc	r22, r22
    2070:	77 1f       	adc	r23, r23
    2072:	88 1f       	adc	r24, r24
    2074:	99 1f       	adc	r25, r25
    2076:	1a 94       	dec	r1
    2078:	69 f7       	brne	.-38     	; 0x2054 <__udivmodsi4_loop>
    207a:	60 95       	com	r22
    207c:	70 95       	com	r23
    207e:	80 95       	com	r24
    2080:	90 95       	com	r25
    2082:	9b 01       	movw	r18, r22
    2084:	ac 01       	movw	r20, r24
    2086:	bd 01       	movw	r22, r26
    2088:	cf 01       	movw	r24, r30
    208a:	08 95       	ret

0000208c <__ashrdi3>:
    208c:	97 fb       	bst	r25, 7
    208e:	10 f8       	bld	r1, 0

00002090 <__lshrdi3>:
    2090:	16 94       	lsr	r1
    2092:	00 08       	sbc	r0, r0
    2094:	0f 93       	push	r16
    2096:	08 30       	cpi	r16, 0x08	; 8
    2098:	98 f0       	brcs	.+38     	; 0x20c0 <__lshrdi3+0x30>
    209a:	08 50       	subi	r16, 0x08	; 8
    209c:	23 2f       	mov	r18, r19
    209e:	34 2f       	mov	r19, r20
    20a0:	45 2f       	mov	r20, r21
    20a2:	56 2f       	mov	r21, r22
    20a4:	67 2f       	mov	r22, r23
    20a6:	78 2f       	mov	r23, r24
    20a8:	89 2f       	mov	r24, r25
    20aa:	90 2d       	mov	r25, r0
    20ac:	f4 cf       	rjmp	.-24     	; 0x2096 <__lshrdi3+0x6>
    20ae:	05 94       	asr	r0
    20b0:	97 95       	ror	r25
    20b2:	87 95       	ror	r24
    20b4:	77 95       	ror	r23
    20b6:	67 95       	ror	r22
    20b8:	57 95       	ror	r21
    20ba:	47 95       	ror	r20
    20bc:	37 95       	ror	r19
    20be:	27 95       	ror	r18
    20c0:	0a 95       	dec	r16
    20c2:	aa f7       	brpl	.-22     	; 0x20ae <__lshrdi3+0x1e>
    20c4:	0f 91       	pop	r16
    20c6:	08 95       	ret

000020c8 <__adddi3_s8>:
    20c8:	00 24       	eor	r0, r0
    20ca:	a7 fd       	sbrc	r26, 7
    20cc:	00 94       	com	r0
    20ce:	2a 0f       	add	r18, r26
    20d0:	30 1d       	adc	r19, r0
    20d2:	40 1d       	adc	r20, r0
    20d4:	50 1d       	adc	r21, r0
    20d6:	60 1d       	adc	r22, r0
    20d8:	70 1d       	adc	r23, r0
    20da:	80 1d       	adc	r24, r0
    20dc:	90 1d       	adc	r25, r0
    20de:	08 95       	ret

000020e0 <malloc>:
    20e0:	0f 93       	push	r16
    20e2:	1f 93       	push	r17
    20e4:	cf 93       	push	r28
    20e6:	df 93       	push	r29
    20e8:	82 30       	cpi	r24, 0x02	; 2
    20ea:	91 05       	cpc	r25, r1
    20ec:	10 f4       	brcc	.+4      	; 0x20f2 <malloc+0x12>
    20ee:	82 e0       	ldi	r24, 0x02	; 2
    20f0:	90 e0       	ldi	r25, 0x00	; 0
    20f2:	e0 91 13 01 	lds	r30, 0x0113	; 0x800113 <__flp>
    20f6:	f0 91 14 01 	lds	r31, 0x0114	; 0x800114 <__flp+0x1>
    20fa:	20 e0       	ldi	r18, 0x00	; 0
    20fc:	30 e0       	ldi	r19, 0x00	; 0
    20fe:	a0 e0       	ldi	r26, 0x00	; 0
    2100:	b0 e0       	ldi	r27, 0x00	; 0
    2102:	30 97       	sbiw	r30, 0x00	; 0
    2104:	19 f1       	breq	.+70     	; 0x214c <malloc+0x6c>
    2106:	40 81       	ld	r20, Z
    2108:	51 81       	ldd	r21, Z+1	; 0x01
    210a:	02 81       	ldd	r16, Z+2	; 0x02
    210c:	13 81       	ldd	r17, Z+3	; 0x03
    210e:	48 17       	cp	r20, r24
    2110:	59 07       	cpc	r21, r25
    2112:	c8 f0       	brcs	.+50     	; 0x2146 <malloc+0x66>
    2114:	84 17       	cp	r24, r20
    2116:	95 07       	cpc	r25, r21
    2118:	69 f4       	brne	.+26     	; 0x2134 <malloc+0x54>
    211a:	10 97       	sbiw	r26, 0x00	; 0
    211c:	31 f0       	breq	.+12     	; 0x212a <malloc+0x4a>
    211e:	12 96       	adiw	r26, 0x02	; 2
    2120:	0c 93       	st	X, r16
    2122:	12 97       	sbiw	r26, 0x02	; 2
    2124:	13 96       	adiw	r26, 0x03	; 3
    2126:	1c 93       	st	X, r17
    2128:	27 c0       	rjmp	.+78     	; 0x2178 <malloc+0x98>
    212a:	00 93 13 01 	sts	0x0113, r16	; 0x800113 <__flp>
    212e:	10 93 14 01 	sts	0x0114, r17	; 0x800114 <__flp+0x1>
    2132:	22 c0       	rjmp	.+68     	; 0x2178 <malloc+0x98>
    2134:	21 15       	cp	r18, r1
    2136:	31 05       	cpc	r19, r1
    2138:	19 f0       	breq	.+6      	; 0x2140 <malloc+0x60>
    213a:	42 17       	cp	r20, r18
    213c:	53 07       	cpc	r21, r19
    213e:	18 f4       	brcc	.+6      	; 0x2146 <malloc+0x66>
    2140:	9a 01       	movw	r18, r20
    2142:	bd 01       	movw	r22, r26
    2144:	ef 01       	movw	r28, r30
    2146:	df 01       	movw	r26, r30
    2148:	f8 01       	movw	r30, r16
    214a:	db cf       	rjmp	.-74     	; 0x2102 <malloc+0x22>
    214c:	21 15       	cp	r18, r1
    214e:	31 05       	cpc	r19, r1
    2150:	f9 f0       	breq	.+62     	; 0x2190 <malloc+0xb0>
    2152:	28 1b       	sub	r18, r24
    2154:	39 0b       	sbc	r19, r25
    2156:	24 30       	cpi	r18, 0x04	; 4
    2158:	31 05       	cpc	r19, r1
    215a:	80 f4       	brcc	.+32     	; 0x217c <malloc+0x9c>
    215c:	8a 81       	ldd	r24, Y+2	; 0x02
    215e:	9b 81       	ldd	r25, Y+3	; 0x03
    2160:	61 15       	cp	r22, r1
    2162:	71 05       	cpc	r23, r1
    2164:	21 f0       	breq	.+8      	; 0x216e <malloc+0x8e>
    2166:	fb 01       	movw	r30, r22
    2168:	93 83       	std	Z+3, r25	; 0x03
    216a:	82 83       	std	Z+2, r24	; 0x02
    216c:	04 c0       	rjmp	.+8      	; 0x2176 <malloc+0x96>
    216e:	90 93 14 01 	sts	0x0114, r25	; 0x800114 <__flp+0x1>
    2172:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <__flp>
    2176:	fe 01       	movw	r30, r28
    2178:	32 96       	adiw	r30, 0x02	; 2
    217a:	44 c0       	rjmp	.+136    	; 0x2204 <malloc+0x124>
    217c:	fe 01       	movw	r30, r28
    217e:	e2 0f       	add	r30, r18
    2180:	f3 1f       	adc	r31, r19
    2182:	81 93       	st	Z+, r24
    2184:	91 93       	st	Z+, r25
    2186:	22 50       	subi	r18, 0x02	; 2
    2188:	31 09       	sbc	r19, r1
    218a:	39 83       	std	Y+1, r19	; 0x01
    218c:	28 83       	st	Y, r18
    218e:	3a c0       	rjmp	.+116    	; 0x2204 <malloc+0x124>
    2190:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <__brkval>
    2194:	30 91 12 01 	lds	r19, 0x0112	; 0x800112 <__brkval+0x1>
    2198:	23 2b       	or	r18, r19
    219a:	41 f4       	brne	.+16     	; 0x21ac <malloc+0xcc>
    219c:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__malloc_heap_start>
    21a0:	30 91 63 00 	lds	r19, 0x0063	; 0x800063 <__malloc_heap_start+0x1>
    21a4:	30 93 12 01 	sts	0x0112, r19	; 0x800112 <__brkval+0x1>
    21a8:	20 93 11 01 	sts	0x0111, r18	; 0x800111 <__brkval>
    21ac:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    21b0:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    21b4:	21 15       	cp	r18, r1
    21b6:	31 05       	cpc	r19, r1
    21b8:	41 f4       	brne	.+16     	; 0x21ca <malloc+0xea>
    21ba:	2d b7       	in	r18, 0x3d	; 61
    21bc:	3e b7       	in	r19, 0x3e	; 62
    21be:	40 91 64 00 	lds	r20, 0x0064	; 0x800064 <__malloc_margin>
    21c2:	50 91 65 00 	lds	r21, 0x0065	; 0x800065 <__malloc_margin+0x1>
    21c6:	24 1b       	sub	r18, r20
    21c8:	35 0b       	sbc	r19, r21
    21ca:	e0 91 11 01 	lds	r30, 0x0111	; 0x800111 <__brkval>
    21ce:	f0 91 12 01 	lds	r31, 0x0112	; 0x800112 <__brkval+0x1>
    21d2:	e2 17       	cp	r30, r18
    21d4:	f3 07       	cpc	r31, r19
    21d6:	a0 f4       	brcc	.+40     	; 0x2200 <malloc+0x120>
    21d8:	2e 1b       	sub	r18, r30
    21da:	3f 0b       	sbc	r19, r31
    21dc:	28 17       	cp	r18, r24
    21de:	39 07       	cpc	r19, r25
    21e0:	78 f0       	brcs	.+30     	; 0x2200 <malloc+0x120>
    21e2:	ac 01       	movw	r20, r24
    21e4:	4e 5f       	subi	r20, 0xFE	; 254
    21e6:	5f 4f       	sbci	r21, 0xFF	; 255
    21e8:	24 17       	cp	r18, r20
    21ea:	35 07       	cpc	r19, r21
    21ec:	48 f0       	brcs	.+18     	; 0x2200 <malloc+0x120>
    21ee:	4e 0f       	add	r20, r30
    21f0:	5f 1f       	adc	r21, r31
    21f2:	50 93 12 01 	sts	0x0112, r21	; 0x800112 <__brkval+0x1>
    21f6:	40 93 11 01 	sts	0x0111, r20	; 0x800111 <__brkval>
    21fa:	81 93       	st	Z+, r24
    21fc:	91 93       	st	Z+, r25
    21fe:	02 c0       	rjmp	.+4      	; 0x2204 <malloc+0x124>
    2200:	e0 e0       	ldi	r30, 0x00	; 0
    2202:	f0 e0       	ldi	r31, 0x00	; 0
    2204:	cf 01       	movw	r24, r30
    2206:	df 91       	pop	r29
    2208:	cf 91       	pop	r28
    220a:	1f 91       	pop	r17
    220c:	0f 91       	pop	r16
    220e:	08 95       	ret

00002210 <free>:
    2210:	cf 93       	push	r28
    2212:	df 93       	push	r29
    2214:	00 97       	sbiw	r24, 0x00	; 0
    2216:	09 f4       	brne	.+2      	; 0x221a <free+0xa>
    2218:	81 c0       	rjmp	.+258    	; 0x231c <free+0x10c>
    221a:	fc 01       	movw	r30, r24
    221c:	32 97       	sbiw	r30, 0x02	; 2
    221e:	13 82       	std	Z+3, r1	; 0x03
    2220:	12 82       	std	Z+2, r1	; 0x02
    2222:	a0 91 13 01 	lds	r26, 0x0113	; 0x800113 <__flp>
    2226:	b0 91 14 01 	lds	r27, 0x0114	; 0x800114 <__flp+0x1>
    222a:	10 97       	sbiw	r26, 0x00	; 0
    222c:	81 f4       	brne	.+32     	; 0x224e <free+0x3e>
    222e:	20 81       	ld	r18, Z
    2230:	31 81       	ldd	r19, Z+1	; 0x01
    2232:	82 0f       	add	r24, r18
    2234:	93 1f       	adc	r25, r19
    2236:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <__brkval>
    223a:	30 91 12 01 	lds	r19, 0x0112	; 0x800112 <__brkval+0x1>
    223e:	28 17       	cp	r18, r24
    2240:	39 07       	cpc	r19, r25
    2242:	51 f5       	brne	.+84     	; 0x2298 <free+0x88>
    2244:	f0 93 12 01 	sts	0x0112, r31	; 0x800112 <__brkval+0x1>
    2248:	e0 93 11 01 	sts	0x0111, r30	; 0x800111 <__brkval>
    224c:	67 c0       	rjmp	.+206    	; 0x231c <free+0x10c>
    224e:	ed 01       	movw	r28, r26
    2250:	20 e0       	ldi	r18, 0x00	; 0
    2252:	30 e0       	ldi	r19, 0x00	; 0
    2254:	ce 17       	cp	r28, r30
    2256:	df 07       	cpc	r29, r31
    2258:	40 f4       	brcc	.+16     	; 0x226a <free+0x5a>
    225a:	4a 81       	ldd	r20, Y+2	; 0x02
    225c:	5b 81       	ldd	r21, Y+3	; 0x03
    225e:	9e 01       	movw	r18, r28
    2260:	41 15       	cp	r20, r1
    2262:	51 05       	cpc	r21, r1
    2264:	f1 f0       	breq	.+60     	; 0x22a2 <free+0x92>
    2266:	ea 01       	movw	r28, r20
    2268:	f5 cf       	rjmp	.-22     	; 0x2254 <free+0x44>
    226a:	d3 83       	std	Z+3, r29	; 0x03
    226c:	c2 83       	std	Z+2, r28	; 0x02
    226e:	40 81       	ld	r20, Z
    2270:	51 81       	ldd	r21, Z+1	; 0x01
    2272:	84 0f       	add	r24, r20
    2274:	95 1f       	adc	r25, r21
    2276:	c8 17       	cp	r28, r24
    2278:	d9 07       	cpc	r29, r25
    227a:	59 f4       	brne	.+22     	; 0x2292 <free+0x82>
    227c:	88 81       	ld	r24, Y
    227e:	99 81       	ldd	r25, Y+1	; 0x01
    2280:	84 0f       	add	r24, r20
    2282:	95 1f       	adc	r25, r21
    2284:	02 96       	adiw	r24, 0x02	; 2
    2286:	91 83       	std	Z+1, r25	; 0x01
    2288:	80 83       	st	Z, r24
    228a:	8a 81       	ldd	r24, Y+2	; 0x02
    228c:	9b 81       	ldd	r25, Y+3	; 0x03
    228e:	93 83       	std	Z+3, r25	; 0x03
    2290:	82 83       	std	Z+2, r24	; 0x02
    2292:	21 15       	cp	r18, r1
    2294:	31 05       	cpc	r19, r1
    2296:	29 f4       	brne	.+10     	; 0x22a2 <free+0x92>
    2298:	f0 93 14 01 	sts	0x0114, r31	; 0x800114 <__flp+0x1>
    229c:	e0 93 13 01 	sts	0x0113, r30	; 0x800113 <__flp>
    22a0:	3d c0       	rjmp	.+122    	; 0x231c <free+0x10c>
    22a2:	e9 01       	movw	r28, r18
    22a4:	fb 83       	std	Y+3, r31	; 0x03
    22a6:	ea 83       	std	Y+2, r30	; 0x02
    22a8:	49 91       	ld	r20, Y+
    22aa:	59 91       	ld	r21, Y+
    22ac:	c4 0f       	add	r28, r20
    22ae:	d5 1f       	adc	r29, r21
    22b0:	ec 17       	cp	r30, r28
    22b2:	fd 07       	cpc	r31, r29
    22b4:	61 f4       	brne	.+24     	; 0x22ce <free+0xbe>
    22b6:	80 81       	ld	r24, Z
    22b8:	91 81       	ldd	r25, Z+1	; 0x01
    22ba:	84 0f       	add	r24, r20
    22bc:	95 1f       	adc	r25, r21
    22be:	02 96       	adiw	r24, 0x02	; 2
    22c0:	e9 01       	movw	r28, r18
    22c2:	99 83       	std	Y+1, r25	; 0x01
    22c4:	88 83       	st	Y, r24
    22c6:	82 81       	ldd	r24, Z+2	; 0x02
    22c8:	93 81       	ldd	r25, Z+3	; 0x03
    22ca:	9b 83       	std	Y+3, r25	; 0x03
    22cc:	8a 83       	std	Y+2, r24	; 0x02
    22ce:	e0 e0       	ldi	r30, 0x00	; 0
    22d0:	f0 e0       	ldi	r31, 0x00	; 0
    22d2:	12 96       	adiw	r26, 0x02	; 2
    22d4:	8d 91       	ld	r24, X+
    22d6:	9c 91       	ld	r25, X
    22d8:	13 97       	sbiw	r26, 0x03	; 3
    22da:	00 97       	sbiw	r24, 0x00	; 0
    22dc:	19 f0       	breq	.+6      	; 0x22e4 <free+0xd4>
    22de:	fd 01       	movw	r30, r26
    22e0:	dc 01       	movw	r26, r24
    22e2:	f7 cf       	rjmp	.-18     	; 0x22d2 <free+0xc2>
    22e4:	8d 91       	ld	r24, X+
    22e6:	9c 91       	ld	r25, X
    22e8:	11 97       	sbiw	r26, 0x01	; 1
    22ea:	9d 01       	movw	r18, r26
    22ec:	2e 5f       	subi	r18, 0xFE	; 254
    22ee:	3f 4f       	sbci	r19, 0xFF	; 255
    22f0:	82 0f       	add	r24, r18
    22f2:	93 1f       	adc	r25, r19
    22f4:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <__brkval>
    22f8:	30 91 12 01 	lds	r19, 0x0112	; 0x800112 <__brkval+0x1>
    22fc:	28 17       	cp	r18, r24
    22fe:	39 07       	cpc	r19, r25
    2300:	69 f4       	brne	.+26     	; 0x231c <free+0x10c>
    2302:	30 97       	sbiw	r30, 0x00	; 0
    2304:	29 f4       	brne	.+10     	; 0x2310 <free+0x100>
    2306:	10 92 14 01 	sts	0x0114, r1	; 0x800114 <__flp+0x1>
    230a:	10 92 13 01 	sts	0x0113, r1	; 0x800113 <__flp>
    230e:	02 c0       	rjmp	.+4      	; 0x2314 <free+0x104>
    2310:	13 82       	std	Z+3, r1	; 0x03
    2312:	12 82       	std	Z+2, r1	; 0x02
    2314:	b0 93 12 01 	sts	0x0112, r27	; 0x800112 <__brkval+0x1>
    2318:	a0 93 11 01 	sts	0x0111, r26	; 0x800111 <__brkval>
    231c:	df 91       	pop	r29
    231e:	cf 91       	pop	r28
    2320:	08 95       	ret

00002322 <memcpy>:
    2322:	fb 01       	movw	r30, r22
    2324:	dc 01       	movw	r26, r24
    2326:	02 c0       	rjmp	.+4      	; 0x232c <memcpy+0xa>
    2328:	01 90       	ld	r0, Z+
    232a:	0d 92       	st	X+, r0
    232c:	41 50       	subi	r20, 0x01	; 1
    232e:	50 40       	sbci	r21, 0x00	; 0
    2330:	d8 f7       	brcc	.-10     	; 0x2328 <memcpy+0x6>
    2332:	08 95       	ret

00002334 <_exit>:
    2334:	f8 94       	cli

00002336 <__stop_program>:
    2336:	ff cf       	rjmp	.-2      	; 0x2336 <__stop_program>
